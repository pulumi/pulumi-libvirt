// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package libvirt

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Manages a VM network resource within libvirt. For more information see
// [the official documentation](https://libvirt.org/formatnetwork.html).
type Network struct {
	pulumi.CustomResourceState

	// A list of (0 or 1) IPv4 and (0 or 1) IPv6 subnets in
	// CIDR notation.  This defines the subnets associated to that network.
	// This argument is also used to define the address on the real host.
	// If `dhcp {  enabled = true }` addresses is also used to define the address range served by
	// the DHCP server.
	// No DHCP server will be started if `addresses` is omitted.
	Addresses pulumi.StringArrayOutput `pulumi:"addresses"`
	// Set to `true` to start the network on host boot up.
	// If not specified `false` is assumed.
	Autostart pulumi.BoolPtrOutput `pulumi:"autostart"`
	// The bridge device defines the name of a bridge
	// device which will be used to construct the virtual network (when not provided,
	// it will be automatically obtained by libvirt in `none`, `nat` and `route` modes).
	Bridge pulumi.StringOutput `pulumi:"bridge"`
	// DHCP configuration.
	// You need to use it in conjuction with the adresses variable.
	Dhcp NetworkDhcpPtrOutput `pulumi:"dhcp"`
	// configuration of DNS specific settings for the network
	Dns NetworkDnsPtrOutput `pulumi:"dns"`
	// configuration of Dnsmasq options for the network
	// You need to provide a list of option name and value pairs.
	DnsmasqOptions NetworkDnsmasqOptionsPtrOutput `pulumi:"dnsmasqOptions"`
	// The domain used by the DNS server.
	Domain pulumi.StringPtrOutput `pulumi:"domain"`
	// One of:
	// - `none`: the guests can talk to each other and the host OS, but cannot reach
	//   any other machines on the LAN.
	// - `nat`: it is the default network mode. This is a configuration that
	//   allows guest OS to get outbound connectivity regardless of whether the host
	//   uses ethernet, wireless, dialup, or VPN networking without requiring any
	//   specific admin configuration. In the absence of host networking, it at
	//   least allows guests to talk directly to each other.
	// - `route`: this is a variant on the default network which routes traffic from
	//   the virtual network to the LAN **without applying any NAT**. It requires that
	//   the IP address range be pre-configured in the routing tables of the router
	//   on the host network.
	// - `bridge`: use a pre-existing host bridge. The guests will effectively be
	//   directly connected to the physical network (i.e. their IP addresses will
	//   all be on the subnet of the physical network, and there will be no
	//   restrictions on inbound or outbound connections). The `bridge` network
	//   attribute is mandatory in this case.
	Mode pulumi.StringPtrOutput `pulumi:"mode"`
	// The MTU to set for the underlying network interfaces. When
	// not supplied, libvirt will use the default for the interface, usually 1500.
	// Libvirt version 5.1 and greater will advertise this value to nodes via DHCP.
	Mtu pulumi.IntPtrOutput `pulumi:"mtu"`
	// A unique name for the resource, required by libvirt.
	// Changing this forces a new resource to be created.
	Name pulumi.StringOutput `pulumi:"name"`
	// a list of static routes. A `cidr` and a `gateway` must
	// be provided. The `gateway` must be reachable via the bridge interface.
	Routes NetworkRouteArrayOutput `pulumi:"routes"`
	Xml    NetworkXmlPtrOutput     `pulumi:"xml"`
}

// NewNetwork registers a new resource with the given unique name, arguments, and options.
func NewNetwork(ctx *pulumi.Context,
	name string, args *NetworkArgs, opts ...pulumi.ResourceOption) (*Network, error) {
	if args == nil {
		args = &NetworkArgs{}
	}

	var resource Network
	err := ctx.RegisterResource("libvirt:index/network:Network", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetNetwork gets an existing Network resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetNetwork(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *NetworkState, opts ...pulumi.ResourceOption) (*Network, error) {
	var resource Network
	err := ctx.ReadResource("libvirt:index/network:Network", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Network resources.
type networkState struct {
	// A list of (0 or 1) IPv4 and (0 or 1) IPv6 subnets in
	// CIDR notation.  This defines the subnets associated to that network.
	// This argument is also used to define the address on the real host.
	// If `dhcp {  enabled = true }` addresses is also used to define the address range served by
	// the DHCP server.
	// No DHCP server will be started if `addresses` is omitted.
	Addresses []string `pulumi:"addresses"`
	// Set to `true` to start the network on host boot up.
	// If not specified `false` is assumed.
	Autostart *bool `pulumi:"autostart"`
	// The bridge device defines the name of a bridge
	// device which will be used to construct the virtual network (when not provided,
	// it will be automatically obtained by libvirt in `none`, `nat` and `route` modes).
	Bridge *string `pulumi:"bridge"`
	// DHCP configuration.
	// You need to use it in conjuction with the adresses variable.
	Dhcp *NetworkDhcp `pulumi:"dhcp"`
	// configuration of DNS specific settings for the network
	Dns *NetworkDns `pulumi:"dns"`
	// configuration of Dnsmasq options for the network
	// You need to provide a list of option name and value pairs.
	DnsmasqOptions *NetworkDnsmasqOptions `pulumi:"dnsmasqOptions"`
	// The domain used by the DNS server.
	Domain *string `pulumi:"domain"`
	// One of:
	// - `none`: the guests can talk to each other and the host OS, but cannot reach
	//   any other machines on the LAN.
	// - `nat`: it is the default network mode. This is a configuration that
	//   allows guest OS to get outbound connectivity regardless of whether the host
	//   uses ethernet, wireless, dialup, or VPN networking without requiring any
	//   specific admin configuration. In the absence of host networking, it at
	//   least allows guests to talk directly to each other.
	// - `route`: this is a variant on the default network which routes traffic from
	//   the virtual network to the LAN **without applying any NAT**. It requires that
	//   the IP address range be pre-configured in the routing tables of the router
	//   on the host network.
	// - `bridge`: use a pre-existing host bridge. The guests will effectively be
	//   directly connected to the physical network (i.e. their IP addresses will
	//   all be on the subnet of the physical network, and there will be no
	//   restrictions on inbound or outbound connections). The `bridge` network
	//   attribute is mandatory in this case.
	Mode *string `pulumi:"mode"`
	// The MTU to set for the underlying network interfaces. When
	// not supplied, libvirt will use the default for the interface, usually 1500.
	// Libvirt version 5.1 and greater will advertise this value to nodes via DHCP.
	Mtu *int `pulumi:"mtu"`
	// A unique name for the resource, required by libvirt.
	// Changing this forces a new resource to be created.
	Name *string `pulumi:"name"`
	// a list of static routes. A `cidr` and a `gateway` must
	// be provided. The `gateway` must be reachable via the bridge interface.
	Routes []NetworkRoute `pulumi:"routes"`
	Xml    *NetworkXml    `pulumi:"xml"`
}

type NetworkState struct {
	// A list of (0 or 1) IPv4 and (0 or 1) IPv6 subnets in
	// CIDR notation.  This defines the subnets associated to that network.
	// This argument is also used to define the address on the real host.
	// If `dhcp {  enabled = true }` addresses is also used to define the address range served by
	// the DHCP server.
	// No DHCP server will be started if `addresses` is omitted.
	Addresses pulumi.StringArrayInput
	// Set to `true` to start the network on host boot up.
	// If not specified `false` is assumed.
	Autostart pulumi.BoolPtrInput
	// The bridge device defines the name of a bridge
	// device which will be used to construct the virtual network (when not provided,
	// it will be automatically obtained by libvirt in `none`, `nat` and `route` modes).
	Bridge pulumi.StringPtrInput
	// DHCP configuration.
	// You need to use it in conjuction with the adresses variable.
	Dhcp NetworkDhcpPtrInput
	// configuration of DNS specific settings for the network
	Dns NetworkDnsPtrInput
	// configuration of Dnsmasq options for the network
	// You need to provide a list of option name and value pairs.
	DnsmasqOptions NetworkDnsmasqOptionsPtrInput
	// The domain used by the DNS server.
	Domain pulumi.StringPtrInput
	// One of:
	// - `none`: the guests can talk to each other and the host OS, but cannot reach
	//   any other machines on the LAN.
	// - `nat`: it is the default network mode. This is a configuration that
	//   allows guest OS to get outbound connectivity regardless of whether the host
	//   uses ethernet, wireless, dialup, or VPN networking without requiring any
	//   specific admin configuration. In the absence of host networking, it at
	//   least allows guests to talk directly to each other.
	// - `route`: this is a variant on the default network which routes traffic from
	//   the virtual network to the LAN **without applying any NAT**. It requires that
	//   the IP address range be pre-configured in the routing tables of the router
	//   on the host network.
	// - `bridge`: use a pre-existing host bridge. The guests will effectively be
	//   directly connected to the physical network (i.e. their IP addresses will
	//   all be on the subnet of the physical network, and there will be no
	//   restrictions on inbound or outbound connections). The `bridge` network
	//   attribute is mandatory in this case.
	Mode pulumi.StringPtrInput
	// The MTU to set for the underlying network interfaces. When
	// not supplied, libvirt will use the default for the interface, usually 1500.
	// Libvirt version 5.1 and greater will advertise this value to nodes via DHCP.
	Mtu pulumi.IntPtrInput
	// A unique name for the resource, required by libvirt.
	// Changing this forces a new resource to be created.
	Name pulumi.StringPtrInput
	// a list of static routes. A `cidr` and a `gateway` must
	// be provided. The `gateway` must be reachable via the bridge interface.
	Routes NetworkRouteArrayInput
	Xml    NetworkXmlPtrInput
}

func (NetworkState) ElementType() reflect.Type {
	return reflect.TypeOf((*networkState)(nil)).Elem()
}

type networkArgs struct {
	// A list of (0 or 1) IPv4 and (0 or 1) IPv6 subnets in
	// CIDR notation.  This defines the subnets associated to that network.
	// This argument is also used to define the address on the real host.
	// If `dhcp {  enabled = true }` addresses is also used to define the address range served by
	// the DHCP server.
	// No DHCP server will be started if `addresses` is omitted.
	Addresses []string `pulumi:"addresses"`
	// Set to `true` to start the network on host boot up.
	// If not specified `false` is assumed.
	Autostart *bool `pulumi:"autostart"`
	// The bridge device defines the name of a bridge
	// device which will be used to construct the virtual network (when not provided,
	// it will be automatically obtained by libvirt in `none`, `nat` and `route` modes).
	Bridge *string `pulumi:"bridge"`
	// DHCP configuration.
	// You need to use it in conjuction with the adresses variable.
	Dhcp *NetworkDhcp `pulumi:"dhcp"`
	// configuration of DNS specific settings for the network
	Dns *NetworkDns `pulumi:"dns"`
	// configuration of Dnsmasq options for the network
	// You need to provide a list of option name and value pairs.
	DnsmasqOptions *NetworkDnsmasqOptions `pulumi:"dnsmasqOptions"`
	// The domain used by the DNS server.
	Domain *string `pulumi:"domain"`
	// One of:
	// - `none`: the guests can talk to each other and the host OS, but cannot reach
	//   any other machines on the LAN.
	// - `nat`: it is the default network mode. This is a configuration that
	//   allows guest OS to get outbound connectivity regardless of whether the host
	//   uses ethernet, wireless, dialup, or VPN networking without requiring any
	//   specific admin configuration. In the absence of host networking, it at
	//   least allows guests to talk directly to each other.
	// - `route`: this is a variant on the default network which routes traffic from
	//   the virtual network to the LAN **without applying any NAT**. It requires that
	//   the IP address range be pre-configured in the routing tables of the router
	//   on the host network.
	// - `bridge`: use a pre-existing host bridge. The guests will effectively be
	//   directly connected to the physical network (i.e. their IP addresses will
	//   all be on the subnet of the physical network, and there will be no
	//   restrictions on inbound or outbound connections). The `bridge` network
	//   attribute is mandatory in this case.
	Mode *string `pulumi:"mode"`
	// The MTU to set for the underlying network interfaces. When
	// not supplied, libvirt will use the default for the interface, usually 1500.
	// Libvirt version 5.1 and greater will advertise this value to nodes via DHCP.
	Mtu *int `pulumi:"mtu"`
	// A unique name for the resource, required by libvirt.
	// Changing this forces a new resource to be created.
	Name *string `pulumi:"name"`
	// a list of static routes. A `cidr` and a `gateway` must
	// be provided. The `gateway` must be reachable via the bridge interface.
	Routes []NetworkRoute `pulumi:"routes"`
	Xml    *NetworkXml    `pulumi:"xml"`
}

// The set of arguments for constructing a Network resource.
type NetworkArgs struct {
	// A list of (0 or 1) IPv4 and (0 or 1) IPv6 subnets in
	// CIDR notation.  This defines the subnets associated to that network.
	// This argument is also used to define the address on the real host.
	// If `dhcp {  enabled = true }` addresses is also used to define the address range served by
	// the DHCP server.
	// No DHCP server will be started if `addresses` is omitted.
	Addresses pulumi.StringArrayInput
	// Set to `true` to start the network on host boot up.
	// If not specified `false` is assumed.
	Autostart pulumi.BoolPtrInput
	// The bridge device defines the name of a bridge
	// device which will be used to construct the virtual network (when not provided,
	// it will be automatically obtained by libvirt in `none`, `nat` and `route` modes).
	Bridge pulumi.StringPtrInput
	// DHCP configuration.
	// You need to use it in conjuction with the adresses variable.
	Dhcp NetworkDhcpPtrInput
	// configuration of DNS specific settings for the network
	Dns NetworkDnsPtrInput
	// configuration of Dnsmasq options for the network
	// You need to provide a list of option name and value pairs.
	DnsmasqOptions NetworkDnsmasqOptionsPtrInput
	// The domain used by the DNS server.
	Domain pulumi.StringPtrInput
	// One of:
	// - `none`: the guests can talk to each other and the host OS, but cannot reach
	//   any other machines on the LAN.
	// - `nat`: it is the default network mode. This is a configuration that
	//   allows guest OS to get outbound connectivity regardless of whether the host
	//   uses ethernet, wireless, dialup, or VPN networking without requiring any
	//   specific admin configuration. In the absence of host networking, it at
	//   least allows guests to talk directly to each other.
	// - `route`: this is a variant on the default network which routes traffic from
	//   the virtual network to the LAN **without applying any NAT**. It requires that
	//   the IP address range be pre-configured in the routing tables of the router
	//   on the host network.
	// - `bridge`: use a pre-existing host bridge. The guests will effectively be
	//   directly connected to the physical network (i.e. their IP addresses will
	//   all be on the subnet of the physical network, and there will be no
	//   restrictions on inbound or outbound connections). The `bridge` network
	//   attribute is mandatory in this case.
	Mode pulumi.StringPtrInput
	// The MTU to set for the underlying network interfaces. When
	// not supplied, libvirt will use the default for the interface, usually 1500.
	// Libvirt version 5.1 and greater will advertise this value to nodes via DHCP.
	Mtu pulumi.IntPtrInput
	// A unique name for the resource, required by libvirt.
	// Changing this forces a new resource to be created.
	Name pulumi.StringPtrInput
	// a list of static routes. A `cidr` and a `gateway` must
	// be provided. The `gateway` must be reachable via the bridge interface.
	Routes NetworkRouteArrayInput
	Xml    NetworkXmlPtrInput
}

func (NetworkArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*networkArgs)(nil)).Elem()
}

type NetworkInput interface {
	pulumi.Input

	ToNetworkOutput() NetworkOutput
	ToNetworkOutputWithContext(ctx context.Context) NetworkOutput
}

func (*Network) ElementType() reflect.Type {
	return reflect.TypeOf((*Network)(nil))
}

func (i *Network) ToNetworkOutput() NetworkOutput {
	return i.ToNetworkOutputWithContext(context.Background())
}

func (i *Network) ToNetworkOutputWithContext(ctx context.Context) NetworkOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NetworkOutput)
}

func (i *Network) ToNetworkPtrOutput() NetworkPtrOutput {
	return i.ToNetworkPtrOutputWithContext(context.Background())
}

func (i *Network) ToNetworkPtrOutputWithContext(ctx context.Context) NetworkPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NetworkPtrOutput)
}

type NetworkPtrInput interface {
	pulumi.Input

	ToNetworkPtrOutput() NetworkPtrOutput
	ToNetworkPtrOutputWithContext(ctx context.Context) NetworkPtrOutput
}

type networkPtrType NetworkArgs

func (*networkPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Network)(nil))
}

func (i *networkPtrType) ToNetworkPtrOutput() NetworkPtrOutput {
	return i.ToNetworkPtrOutputWithContext(context.Background())
}

func (i *networkPtrType) ToNetworkPtrOutputWithContext(ctx context.Context) NetworkPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NetworkPtrOutput)
}

// NetworkArrayInput is an input type that accepts NetworkArray and NetworkArrayOutput values.
// You can construct a concrete instance of `NetworkArrayInput` via:
//
//          NetworkArray{ NetworkArgs{...} }
type NetworkArrayInput interface {
	pulumi.Input

	ToNetworkArrayOutput() NetworkArrayOutput
	ToNetworkArrayOutputWithContext(context.Context) NetworkArrayOutput
}

type NetworkArray []NetworkInput

func (NetworkArray) ElementType() reflect.Type {
	return reflect.TypeOf(([]*Network)(nil))
}

func (i NetworkArray) ToNetworkArrayOutput() NetworkArrayOutput {
	return i.ToNetworkArrayOutputWithContext(context.Background())
}

func (i NetworkArray) ToNetworkArrayOutputWithContext(ctx context.Context) NetworkArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NetworkArrayOutput)
}

// NetworkMapInput is an input type that accepts NetworkMap and NetworkMapOutput values.
// You can construct a concrete instance of `NetworkMapInput` via:
//
//          NetworkMap{ "key": NetworkArgs{...} }
type NetworkMapInput interface {
	pulumi.Input

	ToNetworkMapOutput() NetworkMapOutput
	ToNetworkMapOutputWithContext(context.Context) NetworkMapOutput
}

type NetworkMap map[string]NetworkInput

func (NetworkMap) ElementType() reflect.Type {
	return reflect.TypeOf((map[string]*Network)(nil))
}

func (i NetworkMap) ToNetworkMapOutput() NetworkMapOutput {
	return i.ToNetworkMapOutputWithContext(context.Background())
}

func (i NetworkMap) ToNetworkMapOutputWithContext(ctx context.Context) NetworkMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NetworkMapOutput)
}

type NetworkOutput struct {
	*pulumi.OutputState
}

func (NetworkOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Network)(nil))
}

func (o NetworkOutput) ToNetworkOutput() NetworkOutput {
	return o
}

func (o NetworkOutput) ToNetworkOutputWithContext(ctx context.Context) NetworkOutput {
	return o
}

func (o NetworkOutput) ToNetworkPtrOutput() NetworkPtrOutput {
	return o.ToNetworkPtrOutputWithContext(context.Background())
}

func (o NetworkOutput) ToNetworkPtrOutputWithContext(ctx context.Context) NetworkPtrOutput {
	return o.ApplyT(func(v Network) *Network {
		return &v
	}).(NetworkPtrOutput)
}

type NetworkPtrOutput struct {
	*pulumi.OutputState
}

func (NetworkPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Network)(nil))
}

func (o NetworkPtrOutput) ToNetworkPtrOutput() NetworkPtrOutput {
	return o
}

func (o NetworkPtrOutput) ToNetworkPtrOutputWithContext(ctx context.Context) NetworkPtrOutput {
	return o
}

type NetworkArrayOutput struct{ *pulumi.OutputState }

func (NetworkArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Network)(nil))
}

func (o NetworkArrayOutput) ToNetworkArrayOutput() NetworkArrayOutput {
	return o
}

func (o NetworkArrayOutput) ToNetworkArrayOutputWithContext(ctx context.Context) NetworkArrayOutput {
	return o
}

func (o NetworkArrayOutput) Index(i pulumi.IntInput) NetworkOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) Network {
		return vs[0].([]Network)[vs[1].(int)]
	}).(NetworkOutput)
}

type NetworkMapOutput struct{ *pulumi.OutputState }

func (NetworkMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]Network)(nil))
}

func (o NetworkMapOutput) ToNetworkMapOutput() NetworkMapOutput {
	return o
}

func (o NetworkMapOutput) ToNetworkMapOutputWithContext(ctx context.Context) NetworkMapOutput {
	return o
}

func (o NetworkMapOutput) MapIndex(k pulumi.StringInput) NetworkOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) Network {
		return vs[0].(map[string]Network)[vs[1].(string)]
	}).(NetworkOutput)
}

func init() {
	pulumi.RegisterOutputType(NetworkOutput{})
	pulumi.RegisterOutputType(NetworkPtrOutput{})
	pulumi.RegisterOutputType(NetworkArrayOutput{})
	pulumi.RegisterOutputType(NetworkMapOutput{})
}
