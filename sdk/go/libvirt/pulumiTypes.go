// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package libvirt

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi-libvirt/sdk/go/libvirt/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

var _ = internal.GetEnvOrDefault

type DomainBootDevice struct {
	Devs []string `pulumi:"devs"`
}

// DomainBootDeviceInput is an input type that accepts DomainBootDeviceArgs and DomainBootDeviceOutput values.
// You can construct a concrete instance of `DomainBootDeviceInput` via:
//
//	DomainBootDeviceArgs{...}
type DomainBootDeviceInput interface {
	pulumi.Input

	ToDomainBootDeviceOutput() DomainBootDeviceOutput
	ToDomainBootDeviceOutputWithContext(context.Context) DomainBootDeviceOutput
}

type DomainBootDeviceArgs struct {
	Devs pulumi.StringArrayInput `pulumi:"devs"`
}

func (DomainBootDeviceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DomainBootDevice)(nil)).Elem()
}

func (i DomainBootDeviceArgs) ToDomainBootDeviceOutput() DomainBootDeviceOutput {
	return i.ToDomainBootDeviceOutputWithContext(context.Background())
}

func (i DomainBootDeviceArgs) ToDomainBootDeviceOutputWithContext(ctx context.Context) DomainBootDeviceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DomainBootDeviceOutput)
}

// DomainBootDeviceArrayInput is an input type that accepts DomainBootDeviceArray and DomainBootDeviceArrayOutput values.
// You can construct a concrete instance of `DomainBootDeviceArrayInput` via:
//
//	DomainBootDeviceArray{ DomainBootDeviceArgs{...} }
type DomainBootDeviceArrayInput interface {
	pulumi.Input

	ToDomainBootDeviceArrayOutput() DomainBootDeviceArrayOutput
	ToDomainBootDeviceArrayOutputWithContext(context.Context) DomainBootDeviceArrayOutput
}

type DomainBootDeviceArray []DomainBootDeviceInput

func (DomainBootDeviceArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DomainBootDevice)(nil)).Elem()
}

func (i DomainBootDeviceArray) ToDomainBootDeviceArrayOutput() DomainBootDeviceArrayOutput {
	return i.ToDomainBootDeviceArrayOutputWithContext(context.Background())
}

func (i DomainBootDeviceArray) ToDomainBootDeviceArrayOutputWithContext(ctx context.Context) DomainBootDeviceArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DomainBootDeviceArrayOutput)
}

type DomainBootDeviceOutput struct{ *pulumi.OutputState }

func (DomainBootDeviceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DomainBootDevice)(nil)).Elem()
}

func (o DomainBootDeviceOutput) ToDomainBootDeviceOutput() DomainBootDeviceOutput {
	return o
}

func (o DomainBootDeviceOutput) ToDomainBootDeviceOutputWithContext(ctx context.Context) DomainBootDeviceOutput {
	return o
}

func (o DomainBootDeviceOutput) Devs() pulumi.StringArrayOutput {
	return o.ApplyT(func(v DomainBootDevice) []string { return v.Devs }).(pulumi.StringArrayOutput)
}

type DomainBootDeviceArrayOutput struct{ *pulumi.OutputState }

func (DomainBootDeviceArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DomainBootDevice)(nil)).Elem()
}

func (o DomainBootDeviceArrayOutput) ToDomainBootDeviceArrayOutput() DomainBootDeviceArrayOutput {
	return o
}

func (o DomainBootDeviceArrayOutput) ToDomainBootDeviceArrayOutputWithContext(ctx context.Context) DomainBootDeviceArrayOutput {
	return o
}

func (o DomainBootDeviceArrayOutput) Index(i pulumi.IntInput) DomainBootDeviceOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) DomainBootDevice {
		return vs[0].([]DomainBootDevice)[vs[1].(int)]
	}).(DomainBootDeviceOutput)
}

type DomainConsole struct {
	// IP address to listen on. Defaults to 127.0.0.1.
	SourceHost *string `pulumi:"sourceHost"`
	// Source path
	//
	// Additional attributes when type is "tcp":
	SourcePath *string `pulumi:"sourcePath"`
	// Port number or a service name. Defaults to a
	// random port.
	//
	// Note that you can repeat the `console` block to create more than one console.
	// This works the same way as with the `disk` blocks (see above).
	//
	// See [libvirt Domain XML Console element](https://libvirt.org/formatdomain.html#elementsConsole)
	// for more information.
	SourceService *string `pulumi:"sourceService"`
	// Target port
	TargetPort string `pulumi:"targetPort"`
	// for the first console and defaults to `serial`.
	// Subsequent `console` blocks must have a different type - usually `virtio`.
	//
	// Additional attributes when type is "pty":
	TargetType *string `pulumi:"targetType"`
	// The type of hypervisor to use for the domain.  Defaults to `kvm`, other values can be found [here](https://libvirt.org/formatdomain.html#id1)
	Type string `pulumi:"type"`
}

// DomainConsoleInput is an input type that accepts DomainConsoleArgs and DomainConsoleOutput values.
// You can construct a concrete instance of `DomainConsoleInput` via:
//
//	DomainConsoleArgs{...}
type DomainConsoleInput interface {
	pulumi.Input

	ToDomainConsoleOutput() DomainConsoleOutput
	ToDomainConsoleOutputWithContext(context.Context) DomainConsoleOutput
}

type DomainConsoleArgs struct {
	// IP address to listen on. Defaults to 127.0.0.1.
	SourceHost pulumi.StringPtrInput `pulumi:"sourceHost"`
	// Source path
	//
	// Additional attributes when type is "tcp":
	SourcePath pulumi.StringPtrInput `pulumi:"sourcePath"`
	// Port number or a service name. Defaults to a
	// random port.
	//
	// Note that you can repeat the `console` block to create more than one console.
	// This works the same way as with the `disk` blocks (see above).
	//
	// See [libvirt Domain XML Console element](https://libvirt.org/formatdomain.html#elementsConsole)
	// for more information.
	SourceService pulumi.StringPtrInput `pulumi:"sourceService"`
	// Target port
	TargetPort pulumi.StringInput `pulumi:"targetPort"`
	// for the first console and defaults to `serial`.
	// Subsequent `console` blocks must have a different type - usually `virtio`.
	//
	// Additional attributes when type is "pty":
	TargetType pulumi.StringPtrInput `pulumi:"targetType"`
	// The type of hypervisor to use for the domain.  Defaults to `kvm`, other values can be found [here](https://libvirt.org/formatdomain.html#id1)
	Type pulumi.StringInput `pulumi:"type"`
}

func (DomainConsoleArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DomainConsole)(nil)).Elem()
}

func (i DomainConsoleArgs) ToDomainConsoleOutput() DomainConsoleOutput {
	return i.ToDomainConsoleOutputWithContext(context.Background())
}

func (i DomainConsoleArgs) ToDomainConsoleOutputWithContext(ctx context.Context) DomainConsoleOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DomainConsoleOutput)
}

// DomainConsoleArrayInput is an input type that accepts DomainConsoleArray and DomainConsoleArrayOutput values.
// You can construct a concrete instance of `DomainConsoleArrayInput` via:
//
//	DomainConsoleArray{ DomainConsoleArgs{...} }
type DomainConsoleArrayInput interface {
	pulumi.Input

	ToDomainConsoleArrayOutput() DomainConsoleArrayOutput
	ToDomainConsoleArrayOutputWithContext(context.Context) DomainConsoleArrayOutput
}

type DomainConsoleArray []DomainConsoleInput

func (DomainConsoleArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DomainConsole)(nil)).Elem()
}

func (i DomainConsoleArray) ToDomainConsoleArrayOutput() DomainConsoleArrayOutput {
	return i.ToDomainConsoleArrayOutputWithContext(context.Background())
}

func (i DomainConsoleArray) ToDomainConsoleArrayOutputWithContext(ctx context.Context) DomainConsoleArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DomainConsoleArrayOutput)
}

type DomainConsoleOutput struct{ *pulumi.OutputState }

func (DomainConsoleOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DomainConsole)(nil)).Elem()
}

func (o DomainConsoleOutput) ToDomainConsoleOutput() DomainConsoleOutput {
	return o
}

func (o DomainConsoleOutput) ToDomainConsoleOutputWithContext(ctx context.Context) DomainConsoleOutput {
	return o
}

// IP address to listen on. Defaults to 127.0.0.1.
func (o DomainConsoleOutput) SourceHost() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DomainConsole) *string { return v.SourceHost }).(pulumi.StringPtrOutput)
}

// Source path
//
// Additional attributes when type is "tcp":
func (o DomainConsoleOutput) SourcePath() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DomainConsole) *string { return v.SourcePath }).(pulumi.StringPtrOutput)
}

// Port number or a service name. Defaults to a
// random port.
//
// Note that you can repeat the `console` block to create more than one console.
// This works the same way as with the `disk` blocks (see above).
//
// See [libvirt Domain XML Console element](https://libvirt.org/formatdomain.html#elementsConsole)
// for more information.
func (o DomainConsoleOutput) SourceService() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DomainConsole) *string { return v.SourceService }).(pulumi.StringPtrOutput)
}

// Target port
func (o DomainConsoleOutput) TargetPort() pulumi.StringOutput {
	return o.ApplyT(func(v DomainConsole) string { return v.TargetPort }).(pulumi.StringOutput)
}

// for the first console and defaults to `serial`.
// Subsequent `console` blocks must have a different type - usually `virtio`.
//
// Additional attributes when type is "pty":
func (o DomainConsoleOutput) TargetType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DomainConsole) *string { return v.TargetType }).(pulumi.StringPtrOutput)
}

// The type of hypervisor to use for the domain.  Defaults to `kvm`, other values can be found [here](https://libvirt.org/formatdomain.html#id1)
func (o DomainConsoleOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v DomainConsole) string { return v.Type }).(pulumi.StringOutput)
}

type DomainConsoleArrayOutput struct{ *pulumi.OutputState }

func (DomainConsoleArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DomainConsole)(nil)).Elem()
}

func (o DomainConsoleArrayOutput) ToDomainConsoleArrayOutput() DomainConsoleArrayOutput {
	return o
}

func (o DomainConsoleArrayOutput) ToDomainConsoleArrayOutputWithContext(ctx context.Context) DomainConsoleArrayOutput {
	return o
}

func (o DomainConsoleArrayOutput) Index(i pulumi.IntInput) DomainConsoleOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) DomainConsole {
		return vs[0].([]DomainConsole)[vs[1].(int)]
	}).(DomainConsoleOutput)
}

type DomainCpu struct {
	Mode *string `pulumi:"mode"`
}

// DomainCpuInput is an input type that accepts DomainCpuArgs and DomainCpuOutput values.
// You can construct a concrete instance of `DomainCpuInput` via:
//
//	DomainCpuArgs{...}
type DomainCpuInput interface {
	pulumi.Input

	ToDomainCpuOutput() DomainCpuOutput
	ToDomainCpuOutputWithContext(context.Context) DomainCpuOutput
}

type DomainCpuArgs struct {
	Mode pulumi.StringPtrInput `pulumi:"mode"`
}

func (DomainCpuArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DomainCpu)(nil)).Elem()
}

func (i DomainCpuArgs) ToDomainCpuOutput() DomainCpuOutput {
	return i.ToDomainCpuOutputWithContext(context.Background())
}

func (i DomainCpuArgs) ToDomainCpuOutputWithContext(ctx context.Context) DomainCpuOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DomainCpuOutput)
}

func (i DomainCpuArgs) ToDomainCpuPtrOutput() DomainCpuPtrOutput {
	return i.ToDomainCpuPtrOutputWithContext(context.Background())
}

func (i DomainCpuArgs) ToDomainCpuPtrOutputWithContext(ctx context.Context) DomainCpuPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DomainCpuOutput).ToDomainCpuPtrOutputWithContext(ctx)
}

// DomainCpuPtrInput is an input type that accepts DomainCpuArgs, DomainCpuPtr and DomainCpuPtrOutput values.
// You can construct a concrete instance of `DomainCpuPtrInput` via:
//
//	        DomainCpuArgs{...}
//
//	or:
//
//	        nil
type DomainCpuPtrInput interface {
	pulumi.Input

	ToDomainCpuPtrOutput() DomainCpuPtrOutput
	ToDomainCpuPtrOutputWithContext(context.Context) DomainCpuPtrOutput
}

type domainCpuPtrType DomainCpuArgs

func DomainCpuPtr(v *DomainCpuArgs) DomainCpuPtrInput {
	return (*domainCpuPtrType)(v)
}

func (*domainCpuPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**DomainCpu)(nil)).Elem()
}

func (i *domainCpuPtrType) ToDomainCpuPtrOutput() DomainCpuPtrOutput {
	return i.ToDomainCpuPtrOutputWithContext(context.Background())
}

func (i *domainCpuPtrType) ToDomainCpuPtrOutputWithContext(ctx context.Context) DomainCpuPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DomainCpuPtrOutput)
}

type DomainCpuOutput struct{ *pulumi.OutputState }

func (DomainCpuOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DomainCpu)(nil)).Elem()
}

func (o DomainCpuOutput) ToDomainCpuOutput() DomainCpuOutput {
	return o
}

func (o DomainCpuOutput) ToDomainCpuOutputWithContext(ctx context.Context) DomainCpuOutput {
	return o
}

func (o DomainCpuOutput) ToDomainCpuPtrOutput() DomainCpuPtrOutput {
	return o.ToDomainCpuPtrOutputWithContext(context.Background())
}

func (o DomainCpuOutput) ToDomainCpuPtrOutputWithContext(ctx context.Context) DomainCpuPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v DomainCpu) *DomainCpu {
		return &v
	}).(DomainCpuPtrOutput)
}

func (o DomainCpuOutput) Mode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DomainCpu) *string { return v.Mode }).(pulumi.StringPtrOutput)
}

type DomainCpuPtrOutput struct{ *pulumi.OutputState }

func (DomainCpuPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**DomainCpu)(nil)).Elem()
}

func (o DomainCpuPtrOutput) ToDomainCpuPtrOutput() DomainCpuPtrOutput {
	return o
}

func (o DomainCpuPtrOutput) ToDomainCpuPtrOutputWithContext(ctx context.Context) DomainCpuPtrOutput {
	return o
}

func (o DomainCpuPtrOutput) Elem() DomainCpuOutput {
	return o.ApplyT(func(v *DomainCpu) DomainCpu {
		if v != nil {
			return *v
		}
		var ret DomainCpu
		return ret
	}).(DomainCpuOutput)
}

func (o DomainCpuPtrOutput) Mode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *DomainCpu) *string {
		if v == nil {
			return nil
		}
		return v.Mode
	}).(pulumi.StringPtrOutput)
}

type DomainDisk struct {
	// The path to the host device to use as the block device for this disk.
	//
	// While `volumeId`, `url`, `file` and `blockDevice` are optional, it is intended that you use one of them.
	BlockDevice *string `pulumi:"blockDevice"`
	// The filename to use as the block device for this disk (read-only)
	File *string `pulumi:"file"`
	// Use a scsi controller for this disk.  The controller
	// model is set to `virtio-scsi`
	Scsi *bool `pulumi:"scsi"`
	// The http url to use as the block device for this disk (read-only)
	Url *string `pulumi:"url"`
	// The volume id to use for this disk.
	VolumeId *string `pulumi:"volumeId"`
	// Specify a WWN to use for the disk if the disk is using
	// a scsi controller, if not specified then a random wwn is generated for the disk
	//
	// ```go
	// package main
	//
	// import (
	// 	"github.com/pulumi/pulumi-libvirt/sdk/go/libvirt"
	// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	// )
	//
	// func main() {
	// 	pulumi.Run(func(ctx *pulumi.Context) error {
	// 		leap, err := libvirt.NewVolume(ctx, "leap", &libvirt.VolumeArgs{
	// 			Source: pulumi.String("http://someurl/openSUSE_Leap-42.1.qcow2"),
	// 		})
	// 		if err != nil {
	// 			return err
	// 		}
	// 		mydisk, err := libvirt.NewVolume(ctx, "mydisk", &libvirt.VolumeArgs{
	// 			BaseVolumeId: leap.ID(),
	// 		})
	// 		if err != nil {
	// 			return err
	// 		}
	// 		_, err = libvirt.NewDomain(ctx, "domain1", &libvirt.DomainArgs{
	// 			Disks: libvirt.DomainDiskArray{
	// 				&libvirt.DomainDiskArgs{
	// 					VolumeId: mydisk.ID(),
	// 					Scsi:     pulumi.Bool(true),
	// 				},
	// 				&libvirt.DomainDiskArgs{
	// 					Url: pulumi.String("http://foo.com/install.iso"),
	// 				},
	// 				&libvirt.DomainDiskArgs{
	// 					File: pulumi.String("/absolute/path/to/disk.iso"),
	// 				},
	// 				&libvirt.DomainDiskArgs{
	// 					BlockDevice: pulumi.String("/dev/mapper/36005076802810e55400000000000145f"),
	// 				},
	// 			},
	// 		})
	// 		if err != nil {
	// 			return err
	// 		}
	// 		return nil
	// 	})
	// }
	// ```
	//
	// Also note that the `disk` block is actually a list of maps, so it is possible to
	// declare several of them by using either the literal list and map syntax as in
	// the following examples:
	Wwn *string `pulumi:"wwn"`
}

// DomainDiskInput is an input type that accepts DomainDiskArgs and DomainDiskOutput values.
// You can construct a concrete instance of `DomainDiskInput` via:
//
//	DomainDiskArgs{...}
type DomainDiskInput interface {
	pulumi.Input

	ToDomainDiskOutput() DomainDiskOutput
	ToDomainDiskOutputWithContext(context.Context) DomainDiskOutput
}

type DomainDiskArgs struct {
	// The path to the host device to use as the block device for this disk.
	//
	// While `volumeId`, `url`, `file` and `blockDevice` are optional, it is intended that you use one of them.
	BlockDevice pulumi.StringPtrInput `pulumi:"blockDevice"`
	// The filename to use as the block device for this disk (read-only)
	File pulumi.StringPtrInput `pulumi:"file"`
	// Use a scsi controller for this disk.  The controller
	// model is set to `virtio-scsi`
	Scsi pulumi.BoolPtrInput `pulumi:"scsi"`
	// The http url to use as the block device for this disk (read-only)
	Url pulumi.StringPtrInput `pulumi:"url"`
	// The volume id to use for this disk.
	VolumeId pulumi.StringPtrInput `pulumi:"volumeId"`
	// Specify a WWN to use for the disk if the disk is using
	// a scsi controller, if not specified then a random wwn is generated for the disk
	//
	// ```go
	// package main
	//
	// import (
	// 	"github.com/pulumi/pulumi-libvirt/sdk/go/libvirt"
	// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	// )
	//
	// func main() {
	// 	pulumi.Run(func(ctx *pulumi.Context) error {
	// 		leap, err := libvirt.NewVolume(ctx, "leap", &libvirt.VolumeArgs{
	// 			Source: pulumi.String("http://someurl/openSUSE_Leap-42.1.qcow2"),
	// 		})
	// 		if err != nil {
	// 			return err
	// 		}
	// 		mydisk, err := libvirt.NewVolume(ctx, "mydisk", &libvirt.VolumeArgs{
	// 			BaseVolumeId: leap.ID(),
	// 		})
	// 		if err != nil {
	// 			return err
	// 		}
	// 		_, err = libvirt.NewDomain(ctx, "domain1", &libvirt.DomainArgs{
	// 			Disks: libvirt.DomainDiskArray{
	// 				&libvirt.DomainDiskArgs{
	// 					VolumeId: mydisk.ID(),
	// 					Scsi:     pulumi.Bool(true),
	// 				},
	// 				&libvirt.DomainDiskArgs{
	// 					Url: pulumi.String("http://foo.com/install.iso"),
	// 				},
	// 				&libvirt.DomainDiskArgs{
	// 					File: pulumi.String("/absolute/path/to/disk.iso"),
	// 				},
	// 				&libvirt.DomainDiskArgs{
	// 					BlockDevice: pulumi.String("/dev/mapper/36005076802810e55400000000000145f"),
	// 				},
	// 			},
	// 		})
	// 		if err != nil {
	// 			return err
	// 		}
	// 		return nil
	// 	})
	// }
	// ```
	//
	// Also note that the `disk` block is actually a list of maps, so it is possible to
	// declare several of them by using either the literal list and map syntax as in
	// the following examples:
	Wwn pulumi.StringPtrInput `pulumi:"wwn"`
}

func (DomainDiskArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DomainDisk)(nil)).Elem()
}

func (i DomainDiskArgs) ToDomainDiskOutput() DomainDiskOutput {
	return i.ToDomainDiskOutputWithContext(context.Background())
}

func (i DomainDiskArgs) ToDomainDiskOutputWithContext(ctx context.Context) DomainDiskOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DomainDiskOutput)
}

// DomainDiskArrayInput is an input type that accepts DomainDiskArray and DomainDiskArrayOutput values.
// You can construct a concrete instance of `DomainDiskArrayInput` via:
//
//	DomainDiskArray{ DomainDiskArgs{...} }
type DomainDiskArrayInput interface {
	pulumi.Input

	ToDomainDiskArrayOutput() DomainDiskArrayOutput
	ToDomainDiskArrayOutputWithContext(context.Context) DomainDiskArrayOutput
}

type DomainDiskArray []DomainDiskInput

func (DomainDiskArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DomainDisk)(nil)).Elem()
}

func (i DomainDiskArray) ToDomainDiskArrayOutput() DomainDiskArrayOutput {
	return i.ToDomainDiskArrayOutputWithContext(context.Background())
}

func (i DomainDiskArray) ToDomainDiskArrayOutputWithContext(ctx context.Context) DomainDiskArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DomainDiskArrayOutput)
}

type DomainDiskOutput struct{ *pulumi.OutputState }

func (DomainDiskOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DomainDisk)(nil)).Elem()
}

func (o DomainDiskOutput) ToDomainDiskOutput() DomainDiskOutput {
	return o
}

func (o DomainDiskOutput) ToDomainDiskOutputWithContext(ctx context.Context) DomainDiskOutput {
	return o
}

// The path to the host device to use as the block device for this disk.
//
// While `volumeId`, `url`, `file` and `blockDevice` are optional, it is intended that you use one of them.
func (o DomainDiskOutput) BlockDevice() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DomainDisk) *string { return v.BlockDevice }).(pulumi.StringPtrOutput)
}

// The filename to use as the block device for this disk (read-only)
func (o DomainDiskOutput) File() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DomainDisk) *string { return v.File }).(pulumi.StringPtrOutput)
}

// Use a scsi controller for this disk.  The controller
// model is set to `virtio-scsi`
func (o DomainDiskOutput) Scsi() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v DomainDisk) *bool { return v.Scsi }).(pulumi.BoolPtrOutput)
}

// The http url to use as the block device for this disk (read-only)
func (o DomainDiskOutput) Url() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DomainDisk) *string { return v.Url }).(pulumi.StringPtrOutput)
}

// The volume id to use for this disk.
func (o DomainDiskOutput) VolumeId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DomainDisk) *string { return v.VolumeId }).(pulumi.StringPtrOutput)
}

// Specify a WWN to use for the disk if the disk is using
// a scsi controller, if not specified then a random wwn is generated for the disk
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-libvirt/sdk/go/libvirt"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			leap, err := libvirt.NewVolume(ctx, "leap", &libvirt.VolumeArgs{
//				Source: pulumi.String("http://someurl/openSUSE_Leap-42.1.qcow2"),
//			})
//			if err != nil {
//				return err
//			}
//			mydisk, err := libvirt.NewVolume(ctx, "mydisk", &libvirt.VolumeArgs{
//				BaseVolumeId: leap.ID(),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = libvirt.NewDomain(ctx, "domain1", &libvirt.DomainArgs{
//				Disks: libvirt.DomainDiskArray{
//					&libvirt.DomainDiskArgs{
//						VolumeId: mydisk.ID(),
//						Scsi:     pulumi.Bool(true),
//					},
//					&libvirt.DomainDiskArgs{
//						Url: pulumi.String("http://foo.com/install.iso"),
//					},
//					&libvirt.DomainDiskArgs{
//						File: pulumi.String("/absolute/path/to/disk.iso"),
//					},
//					&libvirt.DomainDiskArgs{
//						BlockDevice: pulumi.String("/dev/mapper/36005076802810e55400000000000145f"),
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// Also note that the `disk` block is actually a list of maps, so it is possible to
// declare several of them by using either the literal list and map syntax as in
// the following examples:
func (o DomainDiskOutput) Wwn() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DomainDisk) *string { return v.Wwn }).(pulumi.StringPtrOutput)
}

type DomainDiskArrayOutput struct{ *pulumi.OutputState }

func (DomainDiskArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DomainDisk)(nil)).Elem()
}

func (o DomainDiskArrayOutput) ToDomainDiskArrayOutput() DomainDiskArrayOutput {
	return o
}

func (o DomainDiskArrayOutput) ToDomainDiskArrayOutputWithContext(ctx context.Context) DomainDiskArrayOutput {
	return o
}

func (o DomainDiskArrayOutput) Index(i pulumi.IntInput) DomainDiskOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) DomainDisk {
		return vs[0].([]DomainDisk)[vs[1].(int)]
	}).(DomainDiskOutput)
}

type DomainFilesystem struct {
	// specifies the security mode for accessing the source. By default
	// the `mapped` mode is chosen.
	Accessmode *string `pulumi:"accessmode"`
	// enables exporting filesystem as a readonly mount for guest, by
	// default read-only access is given.
	//
	// Example:
	//
	// ```go
	// package main
	//
	// import (
	// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	// )
	//
	// func main() {
	// 	pulumi.Run(func(ctx *pulumi.Context) error {
	// 		return nil
	// 	})
	// }
	// ```
	//
	// The exported filesystems can be mounted inside of the guest in this way:
	Readonly *bool `pulumi:"readonly"`
	// the directory of the host to be shared with the guest.
	Source string `pulumi:"source"`
	// an arbitrary string tag that is exported to the guest as a hint for
	// where to mount the source.
	Target string `pulumi:"target"`
}

// DomainFilesystemInput is an input type that accepts DomainFilesystemArgs and DomainFilesystemOutput values.
// You can construct a concrete instance of `DomainFilesystemInput` via:
//
//	DomainFilesystemArgs{...}
type DomainFilesystemInput interface {
	pulumi.Input

	ToDomainFilesystemOutput() DomainFilesystemOutput
	ToDomainFilesystemOutputWithContext(context.Context) DomainFilesystemOutput
}

type DomainFilesystemArgs struct {
	// specifies the security mode for accessing the source. By default
	// the `mapped` mode is chosen.
	Accessmode pulumi.StringPtrInput `pulumi:"accessmode"`
	// enables exporting filesystem as a readonly mount for guest, by
	// default read-only access is given.
	//
	// Example:
	//
	// ```go
	// package main
	//
	// import (
	// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	// )
	//
	// func main() {
	// 	pulumi.Run(func(ctx *pulumi.Context) error {
	// 		return nil
	// 	})
	// }
	// ```
	//
	// The exported filesystems can be mounted inside of the guest in this way:
	Readonly pulumi.BoolPtrInput `pulumi:"readonly"`
	// the directory of the host to be shared with the guest.
	Source pulumi.StringInput `pulumi:"source"`
	// an arbitrary string tag that is exported to the guest as a hint for
	// where to mount the source.
	Target pulumi.StringInput `pulumi:"target"`
}

func (DomainFilesystemArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DomainFilesystem)(nil)).Elem()
}

func (i DomainFilesystemArgs) ToDomainFilesystemOutput() DomainFilesystemOutput {
	return i.ToDomainFilesystemOutputWithContext(context.Background())
}

func (i DomainFilesystemArgs) ToDomainFilesystemOutputWithContext(ctx context.Context) DomainFilesystemOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DomainFilesystemOutput)
}

// DomainFilesystemArrayInput is an input type that accepts DomainFilesystemArray and DomainFilesystemArrayOutput values.
// You can construct a concrete instance of `DomainFilesystemArrayInput` via:
//
//	DomainFilesystemArray{ DomainFilesystemArgs{...} }
type DomainFilesystemArrayInput interface {
	pulumi.Input

	ToDomainFilesystemArrayOutput() DomainFilesystemArrayOutput
	ToDomainFilesystemArrayOutputWithContext(context.Context) DomainFilesystemArrayOutput
}

type DomainFilesystemArray []DomainFilesystemInput

func (DomainFilesystemArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DomainFilesystem)(nil)).Elem()
}

func (i DomainFilesystemArray) ToDomainFilesystemArrayOutput() DomainFilesystemArrayOutput {
	return i.ToDomainFilesystemArrayOutputWithContext(context.Background())
}

func (i DomainFilesystemArray) ToDomainFilesystemArrayOutputWithContext(ctx context.Context) DomainFilesystemArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DomainFilesystemArrayOutput)
}

type DomainFilesystemOutput struct{ *pulumi.OutputState }

func (DomainFilesystemOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DomainFilesystem)(nil)).Elem()
}

func (o DomainFilesystemOutput) ToDomainFilesystemOutput() DomainFilesystemOutput {
	return o
}

func (o DomainFilesystemOutput) ToDomainFilesystemOutputWithContext(ctx context.Context) DomainFilesystemOutput {
	return o
}

// specifies the security mode for accessing the source. By default
// the `mapped` mode is chosen.
func (o DomainFilesystemOutput) Accessmode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DomainFilesystem) *string { return v.Accessmode }).(pulumi.StringPtrOutput)
}

// enables exporting filesystem as a readonly mount for guest, by
// default read-only access is given.
//
// Example:
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			return nil
//		})
//	}
//
// ```
//
// The exported filesystems can be mounted inside of the guest in this way:
func (o DomainFilesystemOutput) Readonly() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v DomainFilesystem) *bool { return v.Readonly }).(pulumi.BoolPtrOutput)
}

// the directory of the host to be shared with the guest.
func (o DomainFilesystemOutput) Source() pulumi.StringOutput {
	return o.ApplyT(func(v DomainFilesystem) string { return v.Source }).(pulumi.StringOutput)
}

// an arbitrary string tag that is exported to the guest as a hint for
// where to mount the source.
func (o DomainFilesystemOutput) Target() pulumi.StringOutput {
	return o.ApplyT(func(v DomainFilesystem) string { return v.Target }).(pulumi.StringOutput)
}

type DomainFilesystemArrayOutput struct{ *pulumi.OutputState }

func (DomainFilesystemArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DomainFilesystem)(nil)).Elem()
}

func (o DomainFilesystemArrayOutput) ToDomainFilesystemArrayOutput() DomainFilesystemArrayOutput {
	return o
}

func (o DomainFilesystemArrayOutput) ToDomainFilesystemArrayOutputWithContext(ctx context.Context) DomainFilesystemArrayOutput {
	return o
}

func (o DomainFilesystemArrayOutput) Index(i pulumi.IntInput) DomainFilesystemOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) DomainFilesystem {
		return vs[0].([]DomainFilesystem)[vs[1].(int)]
	}).(DomainFilesystemOutput)
}

type DomainGraphics struct {
	// defaults to "yes"
	Autoport *bool `pulumi:"autoport"`
	// IP Address where the VNC listener should be started if
	// `listenType` is set to `address`. Defaults to 127.0.0.1
	ListenAddress *string `pulumi:"listenAddress"`
	// "listen type", defaults to "none"
	ListenType *string `pulumi:"listenType"`
	// The type of hypervisor to use for the domain.  Defaults to `kvm`, other values can be found [here](https://libvirt.org/formatdomain.html#id1)
	Type *string `pulumi:"type"`
	// Port to listen on for VNC WebSocket functionality (-1 meaning auto-allocation)
	//
	// On occasion we have found it necessary to set a `type` of `vnc` and a
	// `listenType` of `address` with certain builds of QEMU.
	//
	// With `listenAddress` it is possible to specify a listener address for the virtual
	// machines VNC server. Usually this is an IP of the host system.
	//
	// The `graphics` block will look as follows:
	Websocket *int `pulumi:"websocket"`
}

// DomainGraphicsInput is an input type that accepts DomainGraphicsArgs and DomainGraphicsOutput values.
// You can construct a concrete instance of `DomainGraphicsInput` via:
//
//	DomainGraphicsArgs{...}
type DomainGraphicsInput interface {
	pulumi.Input

	ToDomainGraphicsOutput() DomainGraphicsOutput
	ToDomainGraphicsOutputWithContext(context.Context) DomainGraphicsOutput
}

type DomainGraphicsArgs struct {
	// defaults to "yes"
	Autoport pulumi.BoolPtrInput `pulumi:"autoport"`
	// IP Address where the VNC listener should be started if
	// `listenType` is set to `address`. Defaults to 127.0.0.1
	ListenAddress pulumi.StringPtrInput `pulumi:"listenAddress"`
	// "listen type", defaults to "none"
	ListenType pulumi.StringPtrInput `pulumi:"listenType"`
	// The type of hypervisor to use for the domain.  Defaults to `kvm`, other values can be found [here](https://libvirt.org/formatdomain.html#id1)
	Type pulumi.StringPtrInput `pulumi:"type"`
	// Port to listen on for VNC WebSocket functionality (-1 meaning auto-allocation)
	//
	// On occasion we have found it necessary to set a `type` of `vnc` and a
	// `listenType` of `address` with certain builds of QEMU.
	//
	// With `listenAddress` it is possible to specify a listener address for the virtual
	// machines VNC server. Usually this is an IP of the host system.
	//
	// The `graphics` block will look as follows:
	Websocket pulumi.IntPtrInput `pulumi:"websocket"`
}

func (DomainGraphicsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DomainGraphics)(nil)).Elem()
}

func (i DomainGraphicsArgs) ToDomainGraphicsOutput() DomainGraphicsOutput {
	return i.ToDomainGraphicsOutputWithContext(context.Background())
}

func (i DomainGraphicsArgs) ToDomainGraphicsOutputWithContext(ctx context.Context) DomainGraphicsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DomainGraphicsOutput)
}

func (i DomainGraphicsArgs) ToDomainGraphicsPtrOutput() DomainGraphicsPtrOutput {
	return i.ToDomainGraphicsPtrOutputWithContext(context.Background())
}

func (i DomainGraphicsArgs) ToDomainGraphicsPtrOutputWithContext(ctx context.Context) DomainGraphicsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DomainGraphicsOutput).ToDomainGraphicsPtrOutputWithContext(ctx)
}

// DomainGraphicsPtrInput is an input type that accepts DomainGraphicsArgs, DomainGraphicsPtr and DomainGraphicsPtrOutput values.
// You can construct a concrete instance of `DomainGraphicsPtrInput` via:
//
//	        DomainGraphicsArgs{...}
//
//	or:
//
//	        nil
type DomainGraphicsPtrInput interface {
	pulumi.Input

	ToDomainGraphicsPtrOutput() DomainGraphicsPtrOutput
	ToDomainGraphicsPtrOutputWithContext(context.Context) DomainGraphicsPtrOutput
}

type domainGraphicsPtrType DomainGraphicsArgs

func DomainGraphicsPtr(v *DomainGraphicsArgs) DomainGraphicsPtrInput {
	return (*domainGraphicsPtrType)(v)
}

func (*domainGraphicsPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**DomainGraphics)(nil)).Elem()
}

func (i *domainGraphicsPtrType) ToDomainGraphicsPtrOutput() DomainGraphicsPtrOutput {
	return i.ToDomainGraphicsPtrOutputWithContext(context.Background())
}

func (i *domainGraphicsPtrType) ToDomainGraphicsPtrOutputWithContext(ctx context.Context) DomainGraphicsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DomainGraphicsPtrOutput)
}

type DomainGraphicsOutput struct{ *pulumi.OutputState }

func (DomainGraphicsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DomainGraphics)(nil)).Elem()
}

func (o DomainGraphicsOutput) ToDomainGraphicsOutput() DomainGraphicsOutput {
	return o
}

func (o DomainGraphicsOutput) ToDomainGraphicsOutputWithContext(ctx context.Context) DomainGraphicsOutput {
	return o
}

func (o DomainGraphicsOutput) ToDomainGraphicsPtrOutput() DomainGraphicsPtrOutput {
	return o.ToDomainGraphicsPtrOutputWithContext(context.Background())
}

func (o DomainGraphicsOutput) ToDomainGraphicsPtrOutputWithContext(ctx context.Context) DomainGraphicsPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v DomainGraphics) *DomainGraphics {
		return &v
	}).(DomainGraphicsPtrOutput)
}

// defaults to "yes"
func (o DomainGraphicsOutput) Autoport() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v DomainGraphics) *bool { return v.Autoport }).(pulumi.BoolPtrOutput)
}

// IP Address where the VNC listener should be started if
// `listenType` is set to `address`. Defaults to 127.0.0.1
func (o DomainGraphicsOutput) ListenAddress() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DomainGraphics) *string { return v.ListenAddress }).(pulumi.StringPtrOutput)
}

// "listen type", defaults to "none"
func (o DomainGraphicsOutput) ListenType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DomainGraphics) *string { return v.ListenType }).(pulumi.StringPtrOutput)
}

// The type of hypervisor to use for the domain.  Defaults to `kvm`, other values can be found [here](https://libvirt.org/formatdomain.html#id1)
func (o DomainGraphicsOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DomainGraphics) *string { return v.Type }).(pulumi.StringPtrOutput)
}

// Port to listen on for VNC WebSocket functionality (-1 meaning auto-allocation)
//
// On occasion we have found it necessary to set a `type` of `vnc` and a
// `listenType` of `address` with certain builds of QEMU.
//
// With `listenAddress` it is possible to specify a listener address for the virtual
// machines VNC server. Usually this is an IP of the host system.
//
// The `graphics` block will look as follows:
func (o DomainGraphicsOutput) Websocket() pulumi.IntPtrOutput {
	return o.ApplyT(func(v DomainGraphics) *int { return v.Websocket }).(pulumi.IntPtrOutput)
}

type DomainGraphicsPtrOutput struct{ *pulumi.OutputState }

func (DomainGraphicsPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**DomainGraphics)(nil)).Elem()
}

func (o DomainGraphicsPtrOutput) ToDomainGraphicsPtrOutput() DomainGraphicsPtrOutput {
	return o
}

func (o DomainGraphicsPtrOutput) ToDomainGraphicsPtrOutputWithContext(ctx context.Context) DomainGraphicsPtrOutput {
	return o
}

func (o DomainGraphicsPtrOutput) Elem() DomainGraphicsOutput {
	return o.ApplyT(func(v *DomainGraphics) DomainGraphics {
		if v != nil {
			return *v
		}
		var ret DomainGraphics
		return ret
	}).(DomainGraphicsOutput)
}

// defaults to "yes"
func (o DomainGraphicsPtrOutput) Autoport() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *DomainGraphics) *bool {
		if v == nil {
			return nil
		}
		return v.Autoport
	}).(pulumi.BoolPtrOutput)
}

// IP Address where the VNC listener should be started if
// `listenType` is set to `address`. Defaults to 127.0.0.1
func (o DomainGraphicsPtrOutput) ListenAddress() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *DomainGraphics) *string {
		if v == nil {
			return nil
		}
		return v.ListenAddress
	}).(pulumi.StringPtrOutput)
}

// "listen type", defaults to "none"
func (o DomainGraphicsPtrOutput) ListenType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *DomainGraphics) *string {
		if v == nil {
			return nil
		}
		return v.ListenType
	}).(pulumi.StringPtrOutput)
}

// The type of hypervisor to use for the domain.  Defaults to `kvm`, other values can be found [here](https://libvirt.org/formatdomain.html#id1)
func (o DomainGraphicsPtrOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *DomainGraphics) *string {
		if v == nil {
			return nil
		}
		return v.Type
	}).(pulumi.StringPtrOutput)
}

// Port to listen on for VNC WebSocket functionality (-1 meaning auto-allocation)
//
// On occasion we have found it necessary to set a `type` of `vnc` and a
// `listenType` of `address` with certain builds of QEMU.
//
// With `listenAddress` it is possible to specify a listener address for the virtual
// machines VNC server. Usually this is an IP of the host system.
//
// The `graphics` block will look as follows:
func (o DomainGraphicsPtrOutput) Websocket() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *DomainGraphics) *int {
		if v == nil {
			return nil
		}
		return v.Websocket
	}).(pulumi.IntPtrOutput)
}

type DomainNetworkInterface struct {
	// An IP address for this domain in this network.
	Addresses []string `pulumi:"addresses"`
	// Provides a bridge from the VM directly to the LAN. This assumes
	// there is a bridge device on the host which has one or more of the hosts
	// physical NICs enslaved. The guest VM will have an associated _tun_ device
	// created and enslaved to the bridge. The IP range / network configuration is
	// whatever is used on the LAN. This provides the guest VM full incoming &
	// outgoing net access just like a physical machine.
	Bridge *string `pulumi:"bridge"`
	// A hostname that will be assigned to this domain
	// resource in this network.
	Hostname *string `pulumi:"hostname"`
	// The specific MAC address to use for this interface.
	Mac *string `pulumi:"mac"`
	// Packets whose destination is on the same host as where they
	// originate from are directly delivered to the target macvtap device. Both
	// origin and destination devices need to be in bridge mode for direct delivery.
	// If either one of them is in vepa mode, a VEPA capable bridge is required.
	Macvtap     *string `pulumi:"macvtap"`
	NetworkId   *string `pulumi:"networkId"`
	NetworkName *string `pulumi:"networkName"`
	// This feature attaches a virtual function of a SRIOV capable
	// NIC directly to a VM without losing the migration capability. All packets are
	// sent to the VF/IF of the configured network device. Depending on the
	// capabilities of the device additional prerequisites or limitations may apply;
	// for example, on Linux this requires kernel 2.6.38 or newer.
	//
	// Example of a `macvtap` interface:
	Passthrough *string `pulumi:"passthrough"`
	// All VMs' packets are sent to the external bridge. Packets whose
	// destination is a VM on the same host as where the packet originates from are
	// sent back to the host by the VEPA capable bridge (today's bridges are
	// typically not VEPA capable).
	Vepa *string `pulumi:"vepa"`
	// When creating the domain resource, wait until the
	// network interface gets a DHCP lease from libvirt, so that the computed IP
	// addresses will be available when the domain is up and the plan applied.
	//
	// When connecting to a LAN, users can specify a target device with:
	WaitForLease *bool `pulumi:"waitForLease"`
}

// DomainNetworkInterfaceInput is an input type that accepts DomainNetworkInterfaceArgs and DomainNetworkInterfaceOutput values.
// You can construct a concrete instance of `DomainNetworkInterfaceInput` via:
//
//	DomainNetworkInterfaceArgs{...}
type DomainNetworkInterfaceInput interface {
	pulumi.Input

	ToDomainNetworkInterfaceOutput() DomainNetworkInterfaceOutput
	ToDomainNetworkInterfaceOutputWithContext(context.Context) DomainNetworkInterfaceOutput
}

type DomainNetworkInterfaceArgs struct {
	// An IP address for this domain in this network.
	Addresses pulumi.StringArrayInput `pulumi:"addresses"`
	// Provides a bridge from the VM directly to the LAN. This assumes
	// there is a bridge device on the host which has one or more of the hosts
	// physical NICs enslaved. The guest VM will have an associated _tun_ device
	// created and enslaved to the bridge. The IP range / network configuration is
	// whatever is used on the LAN. This provides the guest VM full incoming &
	// outgoing net access just like a physical machine.
	Bridge pulumi.StringPtrInput `pulumi:"bridge"`
	// A hostname that will be assigned to this domain
	// resource in this network.
	Hostname pulumi.StringPtrInput `pulumi:"hostname"`
	// The specific MAC address to use for this interface.
	Mac pulumi.StringPtrInput `pulumi:"mac"`
	// Packets whose destination is on the same host as where they
	// originate from are directly delivered to the target macvtap device. Both
	// origin and destination devices need to be in bridge mode for direct delivery.
	// If either one of them is in vepa mode, a VEPA capable bridge is required.
	Macvtap     pulumi.StringPtrInput `pulumi:"macvtap"`
	NetworkId   pulumi.StringPtrInput `pulumi:"networkId"`
	NetworkName pulumi.StringPtrInput `pulumi:"networkName"`
	// This feature attaches a virtual function of a SRIOV capable
	// NIC directly to a VM without losing the migration capability. All packets are
	// sent to the VF/IF of the configured network device. Depending on the
	// capabilities of the device additional prerequisites or limitations may apply;
	// for example, on Linux this requires kernel 2.6.38 or newer.
	//
	// Example of a `macvtap` interface:
	Passthrough pulumi.StringPtrInput `pulumi:"passthrough"`
	// All VMs' packets are sent to the external bridge. Packets whose
	// destination is a VM on the same host as where the packet originates from are
	// sent back to the host by the VEPA capable bridge (today's bridges are
	// typically not VEPA capable).
	Vepa pulumi.StringPtrInput `pulumi:"vepa"`
	// When creating the domain resource, wait until the
	// network interface gets a DHCP lease from libvirt, so that the computed IP
	// addresses will be available when the domain is up and the plan applied.
	//
	// When connecting to a LAN, users can specify a target device with:
	WaitForLease pulumi.BoolPtrInput `pulumi:"waitForLease"`
}

func (DomainNetworkInterfaceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DomainNetworkInterface)(nil)).Elem()
}

func (i DomainNetworkInterfaceArgs) ToDomainNetworkInterfaceOutput() DomainNetworkInterfaceOutput {
	return i.ToDomainNetworkInterfaceOutputWithContext(context.Background())
}

func (i DomainNetworkInterfaceArgs) ToDomainNetworkInterfaceOutputWithContext(ctx context.Context) DomainNetworkInterfaceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DomainNetworkInterfaceOutput)
}

// DomainNetworkInterfaceArrayInput is an input type that accepts DomainNetworkInterfaceArray and DomainNetworkInterfaceArrayOutput values.
// You can construct a concrete instance of `DomainNetworkInterfaceArrayInput` via:
//
//	DomainNetworkInterfaceArray{ DomainNetworkInterfaceArgs{...} }
type DomainNetworkInterfaceArrayInput interface {
	pulumi.Input

	ToDomainNetworkInterfaceArrayOutput() DomainNetworkInterfaceArrayOutput
	ToDomainNetworkInterfaceArrayOutputWithContext(context.Context) DomainNetworkInterfaceArrayOutput
}

type DomainNetworkInterfaceArray []DomainNetworkInterfaceInput

func (DomainNetworkInterfaceArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DomainNetworkInterface)(nil)).Elem()
}

func (i DomainNetworkInterfaceArray) ToDomainNetworkInterfaceArrayOutput() DomainNetworkInterfaceArrayOutput {
	return i.ToDomainNetworkInterfaceArrayOutputWithContext(context.Background())
}

func (i DomainNetworkInterfaceArray) ToDomainNetworkInterfaceArrayOutputWithContext(ctx context.Context) DomainNetworkInterfaceArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DomainNetworkInterfaceArrayOutput)
}

type DomainNetworkInterfaceOutput struct{ *pulumi.OutputState }

func (DomainNetworkInterfaceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DomainNetworkInterface)(nil)).Elem()
}

func (o DomainNetworkInterfaceOutput) ToDomainNetworkInterfaceOutput() DomainNetworkInterfaceOutput {
	return o
}

func (o DomainNetworkInterfaceOutput) ToDomainNetworkInterfaceOutputWithContext(ctx context.Context) DomainNetworkInterfaceOutput {
	return o
}

// An IP address for this domain in this network.
func (o DomainNetworkInterfaceOutput) Addresses() pulumi.StringArrayOutput {
	return o.ApplyT(func(v DomainNetworkInterface) []string { return v.Addresses }).(pulumi.StringArrayOutput)
}

// Provides a bridge from the VM directly to the LAN. This assumes
// there is a bridge device on the host which has one or more of the hosts
// physical NICs enslaved. The guest VM will have an associated _tun_ device
// created and enslaved to the bridge. The IP range / network configuration is
// whatever is used on the LAN. This provides the guest VM full incoming &
// outgoing net access just like a physical machine.
func (o DomainNetworkInterfaceOutput) Bridge() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DomainNetworkInterface) *string { return v.Bridge }).(pulumi.StringPtrOutput)
}

// A hostname that will be assigned to this domain
// resource in this network.
func (o DomainNetworkInterfaceOutput) Hostname() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DomainNetworkInterface) *string { return v.Hostname }).(pulumi.StringPtrOutput)
}

// The specific MAC address to use for this interface.
func (o DomainNetworkInterfaceOutput) Mac() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DomainNetworkInterface) *string { return v.Mac }).(pulumi.StringPtrOutput)
}

// Packets whose destination is on the same host as where they
// originate from are directly delivered to the target macvtap device. Both
// origin and destination devices need to be in bridge mode for direct delivery.
// If either one of them is in vepa mode, a VEPA capable bridge is required.
func (o DomainNetworkInterfaceOutput) Macvtap() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DomainNetworkInterface) *string { return v.Macvtap }).(pulumi.StringPtrOutput)
}

func (o DomainNetworkInterfaceOutput) NetworkId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DomainNetworkInterface) *string { return v.NetworkId }).(pulumi.StringPtrOutput)
}

func (o DomainNetworkInterfaceOutput) NetworkName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DomainNetworkInterface) *string { return v.NetworkName }).(pulumi.StringPtrOutput)
}

// This feature attaches a virtual function of a SRIOV capable
// NIC directly to a VM without losing the migration capability. All packets are
// sent to the VF/IF of the configured network device. Depending on the
// capabilities of the device additional prerequisites or limitations may apply;
// for example, on Linux this requires kernel 2.6.38 or newer.
//
// Example of a `macvtap` interface:
func (o DomainNetworkInterfaceOutput) Passthrough() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DomainNetworkInterface) *string { return v.Passthrough }).(pulumi.StringPtrOutput)
}

// All VMs' packets are sent to the external bridge. Packets whose
// destination is a VM on the same host as where the packet originates from are
// sent back to the host by the VEPA capable bridge (today's bridges are
// typically not VEPA capable).
func (o DomainNetworkInterfaceOutput) Vepa() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DomainNetworkInterface) *string { return v.Vepa }).(pulumi.StringPtrOutput)
}

// When creating the domain resource, wait until the
// network interface gets a DHCP lease from libvirt, so that the computed IP
// addresses will be available when the domain is up and the plan applied.
//
// When connecting to a LAN, users can specify a target device with:
func (o DomainNetworkInterfaceOutput) WaitForLease() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v DomainNetworkInterface) *bool { return v.WaitForLease }).(pulumi.BoolPtrOutput)
}

type DomainNetworkInterfaceArrayOutput struct{ *pulumi.OutputState }

func (DomainNetworkInterfaceArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]DomainNetworkInterface)(nil)).Elem()
}

func (o DomainNetworkInterfaceArrayOutput) ToDomainNetworkInterfaceArrayOutput() DomainNetworkInterfaceArrayOutput {
	return o
}

func (o DomainNetworkInterfaceArrayOutput) ToDomainNetworkInterfaceArrayOutputWithContext(ctx context.Context) DomainNetworkInterfaceArrayOutput {
	return o
}

func (o DomainNetworkInterfaceArrayOutput) Index(i pulumi.IntInput) DomainNetworkInterfaceOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) DomainNetworkInterface {
		return vs[0].([]DomainNetworkInterface)[vs[1].(int)]
	}).(DomainNetworkInterfaceOutput)
}

type DomainNvram struct {
	// The filename to use as the block device for this disk (read-only)
	File string `pulumi:"file"`
	// path to the file used to override variables from the master NVRAM
	// store.
	//
	// So you should typically use the firmware as this,
	Template *string `pulumi:"template"`
}

// DomainNvramInput is an input type that accepts DomainNvramArgs and DomainNvramOutput values.
// You can construct a concrete instance of `DomainNvramInput` via:
//
//	DomainNvramArgs{...}
type DomainNvramInput interface {
	pulumi.Input

	ToDomainNvramOutput() DomainNvramOutput
	ToDomainNvramOutputWithContext(context.Context) DomainNvramOutput
}

type DomainNvramArgs struct {
	// The filename to use as the block device for this disk (read-only)
	File pulumi.StringInput `pulumi:"file"`
	// path to the file used to override variables from the master NVRAM
	// store.
	//
	// So you should typically use the firmware as this,
	Template pulumi.StringPtrInput `pulumi:"template"`
}

func (DomainNvramArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DomainNvram)(nil)).Elem()
}

func (i DomainNvramArgs) ToDomainNvramOutput() DomainNvramOutput {
	return i.ToDomainNvramOutputWithContext(context.Background())
}

func (i DomainNvramArgs) ToDomainNvramOutputWithContext(ctx context.Context) DomainNvramOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DomainNvramOutput)
}

func (i DomainNvramArgs) ToDomainNvramPtrOutput() DomainNvramPtrOutput {
	return i.ToDomainNvramPtrOutputWithContext(context.Background())
}

func (i DomainNvramArgs) ToDomainNvramPtrOutputWithContext(ctx context.Context) DomainNvramPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DomainNvramOutput).ToDomainNvramPtrOutputWithContext(ctx)
}

// DomainNvramPtrInput is an input type that accepts DomainNvramArgs, DomainNvramPtr and DomainNvramPtrOutput values.
// You can construct a concrete instance of `DomainNvramPtrInput` via:
//
//	        DomainNvramArgs{...}
//
//	or:
//
//	        nil
type DomainNvramPtrInput interface {
	pulumi.Input

	ToDomainNvramPtrOutput() DomainNvramPtrOutput
	ToDomainNvramPtrOutputWithContext(context.Context) DomainNvramPtrOutput
}

type domainNvramPtrType DomainNvramArgs

func DomainNvramPtr(v *DomainNvramArgs) DomainNvramPtrInput {
	return (*domainNvramPtrType)(v)
}

func (*domainNvramPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**DomainNvram)(nil)).Elem()
}

func (i *domainNvramPtrType) ToDomainNvramPtrOutput() DomainNvramPtrOutput {
	return i.ToDomainNvramPtrOutputWithContext(context.Background())
}

func (i *domainNvramPtrType) ToDomainNvramPtrOutputWithContext(ctx context.Context) DomainNvramPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DomainNvramPtrOutput)
}

type DomainNvramOutput struct{ *pulumi.OutputState }

func (DomainNvramOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DomainNvram)(nil)).Elem()
}

func (o DomainNvramOutput) ToDomainNvramOutput() DomainNvramOutput {
	return o
}

func (o DomainNvramOutput) ToDomainNvramOutputWithContext(ctx context.Context) DomainNvramOutput {
	return o
}

func (o DomainNvramOutput) ToDomainNvramPtrOutput() DomainNvramPtrOutput {
	return o.ToDomainNvramPtrOutputWithContext(context.Background())
}

func (o DomainNvramOutput) ToDomainNvramPtrOutputWithContext(ctx context.Context) DomainNvramPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v DomainNvram) *DomainNvram {
		return &v
	}).(DomainNvramPtrOutput)
}

// The filename to use as the block device for this disk (read-only)
func (o DomainNvramOutput) File() pulumi.StringOutput {
	return o.ApplyT(func(v DomainNvram) string { return v.File }).(pulumi.StringOutput)
}

// path to the file used to override variables from the master NVRAM
// store.
//
// So you should typically use the firmware as this,
func (o DomainNvramOutput) Template() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DomainNvram) *string { return v.Template }).(pulumi.StringPtrOutput)
}

type DomainNvramPtrOutput struct{ *pulumi.OutputState }

func (DomainNvramPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**DomainNvram)(nil)).Elem()
}

func (o DomainNvramPtrOutput) ToDomainNvramPtrOutput() DomainNvramPtrOutput {
	return o
}

func (o DomainNvramPtrOutput) ToDomainNvramPtrOutputWithContext(ctx context.Context) DomainNvramPtrOutput {
	return o
}

func (o DomainNvramPtrOutput) Elem() DomainNvramOutput {
	return o.ApplyT(func(v *DomainNvram) DomainNvram {
		if v != nil {
			return *v
		}
		var ret DomainNvram
		return ret
	}).(DomainNvramOutput)
}

// The filename to use as the block device for this disk (read-only)
func (o DomainNvramPtrOutput) File() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *DomainNvram) *string {
		if v == nil {
			return nil
		}
		return &v.File
	}).(pulumi.StringPtrOutput)
}

// path to the file used to override variables from the master NVRAM
// store.
//
// So you should typically use the firmware as this,
func (o DomainNvramPtrOutput) Template() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *DomainNvram) *string {
		if v == nil {
			return nil
		}
		return v.Template
	}).(pulumi.StringPtrOutput)
}

type DomainTpm struct {
	// Path to TPM device on the host, ex: `/dev/tpm0`
	//
	// Additional attributes when `backendType` is "emulator":
	BackendDevicePath *string `pulumi:"backendDevicePath"`
	// [Secret object](https://libvirt.org/formatsecret.html) for encrypting the TPM state
	BackendEncryptionSecret *string `pulumi:"backendEncryptionSecret"`
	// Keep the TPM state when a transient domain is powered off or undefined
	BackendPersistentState *bool `pulumi:"backendPersistentState"`
	// TPM backend, either `passthrough` or `emulator` (default: `emulator`)
	//
	// Additional attributes when `backendType` is "passthrough":
	BackendType *string `pulumi:"backendType"`
	// TPM version
	BackendVersion *string `pulumi:"backendVersion"`
	// TPM model provided to the guest
	Model *string `pulumi:"model"`
}

// DomainTpmInput is an input type that accepts DomainTpmArgs and DomainTpmOutput values.
// You can construct a concrete instance of `DomainTpmInput` via:
//
//	DomainTpmArgs{...}
type DomainTpmInput interface {
	pulumi.Input

	ToDomainTpmOutput() DomainTpmOutput
	ToDomainTpmOutputWithContext(context.Context) DomainTpmOutput
}

type DomainTpmArgs struct {
	// Path to TPM device on the host, ex: `/dev/tpm0`
	//
	// Additional attributes when `backendType` is "emulator":
	BackendDevicePath pulumi.StringPtrInput `pulumi:"backendDevicePath"`
	// [Secret object](https://libvirt.org/formatsecret.html) for encrypting the TPM state
	BackendEncryptionSecret pulumi.StringPtrInput `pulumi:"backendEncryptionSecret"`
	// Keep the TPM state when a transient domain is powered off or undefined
	BackendPersistentState pulumi.BoolPtrInput `pulumi:"backendPersistentState"`
	// TPM backend, either `passthrough` or `emulator` (default: `emulator`)
	//
	// Additional attributes when `backendType` is "passthrough":
	BackendType pulumi.StringPtrInput `pulumi:"backendType"`
	// TPM version
	BackendVersion pulumi.StringPtrInput `pulumi:"backendVersion"`
	// TPM model provided to the guest
	Model pulumi.StringPtrInput `pulumi:"model"`
}

func (DomainTpmArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DomainTpm)(nil)).Elem()
}

func (i DomainTpmArgs) ToDomainTpmOutput() DomainTpmOutput {
	return i.ToDomainTpmOutputWithContext(context.Background())
}

func (i DomainTpmArgs) ToDomainTpmOutputWithContext(ctx context.Context) DomainTpmOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DomainTpmOutput)
}

func (i DomainTpmArgs) ToDomainTpmPtrOutput() DomainTpmPtrOutput {
	return i.ToDomainTpmPtrOutputWithContext(context.Background())
}

func (i DomainTpmArgs) ToDomainTpmPtrOutputWithContext(ctx context.Context) DomainTpmPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DomainTpmOutput).ToDomainTpmPtrOutputWithContext(ctx)
}

// DomainTpmPtrInput is an input type that accepts DomainTpmArgs, DomainTpmPtr and DomainTpmPtrOutput values.
// You can construct a concrete instance of `DomainTpmPtrInput` via:
//
//	        DomainTpmArgs{...}
//
//	or:
//
//	        nil
type DomainTpmPtrInput interface {
	pulumi.Input

	ToDomainTpmPtrOutput() DomainTpmPtrOutput
	ToDomainTpmPtrOutputWithContext(context.Context) DomainTpmPtrOutput
}

type domainTpmPtrType DomainTpmArgs

func DomainTpmPtr(v *DomainTpmArgs) DomainTpmPtrInput {
	return (*domainTpmPtrType)(v)
}

func (*domainTpmPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**DomainTpm)(nil)).Elem()
}

func (i *domainTpmPtrType) ToDomainTpmPtrOutput() DomainTpmPtrOutput {
	return i.ToDomainTpmPtrOutputWithContext(context.Background())
}

func (i *domainTpmPtrType) ToDomainTpmPtrOutputWithContext(ctx context.Context) DomainTpmPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DomainTpmPtrOutput)
}

type DomainTpmOutput struct{ *pulumi.OutputState }

func (DomainTpmOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DomainTpm)(nil)).Elem()
}

func (o DomainTpmOutput) ToDomainTpmOutput() DomainTpmOutput {
	return o
}

func (o DomainTpmOutput) ToDomainTpmOutputWithContext(ctx context.Context) DomainTpmOutput {
	return o
}

func (o DomainTpmOutput) ToDomainTpmPtrOutput() DomainTpmPtrOutput {
	return o.ToDomainTpmPtrOutputWithContext(context.Background())
}

func (o DomainTpmOutput) ToDomainTpmPtrOutputWithContext(ctx context.Context) DomainTpmPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v DomainTpm) *DomainTpm {
		return &v
	}).(DomainTpmPtrOutput)
}

// Path to TPM device on the host, ex: `/dev/tpm0`
//
// Additional attributes when `backendType` is "emulator":
func (o DomainTpmOutput) BackendDevicePath() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DomainTpm) *string { return v.BackendDevicePath }).(pulumi.StringPtrOutput)
}

// [Secret object](https://libvirt.org/formatsecret.html) for encrypting the TPM state
func (o DomainTpmOutput) BackendEncryptionSecret() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DomainTpm) *string { return v.BackendEncryptionSecret }).(pulumi.StringPtrOutput)
}

// Keep the TPM state when a transient domain is powered off or undefined
func (o DomainTpmOutput) BackendPersistentState() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v DomainTpm) *bool { return v.BackendPersistentState }).(pulumi.BoolPtrOutput)
}

// TPM backend, either `passthrough` or `emulator` (default: `emulator`)
//
// Additional attributes when `backendType` is "passthrough":
func (o DomainTpmOutput) BackendType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DomainTpm) *string { return v.BackendType }).(pulumi.StringPtrOutput)
}

// TPM version
func (o DomainTpmOutput) BackendVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DomainTpm) *string { return v.BackendVersion }).(pulumi.StringPtrOutput)
}

// TPM model provided to the guest
func (o DomainTpmOutput) Model() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DomainTpm) *string { return v.Model }).(pulumi.StringPtrOutput)
}

type DomainTpmPtrOutput struct{ *pulumi.OutputState }

func (DomainTpmPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**DomainTpm)(nil)).Elem()
}

func (o DomainTpmPtrOutput) ToDomainTpmPtrOutput() DomainTpmPtrOutput {
	return o
}

func (o DomainTpmPtrOutput) ToDomainTpmPtrOutputWithContext(ctx context.Context) DomainTpmPtrOutput {
	return o
}

func (o DomainTpmPtrOutput) Elem() DomainTpmOutput {
	return o.ApplyT(func(v *DomainTpm) DomainTpm {
		if v != nil {
			return *v
		}
		var ret DomainTpm
		return ret
	}).(DomainTpmOutput)
}

// Path to TPM device on the host, ex: `/dev/tpm0`
//
// Additional attributes when `backendType` is "emulator":
func (o DomainTpmPtrOutput) BackendDevicePath() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *DomainTpm) *string {
		if v == nil {
			return nil
		}
		return v.BackendDevicePath
	}).(pulumi.StringPtrOutput)
}

// [Secret object](https://libvirt.org/formatsecret.html) for encrypting the TPM state
func (o DomainTpmPtrOutput) BackendEncryptionSecret() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *DomainTpm) *string {
		if v == nil {
			return nil
		}
		return v.BackendEncryptionSecret
	}).(pulumi.StringPtrOutput)
}

// Keep the TPM state when a transient domain is powered off or undefined
func (o DomainTpmPtrOutput) BackendPersistentState() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *DomainTpm) *bool {
		if v == nil {
			return nil
		}
		return v.BackendPersistentState
	}).(pulumi.BoolPtrOutput)
}

// TPM backend, either `passthrough` or `emulator` (default: `emulator`)
//
// Additional attributes when `backendType` is "passthrough":
func (o DomainTpmPtrOutput) BackendType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *DomainTpm) *string {
		if v == nil {
			return nil
		}
		return v.BackendType
	}).(pulumi.StringPtrOutput)
}

// TPM version
func (o DomainTpmPtrOutput) BackendVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *DomainTpm) *string {
		if v == nil {
			return nil
		}
		return v.BackendVersion
	}).(pulumi.StringPtrOutput)
}

// TPM model provided to the guest
func (o DomainTpmPtrOutput) Model() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *DomainTpm) *string {
		if v == nil {
			return nil
		}
		return v.Model
	}).(pulumi.StringPtrOutput)
}

type DomainVideo struct {
	// The type of hypervisor to use for the domain.  Defaults to `kvm`, other values can be found [here](https://libvirt.org/formatdomain.html#id1)
	Type *string `pulumi:"type"`
}

// DomainVideoInput is an input type that accepts DomainVideoArgs and DomainVideoOutput values.
// You can construct a concrete instance of `DomainVideoInput` via:
//
//	DomainVideoArgs{...}
type DomainVideoInput interface {
	pulumi.Input

	ToDomainVideoOutput() DomainVideoOutput
	ToDomainVideoOutputWithContext(context.Context) DomainVideoOutput
}

type DomainVideoArgs struct {
	// The type of hypervisor to use for the domain.  Defaults to `kvm`, other values can be found [here](https://libvirt.org/formatdomain.html#id1)
	Type pulumi.StringPtrInput `pulumi:"type"`
}

func (DomainVideoArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DomainVideo)(nil)).Elem()
}

func (i DomainVideoArgs) ToDomainVideoOutput() DomainVideoOutput {
	return i.ToDomainVideoOutputWithContext(context.Background())
}

func (i DomainVideoArgs) ToDomainVideoOutputWithContext(ctx context.Context) DomainVideoOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DomainVideoOutput)
}

func (i DomainVideoArgs) ToDomainVideoPtrOutput() DomainVideoPtrOutput {
	return i.ToDomainVideoPtrOutputWithContext(context.Background())
}

func (i DomainVideoArgs) ToDomainVideoPtrOutputWithContext(ctx context.Context) DomainVideoPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DomainVideoOutput).ToDomainVideoPtrOutputWithContext(ctx)
}

// DomainVideoPtrInput is an input type that accepts DomainVideoArgs, DomainVideoPtr and DomainVideoPtrOutput values.
// You can construct a concrete instance of `DomainVideoPtrInput` via:
//
//	        DomainVideoArgs{...}
//
//	or:
//
//	        nil
type DomainVideoPtrInput interface {
	pulumi.Input

	ToDomainVideoPtrOutput() DomainVideoPtrOutput
	ToDomainVideoPtrOutputWithContext(context.Context) DomainVideoPtrOutput
}

type domainVideoPtrType DomainVideoArgs

func DomainVideoPtr(v *DomainVideoArgs) DomainVideoPtrInput {
	return (*domainVideoPtrType)(v)
}

func (*domainVideoPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**DomainVideo)(nil)).Elem()
}

func (i *domainVideoPtrType) ToDomainVideoPtrOutput() DomainVideoPtrOutput {
	return i.ToDomainVideoPtrOutputWithContext(context.Background())
}

func (i *domainVideoPtrType) ToDomainVideoPtrOutputWithContext(ctx context.Context) DomainVideoPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DomainVideoPtrOutput)
}

type DomainVideoOutput struct{ *pulumi.OutputState }

func (DomainVideoOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DomainVideo)(nil)).Elem()
}

func (o DomainVideoOutput) ToDomainVideoOutput() DomainVideoOutput {
	return o
}

func (o DomainVideoOutput) ToDomainVideoOutputWithContext(ctx context.Context) DomainVideoOutput {
	return o
}

func (o DomainVideoOutput) ToDomainVideoPtrOutput() DomainVideoPtrOutput {
	return o.ToDomainVideoPtrOutputWithContext(context.Background())
}

func (o DomainVideoOutput) ToDomainVideoPtrOutputWithContext(ctx context.Context) DomainVideoPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v DomainVideo) *DomainVideo {
		return &v
	}).(DomainVideoPtrOutput)
}

// The type of hypervisor to use for the domain.  Defaults to `kvm`, other values can be found [here](https://libvirt.org/formatdomain.html#id1)
func (o DomainVideoOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DomainVideo) *string { return v.Type }).(pulumi.StringPtrOutput)
}

type DomainVideoPtrOutput struct{ *pulumi.OutputState }

func (DomainVideoPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**DomainVideo)(nil)).Elem()
}

func (o DomainVideoPtrOutput) ToDomainVideoPtrOutput() DomainVideoPtrOutput {
	return o
}

func (o DomainVideoPtrOutput) ToDomainVideoPtrOutputWithContext(ctx context.Context) DomainVideoPtrOutput {
	return o
}

func (o DomainVideoPtrOutput) Elem() DomainVideoOutput {
	return o.ApplyT(func(v *DomainVideo) DomainVideo {
		if v != nil {
			return *v
		}
		var ret DomainVideo
		return ret
	}).(DomainVideoOutput)
}

// The type of hypervisor to use for the domain.  Defaults to `kvm`, other values can be found [here](https://libvirt.org/formatdomain.html#id1)
func (o DomainVideoPtrOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *DomainVideo) *string {
		if v == nil {
			return nil
		}
		return v.Type
	}).(pulumi.StringPtrOutput)
}

type DomainXml struct {
	Xslt *string `pulumi:"xslt"`
}

// DomainXmlInput is an input type that accepts DomainXmlArgs and DomainXmlOutput values.
// You can construct a concrete instance of `DomainXmlInput` via:
//
//	DomainXmlArgs{...}
type DomainXmlInput interface {
	pulumi.Input

	ToDomainXmlOutput() DomainXmlOutput
	ToDomainXmlOutputWithContext(context.Context) DomainXmlOutput
}

type DomainXmlArgs struct {
	Xslt pulumi.StringPtrInput `pulumi:"xslt"`
}

func (DomainXmlArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*DomainXml)(nil)).Elem()
}

func (i DomainXmlArgs) ToDomainXmlOutput() DomainXmlOutput {
	return i.ToDomainXmlOutputWithContext(context.Background())
}

func (i DomainXmlArgs) ToDomainXmlOutputWithContext(ctx context.Context) DomainXmlOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DomainXmlOutput)
}

func (i DomainXmlArgs) ToDomainXmlPtrOutput() DomainXmlPtrOutput {
	return i.ToDomainXmlPtrOutputWithContext(context.Background())
}

func (i DomainXmlArgs) ToDomainXmlPtrOutputWithContext(ctx context.Context) DomainXmlPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DomainXmlOutput).ToDomainXmlPtrOutputWithContext(ctx)
}

// DomainXmlPtrInput is an input type that accepts DomainXmlArgs, DomainXmlPtr and DomainXmlPtrOutput values.
// You can construct a concrete instance of `DomainXmlPtrInput` via:
//
//	        DomainXmlArgs{...}
//
//	or:
//
//	        nil
type DomainXmlPtrInput interface {
	pulumi.Input

	ToDomainXmlPtrOutput() DomainXmlPtrOutput
	ToDomainXmlPtrOutputWithContext(context.Context) DomainXmlPtrOutput
}

type domainXmlPtrType DomainXmlArgs

func DomainXmlPtr(v *DomainXmlArgs) DomainXmlPtrInput {
	return (*domainXmlPtrType)(v)
}

func (*domainXmlPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**DomainXml)(nil)).Elem()
}

func (i *domainXmlPtrType) ToDomainXmlPtrOutput() DomainXmlPtrOutput {
	return i.ToDomainXmlPtrOutputWithContext(context.Background())
}

func (i *domainXmlPtrType) ToDomainXmlPtrOutputWithContext(ctx context.Context) DomainXmlPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DomainXmlPtrOutput)
}

type DomainXmlOutput struct{ *pulumi.OutputState }

func (DomainXmlOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*DomainXml)(nil)).Elem()
}

func (o DomainXmlOutput) ToDomainXmlOutput() DomainXmlOutput {
	return o
}

func (o DomainXmlOutput) ToDomainXmlOutputWithContext(ctx context.Context) DomainXmlOutput {
	return o
}

func (o DomainXmlOutput) ToDomainXmlPtrOutput() DomainXmlPtrOutput {
	return o.ToDomainXmlPtrOutputWithContext(context.Background())
}

func (o DomainXmlOutput) ToDomainXmlPtrOutputWithContext(ctx context.Context) DomainXmlPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v DomainXml) *DomainXml {
		return &v
	}).(DomainXmlPtrOutput)
}

func (o DomainXmlOutput) Xslt() pulumi.StringPtrOutput {
	return o.ApplyT(func(v DomainXml) *string { return v.Xslt }).(pulumi.StringPtrOutput)
}

type DomainXmlPtrOutput struct{ *pulumi.OutputState }

func (DomainXmlPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**DomainXml)(nil)).Elem()
}

func (o DomainXmlPtrOutput) ToDomainXmlPtrOutput() DomainXmlPtrOutput {
	return o
}

func (o DomainXmlPtrOutput) ToDomainXmlPtrOutputWithContext(ctx context.Context) DomainXmlPtrOutput {
	return o
}

func (o DomainXmlPtrOutput) Elem() DomainXmlOutput {
	return o.ApplyT(func(v *DomainXml) DomainXml {
		if v != nil {
			return *v
		}
		var ret DomainXml
		return ret
	}).(DomainXmlOutput)
}

func (o DomainXmlPtrOutput) Xslt() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *DomainXml) *string {
		if v == nil {
			return nil
		}
		return v.Xslt
	}).(pulumi.StringPtrOutput)
}

type NetworkDhcp struct {
	// when false, disable the DHCP server
	Enabled *bool `pulumi:"enabled"`
}

// NetworkDhcpInput is an input type that accepts NetworkDhcpArgs and NetworkDhcpOutput values.
// You can construct a concrete instance of `NetworkDhcpInput` via:
//
//	NetworkDhcpArgs{...}
type NetworkDhcpInput interface {
	pulumi.Input

	ToNetworkDhcpOutput() NetworkDhcpOutput
	ToNetworkDhcpOutputWithContext(context.Context) NetworkDhcpOutput
}

type NetworkDhcpArgs struct {
	// when false, disable the DHCP server
	Enabled pulumi.BoolPtrInput `pulumi:"enabled"`
}

func (NetworkDhcpArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*NetworkDhcp)(nil)).Elem()
}

func (i NetworkDhcpArgs) ToNetworkDhcpOutput() NetworkDhcpOutput {
	return i.ToNetworkDhcpOutputWithContext(context.Background())
}

func (i NetworkDhcpArgs) ToNetworkDhcpOutputWithContext(ctx context.Context) NetworkDhcpOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NetworkDhcpOutput)
}

func (i NetworkDhcpArgs) ToNetworkDhcpPtrOutput() NetworkDhcpPtrOutput {
	return i.ToNetworkDhcpPtrOutputWithContext(context.Background())
}

func (i NetworkDhcpArgs) ToNetworkDhcpPtrOutputWithContext(ctx context.Context) NetworkDhcpPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NetworkDhcpOutput).ToNetworkDhcpPtrOutputWithContext(ctx)
}

// NetworkDhcpPtrInput is an input type that accepts NetworkDhcpArgs, NetworkDhcpPtr and NetworkDhcpPtrOutput values.
// You can construct a concrete instance of `NetworkDhcpPtrInput` via:
//
//	        NetworkDhcpArgs{...}
//
//	or:
//
//	        nil
type NetworkDhcpPtrInput interface {
	pulumi.Input

	ToNetworkDhcpPtrOutput() NetworkDhcpPtrOutput
	ToNetworkDhcpPtrOutputWithContext(context.Context) NetworkDhcpPtrOutput
}

type networkDhcpPtrType NetworkDhcpArgs

func NetworkDhcpPtr(v *NetworkDhcpArgs) NetworkDhcpPtrInput {
	return (*networkDhcpPtrType)(v)
}

func (*networkDhcpPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**NetworkDhcp)(nil)).Elem()
}

func (i *networkDhcpPtrType) ToNetworkDhcpPtrOutput() NetworkDhcpPtrOutput {
	return i.ToNetworkDhcpPtrOutputWithContext(context.Background())
}

func (i *networkDhcpPtrType) ToNetworkDhcpPtrOutputWithContext(ctx context.Context) NetworkDhcpPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NetworkDhcpPtrOutput)
}

type NetworkDhcpOutput struct{ *pulumi.OutputState }

func (NetworkDhcpOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*NetworkDhcp)(nil)).Elem()
}

func (o NetworkDhcpOutput) ToNetworkDhcpOutput() NetworkDhcpOutput {
	return o
}

func (o NetworkDhcpOutput) ToNetworkDhcpOutputWithContext(ctx context.Context) NetworkDhcpOutput {
	return o
}

func (o NetworkDhcpOutput) ToNetworkDhcpPtrOutput() NetworkDhcpPtrOutput {
	return o.ToNetworkDhcpPtrOutputWithContext(context.Background())
}

func (o NetworkDhcpOutput) ToNetworkDhcpPtrOutputWithContext(ctx context.Context) NetworkDhcpPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v NetworkDhcp) *NetworkDhcp {
		return &v
	}).(NetworkDhcpPtrOutput)
}

// when false, disable the DHCP server
func (o NetworkDhcpOutput) Enabled() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v NetworkDhcp) *bool { return v.Enabled }).(pulumi.BoolPtrOutput)
}

type NetworkDhcpPtrOutput struct{ *pulumi.OutputState }

func (NetworkDhcpPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**NetworkDhcp)(nil)).Elem()
}

func (o NetworkDhcpPtrOutput) ToNetworkDhcpPtrOutput() NetworkDhcpPtrOutput {
	return o
}

func (o NetworkDhcpPtrOutput) ToNetworkDhcpPtrOutputWithContext(ctx context.Context) NetworkDhcpPtrOutput {
	return o
}

func (o NetworkDhcpPtrOutput) Elem() NetworkDhcpOutput {
	return o.ApplyT(func(v *NetworkDhcp) NetworkDhcp {
		if v != nil {
			return *v
		}
		var ret NetworkDhcp
		return ret
	}).(NetworkDhcpOutput)
}

// when false, disable the DHCP server
func (o NetworkDhcpPtrOutput) Enabled() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *NetworkDhcp) *bool {
		if v == nil {
			return nil
		}
		return v.Enabled
	}).(pulumi.BoolPtrOutput)
}

type NetworkDns struct {
	// when false, disable the DHCP server
	Enabled *bool `pulumi:"enabled"`
	// Either `address`, `domain`, or both must be set
	Forwarders []NetworkDnsForwarder `pulumi:"forwarders"`
	// a DNS host entry block. You can have one or more of these
	// blocks in your DNS definition. You must specify both `ip` and `hostname`.
	//
	// An advanced example of round-robin DNS (using DNS host templates) follows:
	Hosts []NetworkDnsHost `pulumi:"hosts"`
	// true/false: true means 'do not forward unresolved requests for this domain to the part DNS server
	LocalOnly *bool `pulumi:"localOnly"`
	// a DNS SRV entry block. You can have one or more of these blocks
	// in your DNS definition. You must specify `service` and `protocol`.
	Srvs []NetworkDnsSrv `pulumi:"srvs"`
}

// NetworkDnsInput is an input type that accepts NetworkDnsArgs and NetworkDnsOutput values.
// You can construct a concrete instance of `NetworkDnsInput` via:
//
//	NetworkDnsArgs{...}
type NetworkDnsInput interface {
	pulumi.Input

	ToNetworkDnsOutput() NetworkDnsOutput
	ToNetworkDnsOutputWithContext(context.Context) NetworkDnsOutput
}

type NetworkDnsArgs struct {
	// when false, disable the DHCP server
	Enabled pulumi.BoolPtrInput `pulumi:"enabled"`
	// Either `address`, `domain`, or both must be set
	Forwarders NetworkDnsForwarderArrayInput `pulumi:"forwarders"`
	// a DNS host entry block. You can have one or more of these
	// blocks in your DNS definition. You must specify both `ip` and `hostname`.
	//
	// An advanced example of round-robin DNS (using DNS host templates) follows:
	Hosts NetworkDnsHostArrayInput `pulumi:"hosts"`
	// true/false: true means 'do not forward unresolved requests for this domain to the part DNS server
	LocalOnly pulumi.BoolPtrInput `pulumi:"localOnly"`
	// a DNS SRV entry block. You can have one or more of these blocks
	// in your DNS definition. You must specify `service` and `protocol`.
	Srvs NetworkDnsSrvArrayInput `pulumi:"srvs"`
}

func (NetworkDnsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*NetworkDns)(nil)).Elem()
}

func (i NetworkDnsArgs) ToNetworkDnsOutput() NetworkDnsOutput {
	return i.ToNetworkDnsOutputWithContext(context.Background())
}

func (i NetworkDnsArgs) ToNetworkDnsOutputWithContext(ctx context.Context) NetworkDnsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NetworkDnsOutput)
}

func (i NetworkDnsArgs) ToNetworkDnsPtrOutput() NetworkDnsPtrOutput {
	return i.ToNetworkDnsPtrOutputWithContext(context.Background())
}

func (i NetworkDnsArgs) ToNetworkDnsPtrOutputWithContext(ctx context.Context) NetworkDnsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NetworkDnsOutput).ToNetworkDnsPtrOutputWithContext(ctx)
}

// NetworkDnsPtrInput is an input type that accepts NetworkDnsArgs, NetworkDnsPtr and NetworkDnsPtrOutput values.
// You can construct a concrete instance of `NetworkDnsPtrInput` via:
//
//	        NetworkDnsArgs{...}
//
//	or:
//
//	        nil
type NetworkDnsPtrInput interface {
	pulumi.Input

	ToNetworkDnsPtrOutput() NetworkDnsPtrOutput
	ToNetworkDnsPtrOutputWithContext(context.Context) NetworkDnsPtrOutput
}

type networkDnsPtrType NetworkDnsArgs

func NetworkDnsPtr(v *NetworkDnsArgs) NetworkDnsPtrInput {
	return (*networkDnsPtrType)(v)
}

func (*networkDnsPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**NetworkDns)(nil)).Elem()
}

func (i *networkDnsPtrType) ToNetworkDnsPtrOutput() NetworkDnsPtrOutput {
	return i.ToNetworkDnsPtrOutputWithContext(context.Background())
}

func (i *networkDnsPtrType) ToNetworkDnsPtrOutputWithContext(ctx context.Context) NetworkDnsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NetworkDnsPtrOutput)
}

type NetworkDnsOutput struct{ *pulumi.OutputState }

func (NetworkDnsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*NetworkDns)(nil)).Elem()
}

func (o NetworkDnsOutput) ToNetworkDnsOutput() NetworkDnsOutput {
	return o
}

func (o NetworkDnsOutput) ToNetworkDnsOutputWithContext(ctx context.Context) NetworkDnsOutput {
	return o
}

func (o NetworkDnsOutput) ToNetworkDnsPtrOutput() NetworkDnsPtrOutput {
	return o.ToNetworkDnsPtrOutputWithContext(context.Background())
}

func (o NetworkDnsOutput) ToNetworkDnsPtrOutputWithContext(ctx context.Context) NetworkDnsPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v NetworkDns) *NetworkDns {
		return &v
	}).(NetworkDnsPtrOutput)
}

// when false, disable the DHCP server
func (o NetworkDnsOutput) Enabled() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v NetworkDns) *bool { return v.Enabled }).(pulumi.BoolPtrOutput)
}

// Either `address`, `domain`, or both must be set
func (o NetworkDnsOutput) Forwarders() NetworkDnsForwarderArrayOutput {
	return o.ApplyT(func(v NetworkDns) []NetworkDnsForwarder { return v.Forwarders }).(NetworkDnsForwarderArrayOutput)
}

// a DNS host entry block. You can have one or more of these
// blocks in your DNS definition. You must specify both `ip` and `hostname`.
//
// An advanced example of round-robin DNS (using DNS host templates) follows:
func (o NetworkDnsOutput) Hosts() NetworkDnsHostArrayOutput {
	return o.ApplyT(func(v NetworkDns) []NetworkDnsHost { return v.Hosts }).(NetworkDnsHostArrayOutput)
}

// true/false: true means 'do not forward unresolved requests for this domain to the part DNS server
func (o NetworkDnsOutput) LocalOnly() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v NetworkDns) *bool { return v.LocalOnly }).(pulumi.BoolPtrOutput)
}

// a DNS SRV entry block. You can have one or more of these blocks
// in your DNS definition. You must specify `service` and `protocol`.
func (o NetworkDnsOutput) Srvs() NetworkDnsSrvArrayOutput {
	return o.ApplyT(func(v NetworkDns) []NetworkDnsSrv { return v.Srvs }).(NetworkDnsSrvArrayOutput)
}

type NetworkDnsPtrOutput struct{ *pulumi.OutputState }

func (NetworkDnsPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**NetworkDns)(nil)).Elem()
}

func (o NetworkDnsPtrOutput) ToNetworkDnsPtrOutput() NetworkDnsPtrOutput {
	return o
}

func (o NetworkDnsPtrOutput) ToNetworkDnsPtrOutputWithContext(ctx context.Context) NetworkDnsPtrOutput {
	return o
}

func (o NetworkDnsPtrOutput) Elem() NetworkDnsOutput {
	return o.ApplyT(func(v *NetworkDns) NetworkDns {
		if v != nil {
			return *v
		}
		var ret NetworkDns
		return ret
	}).(NetworkDnsOutput)
}

// when false, disable the DHCP server
func (o NetworkDnsPtrOutput) Enabled() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *NetworkDns) *bool {
		if v == nil {
			return nil
		}
		return v.Enabled
	}).(pulumi.BoolPtrOutput)
}

// Either `address`, `domain`, or both must be set
func (o NetworkDnsPtrOutput) Forwarders() NetworkDnsForwarderArrayOutput {
	return o.ApplyT(func(v *NetworkDns) []NetworkDnsForwarder {
		if v == nil {
			return nil
		}
		return v.Forwarders
	}).(NetworkDnsForwarderArrayOutput)
}

// a DNS host entry block. You can have one or more of these
// blocks in your DNS definition. You must specify both `ip` and `hostname`.
//
// An advanced example of round-robin DNS (using DNS host templates) follows:
func (o NetworkDnsPtrOutput) Hosts() NetworkDnsHostArrayOutput {
	return o.ApplyT(func(v *NetworkDns) []NetworkDnsHost {
		if v == nil {
			return nil
		}
		return v.Hosts
	}).(NetworkDnsHostArrayOutput)
}

// true/false: true means 'do not forward unresolved requests for this domain to the part DNS server
func (o NetworkDnsPtrOutput) LocalOnly() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *NetworkDns) *bool {
		if v == nil {
			return nil
		}
		return v.LocalOnly
	}).(pulumi.BoolPtrOutput)
}

// a DNS SRV entry block. You can have one or more of these blocks
// in your DNS definition. You must specify `service` and `protocol`.
func (o NetworkDnsPtrOutput) Srvs() NetworkDnsSrvArrayOutput {
	return o.ApplyT(func(v *NetworkDns) []NetworkDnsSrv {
		if v == nil {
			return nil
		}
		return v.Srvs
	}).(NetworkDnsSrvArrayOutput)
}

type NetworkDnsForwarder struct {
	Address *string `pulumi:"address"`
	// The domain used by the DNS server.
	Domain *string `pulumi:"domain"`
}

// NetworkDnsForwarderInput is an input type that accepts NetworkDnsForwarderArgs and NetworkDnsForwarderOutput values.
// You can construct a concrete instance of `NetworkDnsForwarderInput` via:
//
//	NetworkDnsForwarderArgs{...}
type NetworkDnsForwarderInput interface {
	pulumi.Input

	ToNetworkDnsForwarderOutput() NetworkDnsForwarderOutput
	ToNetworkDnsForwarderOutputWithContext(context.Context) NetworkDnsForwarderOutput
}

type NetworkDnsForwarderArgs struct {
	Address pulumi.StringPtrInput `pulumi:"address"`
	// The domain used by the DNS server.
	Domain pulumi.StringPtrInput `pulumi:"domain"`
}

func (NetworkDnsForwarderArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*NetworkDnsForwarder)(nil)).Elem()
}

func (i NetworkDnsForwarderArgs) ToNetworkDnsForwarderOutput() NetworkDnsForwarderOutput {
	return i.ToNetworkDnsForwarderOutputWithContext(context.Background())
}

func (i NetworkDnsForwarderArgs) ToNetworkDnsForwarderOutputWithContext(ctx context.Context) NetworkDnsForwarderOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NetworkDnsForwarderOutput)
}

// NetworkDnsForwarderArrayInput is an input type that accepts NetworkDnsForwarderArray and NetworkDnsForwarderArrayOutput values.
// You can construct a concrete instance of `NetworkDnsForwarderArrayInput` via:
//
//	NetworkDnsForwarderArray{ NetworkDnsForwarderArgs{...} }
type NetworkDnsForwarderArrayInput interface {
	pulumi.Input

	ToNetworkDnsForwarderArrayOutput() NetworkDnsForwarderArrayOutput
	ToNetworkDnsForwarderArrayOutputWithContext(context.Context) NetworkDnsForwarderArrayOutput
}

type NetworkDnsForwarderArray []NetworkDnsForwarderInput

func (NetworkDnsForwarderArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]NetworkDnsForwarder)(nil)).Elem()
}

func (i NetworkDnsForwarderArray) ToNetworkDnsForwarderArrayOutput() NetworkDnsForwarderArrayOutput {
	return i.ToNetworkDnsForwarderArrayOutputWithContext(context.Background())
}

func (i NetworkDnsForwarderArray) ToNetworkDnsForwarderArrayOutputWithContext(ctx context.Context) NetworkDnsForwarderArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NetworkDnsForwarderArrayOutput)
}

type NetworkDnsForwarderOutput struct{ *pulumi.OutputState }

func (NetworkDnsForwarderOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*NetworkDnsForwarder)(nil)).Elem()
}

func (o NetworkDnsForwarderOutput) ToNetworkDnsForwarderOutput() NetworkDnsForwarderOutput {
	return o
}

func (o NetworkDnsForwarderOutput) ToNetworkDnsForwarderOutputWithContext(ctx context.Context) NetworkDnsForwarderOutput {
	return o
}

func (o NetworkDnsForwarderOutput) Address() pulumi.StringPtrOutput {
	return o.ApplyT(func(v NetworkDnsForwarder) *string { return v.Address }).(pulumi.StringPtrOutput)
}

// The domain used by the DNS server.
func (o NetworkDnsForwarderOutput) Domain() pulumi.StringPtrOutput {
	return o.ApplyT(func(v NetworkDnsForwarder) *string { return v.Domain }).(pulumi.StringPtrOutput)
}

type NetworkDnsForwarderArrayOutput struct{ *pulumi.OutputState }

func (NetworkDnsForwarderArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]NetworkDnsForwarder)(nil)).Elem()
}

func (o NetworkDnsForwarderArrayOutput) ToNetworkDnsForwarderArrayOutput() NetworkDnsForwarderArrayOutput {
	return o
}

func (o NetworkDnsForwarderArrayOutput) ToNetworkDnsForwarderArrayOutputWithContext(ctx context.Context) NetworkDnsForwarderArrayOutput {
	return o
}

func (o NetworkDnsForwarderArrayOutput) Index(i pulumi.IntInput) NetworkDnsForwarderOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) NetworkDnsForwarder {
		return vs[0].([]NetworkDnsForwarder)[vs[1].(int)]
	}).(NetworkDnsForwarderOutput)
}

type NetworkDnsHost struct {
	Hostname *string `pulumi:"hostname"`
	Ip       *string `pulumi:"ip"`
}

// NetworkDnsHostInput is an input type that accepts NetworkDnsHostArgs and NetworkDnsHostOutput values.
// You can construct a concrete instance of `NetworkDnsHostInput` via:
//
//	NetworkDnsHostArgs{...}
type NetworkDnsHostInput interface {
	pulumi.Input

	ToNetworkDnsHostOutput() NetworkDnsHostOutput
	ToNetworkDnsHostOutputWithContext(context.Context) NetworkDnsHostOutput
}

type NetworkDnsHostArgs struct {
	Hostname pulumi.StringPtrInput `pulumi:"hostname"`
	Ip       pulumi.StringPtrInput `pulumi:"ip"`
}

func (NetworkDnsHostArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*NetworkDnsHost)(nil)).Elem()
}

func (i NetworkDnsHostArgs) ToNetworkDnsHostOutput() NetworkDnsHostOutput {
	return i.ToNetworkDnsHostOutputWithContext(context.Background())
}

func (i NetworkDnsHostArgs) ToNetworkDnsHostOutputWithContext(ctx context.Context) NetworkDnsHostOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NetworkDnsHostOutput)
}

// NetworkDnsHostArrayInput is an input type that accepts NetworkDnsHostArray and NetworkDnsHostArrayOutput values.
// You can construct a concrete instance of `NetworkDnsHostArrayInput` via:
//
//	NetworkDnsHostArray{ NetworkDnsHostArgs{...} }
type NetworkDnsHostArrayInput interface {
	pulumi.Input

	ToNetworkDnsHostArrayOutput() NetworkDnsHostArrayOutput
	ToNetworkDnsHostArrayOutputWithContext(context.Context) NetworkDnsHostArrayOutput
}

type NetworkDnsHostArray []NetworkDnsHostInput

func (NetworkDnsHostArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]NetworkDnsHost)(nil)).Elem()
}

func (i NetworkDnsHostArray) ToNetworkDnsHostArrayOutput() NetworkDnsHostArrayOutput {
	return i.ToNetworkDnsHostArrayOutputWithContext(context.Background())
}

func (i NetworkDnsHostArray) ToNetworkDnsHostArrayOutputWithContext(ctx context.Context) NetworkDnsHostArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NetworkDnsHostArrayOutput)
}

type NetworkDnsHostOutput struct{ *pulumi.OutputState }

func (NetworkDnsHostOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*NetworkDnsHost)(nil)).Elem()
}

func (o NetworkDnsHostOutput) ToNetworkDnsHostOutput() NetworkDnsHostOutput {
	return o
}

func (o NetworkDnsHostOutput) ToNetworkDnsHostOutputWithContext(ctx context.Context) NetworkDnsHostOutput {
	return o
}

func (o NetworkDnsHostOutput) Hostname() pulumi.StringPtrOutput {
	return o.ApplyT(func(v NetworkDnsHost) *string { return v.Hostname }).(pulumi.StringPtrOutput)
}

func (o NetworkDnsHostOutput) Ip() pulumi.StringPtrOutput {
	return o.ApplyT(func(v NetworkDnsHost) *string { return v.Ip }).(pulumi.StringPtrOutput)
}

type NetworkDnsHostArrayOutput struct{ *pulumi.OutputState }

func (NetworkDnsHostArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]NetworkDnsHost)(nil)).Elem()
}

func (o NetworkDnsHostArrayOutput) ToNetworkDnsHostArrayOutput() NetworkDnsHostArrayOutput {
	return o
}

func (o NetworkDnsHostArrayOutput) ToNetworkDnsHostArrayOutputWithContext(ctx context.Context) NetworkDnsHostArrayOutput {
	return o
}

func (o NetworkDnsHostArrayOutput) Index(i pulumi.IntInput) NetworkDnsHostOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) NetworkDnsHost {
		return vs[0].([]NetworkDnsHost)[vs[1].(int)]
	}).(NetworkDnsHostOutput)
}

type NetworkDnsSrv struct {
	// The domain used by the DNS server.
	Domain   *string `pulumi:"domain"`
	Port     *string `pulumi:"port"`
	Priority *string `pulumi:"priority"`
	Protocol *string `pulumi:"protocol"`
	Service  *string `pulumi:"service"`
	Target   *string `pulumi:"target"`
	Weight   *string `pulumi:"weight"`
}

// NetworkDnsSrvInput is an input type that accepts NetworkDnsSrvArgs and NetworkDnsSrvOutput values.
// You can construct a concrete instance of `NetworkDnsSrvInput` via:
//
//	NetworkDnsSrvArgs{...}
type NetworkDnsSrvInput interface {
	pulumi.Input

	ToNetworkDnsSrvOutput() NetworkDnsSrvOutput
	ToNetworkDnsSrvOutputWithContext(context.Context) NetworkDnsSrvOutput
}

type NetworkDnsSrvArgs struct {
	// The domain used by the DNS server.
	Domain   pulumi.StringPtrInput `pulumi:"domain"`
	Port     pulumi.StringPtrInput `pulumi:"port"`
	Priority pulumi.StringPtrInput `pulumi:"priority"`
	Protocol pulumi.StringPtrInput `pulumi:"protocol"`
	Service  pulumi.StringPtrInput `pulumi:"service"`
	Target   pulumi.StringPtrInput `pulumi:"target"`
	Weight   pulumi.StringPtrInput `pulumi:"weight"`
}

func (NetworkDnsSrvArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*NetworkDnsSrv)(nil)).Elem()
}

func (i NetworkDnsSrvArgs) ToNetworkDnsSrvOutput() NetworkDnsSrvOutput {
	return i.ToNetworkDnsSrvOutputWithContext(context.Background())
}

func (i NetworkDnsSrvArgs) ToNetworkDnsSrvOutputWithContext(ctx context.Context) NetworkDnsSrvOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NetworkDnsSrvOutput)
}

// NetworkDnsSrvArrayInput is an input type that accepts NetworkDnsSrvArray and NetworkDnsSrvArrayOutput values.
// You can construct a concrete instance of `NetworkDnsSrvArrayInput` via:
//
//	NetworkDnsSrvArray{ NetworkDnsSrvArgs{...} }
type NetworkDnsSrvArrayInput interface {
	pulumi.Input

	ToNetworkDnsSrvArrayOutput() NetworkDnsSrvArrayOutput
	ToNetworkDnsSrvArrayOutputWithContext(context.Context) NetworkDnsSrvArrayOutput
}

type NetworkDnsSrvArray []NetworkDnsSrvInput

func (NetworkDnsSrvArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]NetworkDnsSrv)(nil)).Elem()
}

func (i NetworkDnsSrvArray) ToNetworkDnsSrvArrayOutput() NetworkDnsSrvArrayOutput {
	return i.ToNetworkDnsSrvArrayOutputWithContext(context.Background())
}

func (i NetworkDnsSrvArray) ToNetworkDnsSrvArrayOutputWithContext(ctx context.Context) NetworkDnsSrvArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NetworkDnsSrvArrayOutput)
}

type NetworkDnsSrvOutput struct{ *pulumi.OutputState }

func (NetworkDnsSrvOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*NetworkDnsSrv)(nil)).Elem()
}

func (o NetworkDnsSrvOutput) ToNetworkDnsSrvOutput() NetworkDnsSrvOutput {
	return o
}

func (o NetworkDnsSrvOutput) ToNetworkDnsSrvOutputWithContext(ctx context.Context) NetworkDnsSrvOutput {
	return o
}

// The domain used by the DNS server.
func (o NetworkDnsSrvOutput) Domain() pulumi.StringPtrOutput {
	return o.ApplyT(func(v NetworkDnsSrv) *string { return v.Domain }).(pulumi.StringPtrOutput)
}

func (o NetworkDnsSrvOutput) Port() pulumi.StringPtrOutput {
	return o.ApplyT(func(v NetworkDnsSrv) *string { return v.Port }).(pulumi.StringPtrOutput)
}

func (o NetworkDnsSrvOutput) Priority() pulumi.StringPtrOutput {
	return o.ApplyT(func(v NetworkDnsSrv) *string { return v.Priority }).(pulumi.StringPtrOutput)
}

func (o NetworkDnsSrvOutput) Protocol() pulumi.StringPtrOutput {
	return o.ApplyT(func(v NetworkDnsSrv) *string { return v.Protocol }).(pulumi.StringPtrOutput)
}

func (o NetworkDnsSrvOutput) Service() pulumi.StringPtrOutput {
	return o.ApplyT(func(v NetworkDnsSrv) *string { return v.Service }).(pulumi.StringPtrOutput)
}

func (o NetworkDnsSrvOutput) Target() pulumi.StringPtrOutput {
	return o.ApplyT(func(v NetworkDnsSrv) *string { return v.Target }).(pulumi.StringPtrOutput)
}

func (o NetworkDnsSrvOutput) Weight() pulumi.StringPtrOutput {
	return o.ApplyT(func(v NetworkDnsSrv) *string { return v.Weight }).(pulumi.StringPtrOutput)
}

type NetworkDnsSrvArrayOutput struct{ *pulumi.OutputState }

func (NetworkDnsSrvArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]NetworkDnsSrv)(nil)).Elem()
}

func (o NetworkDnsSrvArrayOutput) ToNetworkDnsSrvArrayOutput() NetworkDnsSrvArrayOutput {
	return o
}

func (o NetworkDnsSrvArrayOutput) ToNetworkDnsSrvArrayOutputWithContext(ctx context.Context) NetworkDnsSrvArrayOutput {
	return o
}

func (o NetworkDnsSrvArrayOutput) Index(i pulumi.IntInput) NetworkDnsSrvOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) NetworkDnsSrv {
		return vs[0].([]NetworkDnsSrv)[vs[1].(int)]
	}).(NetworkDnsSrvOutput)
}

type NetworkDnsmasqOptions struct {
	// a Dnsmasq option entry block. You can have one or more of these
	// blocks in your definition. You must specify `optionName` while `optionValue` is
	// optional to support value-less options.
	//
	// An example of setting Dnsmasq options (using Dnsmasq option templates) follows:
	Options []NetworkDnsmasqOptionsOption `pulumi:"options"`
}

// NetworkDnsmasqOptionsInput is an input type that accepts NetworkDnsmasqOptionsArgs and NetworkDnsmasqOptionsOutput values.
// You can construct a concrete instance of `NetworkDnsmasqOptionsInput` via:
//
//	NetworkDnsmasqOptionsArgs{...}
type NetworkDnsmasqOptionsInput interface {
	pulumi.Input

	ToNetworkDnsmasqOptionsOutput() NetworkDnsmasqOptionsOutput
	ToNetworkDnsmasqOptionsOutputWithContext(context.Context) NetworkDnsmasqOptionsOutput
}

type NetworkDnsmasqOptionsArgs struct {
	// a Dnsmasq option entry block. You can have one or more of these
	// blocks in your definition. You must specify `optionName` while `optionValue` is
	// optional to support value-less options.
	//
	// An example of setting Dnsmasq options (using Dnsmasq option templates) follows:
	Options NetworkDnsmasqOptionsOptionArrayInput `pulumi:"options"`
}

func (NetworkDnsmasqOptionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*NetworkDnsmasqOptions)(nil)).Elem()
}

func (i NetworkDnsmasqOptionsArgs) ToNetworkDnsmasqOptionsOutput() NetworkDnsmasqOptionsOutput {
	return i.ToNetworkDnsmasqOptionsOutputWithContext(context.Background())
}

func (i NetworkDnsmasqOptionsArgs) ToNetworkDnsmasqOptionsOutputWithContext(ctx context.Context) NetworkDnsmasqOptionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NetworkDnsmasqOptionsOutput)
}

func (i NetworkDnsmasqOptionsArgs) ToNetworkDnsmasqOptionsPtrOutput() NetworkDnsmasqOptionsPtrOutput {
	return i.ToNetworkDnsmasqOptionsPtrOutputWithContext(context.Background())
}

func (i NetworkDnsmasqOptionsArgs) ToNetworkDnsmasqOptionsPtrOutputWithContext(ctx context.Context) NetworkDnsmasqOptionsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NetworkDnsmasqOptionsOutput).ToNetworkDnsmasqOptionsPtrOutputWithContext(ctx)
}

// NetworkDnsmasqOptionsPtrInput is an input type that accepts NetworkDnsmasqOptionsArgs, NetworkDnsmasqOptionsPtr and NetworkDnsmasqOptionsPtrOutput values.
// You can construct a concrete instance of `NetworkDnsmasqOptionsPtrInput` via:
//
//	        NetworkDnsmasqOptionsArgs{...}
//
//	or:
//
//	        nil
type NetworkDnsmasqOptionsPtrInput interface {
	pulumi.Input

	ToNetworkDnsmasqOptionsPtrOutput() NetworkDnsmasqOptionsPtrOutput
	ToNetworkDnsmasqOptionsPtrOutputWithContext(context.Context) NetworkDnsmasqOptionsPtrOutput
}

type networkDnsmasqOptionsPtrType NetworkDnsmasqOptionsArgs

func NetworkDnsmasqOptionsPtr(v *NetworkDnsmasqOptionsArgs) NetworkDnsmasqOptionsPtrInput {
	return (*networkDnsmasqOptionsPtrType)(v)
}

func (*networkDnsmasqOptionsPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**NetworkDnsmasqOptions)(nil)).Elem()
}

func (i *networkDnsmasqOptionsPtrType) ToNetworkDnsmasqOptionsPtrOutput() NetworkDnsmasqOptionsPtrOutput {
	return i.ToNetworkDnsmasqOptionsPtrOutputWithContext(context.Background())
}

func (i *networkDnsmasqOptionsPtrType) ToNetworkDnsmasqOptionsPtrOutputWithContext(ctx context.Context) NetworkDnsmasqOptionsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NetworkDnsmasqOptionsPtrOutput)
}

type NetworkDnsmasqOptionsOutput struct{ *pulumi.OutputState }

func (NetworkDnsmasqOptionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*NetworkDnsmasqOptions)(nil)).Elem()
}

func (o NetworkDnsmasqOptionsOutput) ToNetworkDnsmasqOptionsOutput() NetworkDnsmasqOptionsOutput {
	return o
}

func (o NetworkDnsmasqOptionsOutput) ToNetworkDnsmasqOptionsOutputWithContext(ctx context.Context) NetworkDnsmasqOptionsOutput {
	return o
}

func (o NetworkDnsmasqOptionsOutput) ToNetworkDnsmasqOptionsPtrOutput() NetworkDnsmasqOptionsPtrOutput {
	return o.ToNetworkDnsmasqOptionsPtrOutputWithContext(context.Background())
}

func (o NetworkDnsmasqOptionsOutput) ToNetworkDnsmasqOptionsPtrOutputWithContext(ctx context.Context) NetworkDnsmasqOptionsPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v NetworkDnsmasqOptions) *NetworkDnsmasqOptions {
		return &v
	}).(NetworkDnsmasqOptionsPtrOutput)
}

// a Dnsmasq option entry block. You can have one or more of these
// blocks in your definition. You must specify `optionName` while `optionValue` is
// optional to support value-less options.
//
// An example of setting Dnsmasq options (using Dnsmasq option templates) follows:
func (o NetworkDnsmasqOptionsOutput) Options() NetworkDnsmasqOptionsOptionArrayOutput {
	return o.ApplyT(func(v NetworkDnsmasqOptions) []NetworkDnsmasqOptionsOption { return v.Options }).(NetworkDnsmasqOptionsOptionArrayOutput)
}

type NetworkDnsmasqOptionsPtrOutput struct{ *pulumi.OutputState }

func (NetworkDnsmasqOptionsPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**NetworkDnsmasqOptions)(nil)).Elem()
}

func (o NetworkDnsmasqOptionsPtrOutput) ToNetworkDnsmasqOptionsPtrOutput() NetworkDnsmasqOptionsPtrOutput {
	return o
}

func (o NetworkDnsmasqOptionsPtrOutput) ToNetworkDnsmasqOptionsPtrOutputWithContext(ctx context.Context) NetworkDnsmasqOptionsPtrOutput {
	return o
}

func (o NetworkDnsmasqOptionsPtrOutput) Elem() NetworkDnsmasqOptionsOutput {
	return o.ApplyT(func(v *NetworkDnsmasqOptions) NetworkDnsmasqOptions {
		if v != nil {
			return *v
		}
		var ret NetworkDnsmasqOptions
		return ret
	}).(NetworkDnsmasqOptionsOutput)
}

// a Dnsmasq option entry block. You can have one or more of these
// blocks in your definition. You must specify `optionName` while `optionValue` is
// optional to support value-less options.
//
// An example of setting Dnsmasq options (using Dnsmasq option templates) follows:
func (o NetworkDnsmasqOptionsPtrOutput) Options() NetworkDnsmasqOptionsOptionArrayOutput {
	return o.ApplyT(func(v *NetworkDnsmasqOptions) []NetworkDnsmasqOptionsOption {
		if v == nil {
			return nil
		}
		return v.Options
	}).(NetworkDnsmasqOptionsOptionArrayOutput)
}

type NetworkDnsmasqOptionsOption struct {
	OptionName  *string `pulumi:"optionName"`
	OptionValue *string `pulumi:"optionValue"`
}

// NetworkDnsmasqOptionsOptionInput is an input type that accepts NetworkDnsmasqOptionsOptionArgs and NetworkDnsmasqOptionsOptionOutput values.
// You can construct a concrete instance of `NetworkDnsmasqOptionsOptionInput` via:
//
//	NetworkDnsmasqOptionsOptionArgs{...}
type NetworkDnsmasqOptionsOptionInput interface {
	pulumi.Input

	ToNetworkDnsmasqOptionsOptionOutput() NetworkDnsmasqOptionsOptionOutput
	ToNetworkDnsmasqOptionsOptionOutputWithContext(context.Context) NetworkDnsmasqOptionsOptionOutput
}

type NetworkDnsmasqOptionsOptionArgs struct {
	OptionName  pulumi.StringPtrInput `pulumi:"optionName"`
	OptionValue pulumi.StringPtrInput `pulumi:"optionValue"`
}

func (NetworkDnsmasqOptionsOptionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*NetworkDnsmasqOptionsOption)(nil)).Elem()
}

func (i NetworkDnsmasqOptionsOptionArgs) ToNetworkDnsmasqOptionsOptionOutput() NetworkDnsmasqOptionsOptionOutput {
	return i.ToNetworkDnsmasqOptionsOptionOutputWithContext(context.Background())
}

func (i NetworkDnsmasqOptionsOptionArgs) ToNetworkDnsmasqOptionsOptionOutputWithContext(ctx context.Context) NetworkDnsmasqOptionsOptionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NetworkDnsmasqOptionsOptionOutput)
}

// NetworkDnsmasqOptionsOptionArrayInput is an input type that accepts NetworkDnsmasqOptionsOptionArray and NetworkDnsmasqOptionsOptionArrayOutput values.
// You can construct a concrete instance of `NetworkDnsmasqOptionsOptionArrayInput` via:
//
//	NetworkDnsmasqOptionsOptionArray{ NetworkDnsmasqOptionsOptionArgs{...} }
type NetworkDnsmasqOptionsOptionArrayInput interface {
	pulumi.Input

	ToNetworkDnsmasqOptionsOptionArrayOutput() NetworkDnsmasqOptionsOptionArrayOutput
	ToNetworkDnsmasqOptionsOptionArrayOutputWithContext(context.Context) NetworkDnsmasqOptionsOptionArrayOutput
}

type NetworkDnsmasqOptionsOptionArray []NetworkDnsmasqOptionsOptionInput

func (NetworkDnsmasqOptionsOptionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]NetworkDnsmasqOptionsOption)(nil)).Elem()
}

func (i NetworkDnsmasqOptionsOptionArray) ToNetworkDnsmasqOptionsOptionArrayOutput() NetworkDnsmasqOptionsOptionArrayOutput {
	return i.ToNetworkDnsmasqOptionsOptionArrayOutputWithContext(context.Background())
}

func (i NetworkDnsmasqOptionsOptionArray) ToNetworkDnsmasqOptionsOptionArrayOutputWithContext(ctx context.Context) NetworkDnsmasqOptionsOptionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NetworkDnsmasqOptionsOptionArrayOutput)
}

type NetworkDnsmasqOptionsOptionOutput struct{ *pulumi.OutputState }

func (NetworkDnsmasqOptionsOptionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*NetworkDnsmasqOptionsOption)(nil)).Elem()
}

func (o NetworkDnsmasqOptionsOptionOutput) ToNetworkDnsmasqOptionsOptionOutput() NetworkDnsmasqOptionsOptionOutput {
	return o
}

func (o NetworkDnsmasqOptionsOptionOutput) ToNetworkDnsmasqOptionsOptionOutputWithContext(ctx context.Context) NetworkDnsmasqOptionsOptionOutput {
	return o
}

func (o NetworkDnsmasqOptionsOptionOutput) OptionName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v NetworkDnsmasqOptionsOption) *string { return v.OptionName }).(pulumi.StringPtrOutput)
}

func (o NetworkDnsmasqOptionsOptionOutput) OptionValue() pulumi.StringPtrOutput {
	return o.ApplyT(func(v NetworkDnsmasqOptionsOption) *string { return v.OptionValue }).(pulumi.StringPtrOutput)
}

type NetworkDnsmasqOptionsOptionArrayOutput struct{ *pulumi.OutputState }

func (NetworkDnsmasqOptionsOptionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]NetworkDnsmasqOptionsOption)(nil)).Elem()
}

func (o NetworkDnsmasqOptionsOptionArrayOutput) ToNetworkDnsmasqOptionsOptionArrayOutput() NetworkDnsmasqOptionsOptionArrayOutput {
	return o
}

func (o NetworkDnsmasqOptionsOptionArrayOutput) ToNetworkDnsmasqOptionsOptionArrayOutputWithContext(ctx context.Context) NetworkDnsmasqOptionsOptionArrayOutput {
	return o
}

func (o NetworkDnsmasqOptionsOptionArrayOutput) Index(i pulumi.IntInput) NetworkDnsmasqOptionsOptionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) NetworkDnsmasqOptionsOption {
		return vs[0].([]NetworkDnsmasqOptionsOption)[vs[1].(int)]
	}).(NetworkDnsmasqOptionsOptionOutput)
}

type NetworkRoute struct {
	Cidr    string `pulumi:"cidr"`
	Gateway string `pulumi:"gateway"`
}

// NetworkRouteInput is an input type that accepts NetworkRouteArgs and NetworkRouteOutput values.
// You can construct a concrete instance of `NetworkRouteInput` via:
//
//	NetworkRouteArgs{...}
type NetworkRouteInput interface {
	pulumi.Input

	ToNetworkRouteOutput() NetworkRouteOutput
	ToNetworkRouteOutputWithContext(context.Context) NetworkRouteOutput
}

type NetworkRouteArgs struct {
	Cidr    pulumi.StringInput `pulumi:"cidr"`
	Gateway pulumi.StringInput `pulumi:"gateway"`
}

func (NetworkRouteArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*NetworkRoute)(nil)).Elem()
}

func (i NetworkRouteArgs) ToNetworkRouteOutput() NetworkRouteOutput {
	return i.ToNetworkRouteOutputWithContext(context.Background())
}

func (i NetworkRouteArgs) ToNetworkRouteOutputWithContext(ctx context.Context) NetworkRouteOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NetworkRouteOutput)
}

// NetworkRouteArrayInput is an input type that accepts NetworkRouteArray and NetworkRouteArrayOutput values.
// You can construct a concrete instance of `NetworkRouteArrayInput` via:
//
//	NetworkRouteArray{ NetworkRouteArgs{...} }
type NetworkRouteArrayInput interface {
	pulumi.Input

	ToNetworkRouteArrayOutput() NetworkRouteArrayOutput
	ToNetworkRouteArrayOutputWithContext(context.Context) NetworkRouteArrayOutput
}

type NetworkRouteArray []NetworkRouteInput

func (NetworkRouteArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]NetworkRoute)(nil)).Elem()
}

func (i NetworkRouteArray) ToNetworkRouteArrayOutput() NetworkRouteArrayOutput {
	return i.ToNetworkRouteArrayOutputWithContext(context.Background())
}

func (i NetworkRouteArray) ToNetworkRouteArrayOutputWithContext(ctx context.Context) NetworkRouteArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NetworkRouteArrayOutput)
}

type NetworkRouteOutput struct{ *pulumi.OutputState }

func (NetworkRouteOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*NetworkRoute)(nil)).Elem()
}

func (o NetworkRouteOutput) ToNetworkRouteOutput() NetworkRouteOutput {
	return o
}

func (o NetworkRouteOutput) ToNetworkRouteOutputWithContext(ctx context.Context) NetworkRouteOutput {
	return o
}

func (o NetworkRouteOutput) Cidr() pulumi.StringOutput {
	return o.ApplyT(func(v NetworkRoute) string { return v.Cidr }).(pulumi.StringOutput)
}

func (o NetworkRouteOutput) Gateway() pulumi.StringOutput {
	return o.ApplyT(func(v NetworkRoute) string { return v.Gateway }).(pulumi.StringOutput)
}

type NetworkRouteArrayOutput struct{ *pulumi.OutputState }

func (NetworkRouteArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]NetworkRoute)(nil)).Elem()
}

func (o NetworkRouteArrayOutput) ToNetworkRouteArrayOutput() NetworkRouteArrayOutput {
	return o
}

func (o NetworkRouteArrayOutput) ToNetworkRouteArrayOutputWithContext(ctx context.Context) NetworkRouteArrayOutput {
	return o
}

func (o NetworkRouteArrayOutput) Index(i pulumi.IntInput) NetworkRouteOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) NetworkRoute {
		return vs[0].([]NetworkRoute)[vs[1].(int)]
	}).(NetworkRouteOutput)
}

type NetworkXml struct {
	Xslt *string `pulumi:"xslt"`
}

// NetworkXmlInput is an input type that accepts NetworkXmlArgs and NetworkXmlOutput values.
// You can construct a concrete instance of `NetworkXmlInput` via:
//
//	NetworkXmlArgs{...}
type NetworkXmlInput interface {
	pulumi.Input

	ToNetworkXmlOutput() NetworkXmlOutput
	ToNetworkXmlOutputWithContext(context.Context) NetworkXmlOutput
}

type NetworkXmlArgs struct {
	Xslt pulumi.StringPtrInput `pulumi:"xslt"`
}

func (NetworkXmlArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*NetworkXml)(nil)).Elem()
}

func (i NetworkXmlArgs) ToNetworkXmlOutput() NetworkXmlOutput {
	return i.ToNetworkXmlOutputWithContext(context.Background())
}

func (i NetworkXmlArgs) ToNetworkXmlOutputWithContext(ctx context.Context) NetworkXmlOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NetworkXmlOutput)
}

func (i NetworkXmlArgs) ToNetworkXmlPtrOutput() NetworkXmlPtrOutput {
	return i.ToNetworkXmlPtrOutputWithContext(context.Background())
}

func (i NetworkXmlArgs) ToNetworkXmlPtrOutputWithContext(ctx context.Context) NetworkXmlPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NetworkXmlOutput).ToNetworkXmlPtrOutputWithContext(ctx)
}

// NetworkXmlPtrInput is an input type that accepts NetworkXmlArgs, NetworkXmlPtr and NetworkXmlPtrOutput values.
// You can construct a concrete instance of `NetworkXmlPtrInput` via:
//
//	        NetworkXmlArgs{...}
//
//	or:
//
//	        nil
type NetworkXmlPtrInput interface {
	pulumi.Input

	ToNetworkXmlPtrOutput() NetworkXmlPtrOutput
	ToNetworkXmlPtrOutputWithContext(context.Context) NetworkXmlPtrOutput
}

type networkXmlPtrType NetworkXmlArgs

func NetworkXmlPtr(v *NetworkXmlArgs) NetworkXmlPtrInput {
	return (*networkXmlPtrType)(v)
}

func (*networkXmlPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**NetworkXml)(nil)).Elem()
}

func (i *networkXmlPtrType) ToNetworkXmlPtrOutput() NetworkXmlPtrOutput {
	return i.ToNetworkXmlPtrOutputWithContext(context.Background())
}

func (i *networkXmlPtrType) ToNetworkXmlPtrOutputWithContext(ctx context.Context) NetworkXmlPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NetworkXmlPtrOutput)
}

type NetworkXmlOutput struct{ *pulumi.OutputState }

func (NetworkXmlOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*NetworkXml)(nil)).Elem()
}

func (o NetworkXmlOutput) ToNetworkXmlOutput() NetworkXmlOutput {
	return o
}

func (o NetworkXmlOutput) ToNetworkXmlOutputWithContext(ctx context.Context) NetworkXmlOutput {
	return o
}

func (o NetworkXmlOutput) ToNetworkXmlPtrOutput() NetworkXmlPtrOutput {
	return o.ToNetworkXmlPtrOutputWithContext(context.Background())
}

func (o NetworkXmlOutput) ToNetworkXmlPtrOutputWithContext(ctx context.Context) NetworkXmlPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v NetworkXml) *NetworkXml {
		return &v
	}).(NetworkXmlPtrOutput)
}

func (o NetworkXmlOutput) Xslt() pulumi.StringPtrOutput {
	return o.ApplyT(func(v NetworkXml) *string { return v.Xslt }).(pulumi.StringPtrOutput)
}

type NetworkXmlPtrOutput struct{ *pulumi.OutputState }

func (NetworkXmlPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**NetworkXml)(nil)).Elem()
}

func (o NetworkXmlPtrOutput) ToNetworkXmlPtrOutput() NetworkXmlPtrOutput {
	return o
}

func (o NetworkXmlPtrOutput) ToNetworkXmlPtrOutputWithContext(ctx context.Context) NetworkXmlPtrOutput {
	return o
}

func (o NetworkXmlPtrOutput) Elem() NetworkXmlOutput {
	return o.ApplyT(func(v *NetworkXml) NetworkXml {
		if v != nil {
			return *v
		}
		var ret NetworkXml
		return ret
	}).(NetworkXmlOutput)
}

func (o NetworkXmlPtrOutput) Xslt() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *NetworkXml) *string {
		if v == nil {
			return nil
		}
		return v.Xslt
	}).(pulumi.StringPtrOutput)
}

type PoolXml struct {
	Xslt *string `pulumi:"xslt"`
}

// PoolXmlInput is an input type that accepts PoolXmlArgs and PoolXmlOutput values.
// You can construct a concrete instance of `PoolXmlInput` via:
//
//	PoolXmlArgs{...}
type PoolXmlInput interface {
	pulumi.Input

	ToPoolXmlOutput() PoolXmlOutput
	ToPoolXmlOutputWithContext(context.Context) PoolXmlOutput
}

type PoolXmlArgs struct {
	Xslt pulumi.StringPtrInput `pulumi:"xslt"`
}

func (PoolXmlArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*PoolXml)(nil)).Elem()
}

func (i PoolXmlArgs) ToPoolXmlOutput() PoolXmlOutput {
	return i.ToPoolXmlOutputWithContext(context.Background())
}

func (i PoolXmlArgs) ToPoolXmlOutputWithContext(ctx context.Context) PoolXmlOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PoolXmlOutput)
}

func (i PoolXmlArgs) ToPoolXmlPtrOutput() PoolXmlPtrOutput {
	return i.ToPoolXmlPtrOutputWithContext(context.Background())
}

func (i PoolXmlArgs) ToPoolXmlPtrOutputWithContext(ctx context.Context) PoolXmlPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PoolXmlOutput).ToPoolXmlPtrOutputWithContext(ctx)
}

// PoolXmlPtrInput is an input type that accepts PoolXmlArgs, PoolXmlPtr and PoolXmlPtrOutput values.
// You can construct a concrete instance of `PoolXmlPtrInput` via:
//
//	        PoolXmlArgs{...}
//
//	or:
//
//	        nil
type PoolXmlPtrInput interface {
	pulumi.Input

	ToPoolXmlPtrOutput() PoolXmlPtrOutput
	ToPoolXmlPtrOutputWithContext(context.Context) PoolXmlPtrOutput
}

type poolXmlPtrType PoolXmlArgs

func PoolXmlPtr(v *PoolXmlArgs) PoolXmlPtrInput {
	return (*poolXmlPtrType)(v)
}

func (*poolXmlPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**PoolXml)(nil)).Elem()
}

func (i *poolXmlPtrType) ToPoolXmlPtrOutput() PoolXmlPtrOutput {
	return i.ToPoolXmlPtrOutputWithContext(context.Background())
}

func (i *poolXmlPtrType) ToPoolXmlPtrOutputWithContext(ctx context.Context) PoolXmlPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PoolXmlPtrOutput)
}

type PoolXmlOutput struct{ *pulumi.OutputState }

func (PoolXmlOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PoolXml)(nil)).Elem()
}

func (o PoolXmlOutput) ToPoolXmlOutput() PoolXmlOutput {
	return o
}

func (o PoolXmlOutput) ToPoolXmlOutputWithContext(ctx context.Context) PoolXmlOutput {
	return o
}

func (o PoolXmlOutput) ToPoolXmlPtrOutput() PoolXmlPtrOutput {
	return o.ToPoolXmlPtrOutputWithContext(context.Background())
}

func (o PoolXmlOutput) ToPoolXmlPtrOutputWithContext(ctx context.Context) PoolXmlPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v PoolXml) *PoolXml {
		return &v
	}).(PoolXmlPtrOutput)
}

func (o PoolXmlOutput) Xslt() pulumi.StringPtrOutput {
	return o.ApplyT(func(v PoolXml) *string { return v.Xslt }).(pulumi.StringPtrOutput)
}

type PoolXmlPtrOutput struct{ *pulumi.OutputState }

func (PoolXmlPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**PoolXml)(nil)).Elem()
}

func (o PoolXmlPtrOutput) ToPoolXmlPtrOutput() PoolXmlPtrOutput {
	return o
}

func (o PoolXmlPtrOutput) ToPoolXmlPtrOutputWithContext(ctx context.Context) PoolXmlPtrOutput {
	return o
}

func (o PoolXmlPtrOutput) Elem() PoolXmlOutput {
	return o.ApplyT(func(v *PoolXml) PoolXml {
		if v != nil {
			return *v
		}
		var ret PoolXml
		return ret
	}).(PoolXmlOutput)
}

func (o PoolXmlPtrOutput) Xslt() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PoolXml) *string {
		if v == nil {
			return nil
		}
		return v.Xslt
	}).(pulumi.StringPtrOutput)
}

type VolumeXml struct {
	Xslt *string `pulumi:"xslt"`
}

// VolumeXmlInput is an input type that accepts VolumeXmlArgs and VolumeXmlOutput values.
// You can construct a concrete instance of `VolumeXmlInput` via:
//
//	VolumeXmlArgs{...}
type VolumeXmlInput interface {
	pulumi.Input

	ToVolumeXmlOutput() VolumeXmlOutput
	ToVolumeXmlOutputWithContext(context.Context) VolumeXmlOutput
}

type VolumeXmlArgs struct {
	Xslt pulumi.StringPtrInput `pulumi:"xslt"`
}

func (VolumeXmlArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*VolumeXml)(nil)).Elem()
}

func (i VolumeXmlArgs) ToVolumeXmlOutput() VolumeXmlOutput {
	return i.ToVolumeXmlOutputWithContext(context.Background())
}

func (i VolumeXmlArgs) ToVolumeXmlOutputWithContext(ctx context.Context) VolumeXmlOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VolumeXmlOutput)
}

func (i VolumeXmlArgs) ToVolumeXmlPtrOutput() VolumeXmlPtrOutput {
	return i.ToVolumeXmlPtrOutputWithContext(context.Background())
}

func (i VolumeXmlArgs) ToVolumeXmlPtrOutputWithContext(ctx context.Context) VolumeXmlPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VolumeXmlOutput).ToVolumeXmlPtrOutputWithContext(ctx)
}

// VolumeXmlPtrInput is an input type that accepts VolumeXmlArgs, VolumeXmlPtr and VolumeXmlPtrOutput values.
// You can construct a concrete instance of `VolumeXmlPtrInput` via:
//
//	        VolumeXmlArgs{...}
//
//	or:
//
//	        nil
type VolumeXmlPtrInput interface {
	pulumi.Input

	ToVolumeXmlPtrOutput() VolumeXmlPtrOutput
	ToVolumeXmlPtrOutputWithContext(context.Context) VolumeXmlPtrOutput
}

type volumeXmlPtrType VolumeXmlArgs

func VolumeXmlPtr(v *VolumeXmlArgs) VolumeXmlPtrInput {
	return (*volumeXmlPtrType)(v)
}

func (*volumeXmlPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**VolumeXml)(nil)).Elem()
}

func (i *volumeXmlPtrType) ToVolumeXmlPtrOutput() VolumeXmlPtrOutput {
	return i.ToVolumeXmlPtrOutputWithContext(context.Background())
}

func (i *volumeXmlPtrType) ToVolumeXmlPtrOutputWithContext(ctx context.Context) VolumeXmlPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VolumeXmlPtrOutput)
}

type VolumeXmlOutput struct{ *pulumi.OutputState }

func (VolumeXmlOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*VolumeXml)(nil)).Elem()
}

func (o VolumeXmlOutput) ToVolumeXmlOutput() VolumeXmlOutput {
	return o
}

func (o VolumeXmlOutput) ToVolumeXmlOutputWithContext(ctx context.Context) VolumeXmlOutput {
	return o
}

func (o VolumeXmlOutput) ToVolumeXmlPtrOutput() VolumeXmlPtrOutput {
	return o.ToVolumeXmlPtrOutputWithContext(context.Background())
}

func (o VolumeXmlOutput) ToVolumeXmlPtrOutputWithContext(ctx context.Context) VolumeXmlPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v VolumeXml) *VolumeXml {
		return &v
	}).(VolumeXmlPtrOutput)
}

func (o VolumeXmlOutput) Xslt() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VolumeXml) *string { return v.Xslt }).(pulumi.StringPtrOutput)
}

type VolumeXmlPtrOutput struct{ *pulumi.OutputState }

func (VolumeXmlPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**VolumeXml)(nil)).Elem()
}

func (o VolumeXmlPtrOutput) ToVolumeXmlPtrOutput() VolumeXmlPtrOutput {
	return o
}

func (o VolumeXmlPtrOutput) ToVolumeXmlPtrOutputWithContext(ctx context.Context) VolumeXmlPtrOutput {
	return o
}

func (o VolumeXmlPtrOutput) Elem() VolumeXmlOutput {
	return o.ApplyT(func(v *VolumeXml) VolumeXml {
		if v != nil {
			return *v
		}
		var ret VolumeXml
		return ret
	}).(VolumeXmlOutput)
}

func (o VolumeXmlPtrOutput) Xslt() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *VolumeXml) *string {
		if v == nil {
			return nil
		}
		return v.Xslt
	}).(pulumi.StringPtrOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*DomainBootDeviceInput)(nil)).Elem(), DomainBootDeviceArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DomainBootDeviceArrayInput)(nil)).Elem(), DomainBootDeviceArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*DomainConsoleInput)(nil)).Elem(), DomainConsoleArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DomainConsoleArrayInput)(nil)).Elem(), DomainConsoleArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*DomainCpuInput)(nil)).Elem(), DomainCpuArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DomainCpuPtrInput)(nil)).Elem(), DomainCpuArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DomainDiskInput)(nil)).Elem(), DomainDiskArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DomainDiskArrayInput)(nil)).Elem(), DomainDiskArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*DomainFilesystemInput)(nil)).Elem(), DomainFilesystemArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DomainFilesystemArrayInput)(nil)).Elem(), DomainFilesystemArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*DomainGraphicsInput)(nil)).Elem(), DomainGraphicsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DomainGraphicsPtrInput)(nil)).Elem(), DomainGraphicsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DomainNetworkInterfaceInput)(nil)).Elem(), DomainNetworkInterfaceArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DomainNetworkInterfaceArrayInput)(nil)).Elem(), DomainNetworkInterfaceArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*DomainNvramInput)(nil)).Elem(), DomainNvramArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DomainNvramPtrInput)(nil)).Elem(), DomainNvramArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DomainTpmInput)(nil)).Elem(), DomainTpmArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DomainTpmPtrInput)(nil)).Elem(), DomainTpmArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DomainVideoInput)(nil)).Elem(), DomainVideoArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DomainVideoPtrInput)(nil)).Elem(), DomainVideoArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DomainXmlInput)(nil)).Elem(), DomainXmlArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DomainXmlPtrInput)(nil)).Elem(), DomainXmlArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*NetworkDhcpInput)(nil)).Elem(), NetworkDhcpArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*NetworkDhcpPtrInput)(nil)).Elem(), NetworkDhcpArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*NetworkDnsInput)(nil)).Elem(), NetworkDnsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*NetworkDnsPtrInput)(nil)).Elem(), NetworkDnsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*NetworkDnsForwarderInput)(nil)).Elem(), NetworkDnsForwarderArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*NetworkDnsForwarderArrayInput)(nil)).Elem(), NetworkDnsForwarderArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*NetworkDnsHostInput)(nil)).Elem(), NetworkDnsHostArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*NetworkDnsHostArrayInput)(nil)).Elem(), NetworkDnsHostArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*NetworkDnsSrvInput)(nil)).Elem(), NetworkDnsSrvArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*NetworkDnsSrvArrayInput)(nil)).Elem(), NetworkDnsSrvArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*NetworkDnsmasqOptionsInput)(nil)).Elem(), NetworkDnsmasqOptionsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*NetworkDnsmasqOptionsPtrInput)(nil)).Elem(), NetworkDnsmasqOptionsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*NetworkDnsmasqOptionsOptionInput)(nil)).Elem(), NetworkDnsmasqOptionsOptionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*NetworkDnsmasqOptionsOptionArrayInput)(nil)).Elem(), NetworkDnsmasqOptionsOptionArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*NetworkRouteInput)(nil)).Elem(), NetworkRouteArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*NetworkRouteArrayInput)(nil)).Elem(), NetworkRouteArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*NetworkXmlInput)(nil)).Elem(), NetworkXmlArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*NetworkXmlPtrInput)(nil)).Elem(), NetworkXmlArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*PoolXmlInput)(nil)).Elem(), PoolXmlArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*PoolXmlPtrInput)(nil)).Elem(), PoolXmlArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*VolumeXmlInput)(nil)).Elem(), VolumeXmlArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*VolumeXmlPtrInput)(nil)).Elem(), VolumeXmlArgs{})
	pulumi.RegisterOutputType(DomainBootDeviceOutput{})
	pulumi.RegisterOutputType(DomainBootDeviceArrayOutput{})
	pulumi.RegisterOutputType(DomainConsoleOutput{})
	pulumi.RegisterOutputType(DomainConsoleArrayOutput{})
	pulumi.RegisterOutputType(DomainCpuOutput{})
	pulumi.RegisterOutputType(DomainCpuPtrOutput{})
	pulumi.RegisterOutputType(DomainDiskOutput{})
	pulumi.RegisterOutputType(DomainDiskArrayOutput{})
	pulumi.RegisterOutputType(DomainFilesystemOutput{})
	pulumi.RegisterOutputType(DomainFilesystemArrayOutput{})
	pulumi.RegisterOutputType(DomainGraphicsOutput{})
	pulumi.RegisterOutputType(DomainGraphicsPtrOutput{})
	pulumi.RegisterOutputType(DomainNetworkInterfaceOutput{})
	pulumi.RegisterOutputType(DomainNetworkInterfaceArrayOutput{})
	pulumi.RegisterOutputType(DomainNvramOutput{})
	pulumi.RegisterOutputType(DomainNvramPtrOutput{})
	pulumi.RegisterOutputType(DomainTpmOutput{})
	pulumi.RegisterOutputType(DomainTpmPtrOutput{})
	pulumi.RegisterOutputType(DomainVideoOutput{})
	pulumi.RegisterOutputType(DomainVideoPtrOutput{})
	pulumi.RegisterOutputType(DomainXmlOutput{})
	pulumi.RegisterOutputType(DomainXmlPtrOutput{})
	pulumi.RegisterOutputType(NetworkDhcpOutput{})
	pulumi.RegisterOutputType(NetworkDhcpPtrOutput{})
	pulumi.RegisterOutputType(NetworkDnsOutput{})
	pulumi.RegisterOutputType(NetworkDnsPtrOutput{})
	pulumi.RegisterOutputType(NetworkDnsForwarderOutput{})
	pulumi.RegisterOutputType(NetworkDnsForwarderArrayOutput{})
	pulumi.RegisterOutputType(NetworkDnsHostOutput{})
	pulumi.RegisterOutputType(NetworkDnsHostArrayOutput{})
	pulumi.RegisterOutputType(NetworkDnsSrvOutput{})
	pulumi.RegisterOutputType(NetworkDnsSrvArrayOutput{})
	pulumi.RegisterOutputType(NetworkDnsmasqOptionsOutput{})
	pulumi.RegisterOutputType(NetworkDnsmasqOptionsPtrOutput{})
	pulumi.RegisterOutputType(NetworkDnsmasqOptionsOptionOutput{})
	pulumi.RegisterOutputType(NetworkDnsmasqOptionsOptionArrayOutput{})
	pulumi.RegisterOutputType(NetworkRouteOutput{})
	pulumi.RegisterOutputType(NetworkRouteArrayOutput{})
	pulumi.RegisterOutputType(NetworkXmlOutput{})
	pulumi.RegisterOutputType(NetworkXmlPtrOutput{})
	pulumi.RegisterOutputType(PoolXmlOutput{})
	pulumi.RegisterOutputType(PoolXmlPtrOutput{})
	pulumi.RegisterOutputType(VolumeXmlOutput{})
	pulumi.RegisterOutputType(VolumeXmlPtrOutput{})
}
