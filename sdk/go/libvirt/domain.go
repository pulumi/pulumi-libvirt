// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package libvirt

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi-libvirt/sdk/go/libvirt/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumix"
)

// Manages a VM domain resource within libvirt. For more information see
// [the official documentation](https://libvirt.org/formatdomain.html).
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-libvirt/sdk/go/libvirt"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := libvirt.NewDomain(ctx, "default", nil)
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
type Domain struct {
	pulumi.CustomResourceState

	// The architecture for the VM (probably x8664 or i686),
	// you normally won't need to set this unless you are building a special VM
	Arch pulumi.StringOutput `pulumi:"arch"`
	// Set to `true` to start the domain on host boot up.
	// If not specified `false` is assumed.
	Autostart pulumi.BoolOutput `pulumi:"autostart"`
	// A list of devices (dev) which defines boot order. Example
	// below.
	BootDevices DomainBootDeviceArrayOutput `pulumi:"bootDevices"`
	// The `CloudInitDisk` disk that has to be used by
	// the domain. This is going to be attached as a CDROM ISO. Changing the
	// cloud-init won't cause the domain to be recreated, however the change will
	// have effect on the next reboot.
	Cloudinit pulumi.StringPtrOutput `pulumi:"cloudinit"`
	// Arguments to the kernel
	//
	// ```go
	// package main
	//
	// import (
	// 	"github.com/pulumi/pulumi-libvirt/sdk/go/libvirt"
	// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	// )
	//
	// func main() {
	// 	pulumi.Run(func(ctx *pulumi.Context) error {
	// 		_, err := libvirt.NewDomain(ctx, "domain-suse", &libvirt.DomainArgs{
	// 			Memory: pulumi.Int(1024),
	// 			Vcpu:   pulumi.Int(1),
	// 			Kernel: pulumi.Any(libvirt_volume.Kernel.Id),
	// 			Cmdlines: pulumi.AnyMapArray{
	// 				pulumi.AnyMap{
	// 					"arg1": pulumi.Any("value1"),
	// 					"arg2": pulumi.Any("value2"),
	// 					"_":    pulumi.Any("rw nosplash"),
	// 				},
	// 			},
	// 		})
	// 		if err != nil {
	// 			return err
	// 		}
	// 		return nil
	// 	})
	// }
	// ```
	//
	// Kernel params that don't have a keyword identifier can be specified using the
	// special `"_"` keyword. Multiple keyword-less params have to be specified using
	// the same `"_"` keyword, like in the example above.
	//
	// Also note that the `cmd` block is actually a list of maps, so it is possible to
	// declare several of them by using either the literal list and map syntax as in
	// the following examples:
	Cmdlines pulumi.MapArrayOutput    `pulumi:"cmdlines"`
	Consoles DomainConsoleArrayOutput `pulumi:"consoles"`
	// The
	// [Ignition](https://www.terraform.io/docs/providers/libvirt/r/coreos_ignition.html) resource
	// that is to be used by the CoreOS domain.
	CoreosIgnition pulumi.StringPtrOutput `pulumi:"coreosIgnition"`
	// Configures CPU mode. See below for more
	// details.
	Cpu DomainCpuOutput `pulumi:"cpu"`
	// The description for domain.
	// Changing this forces a new resource to be created.
	// This data is not used by libvirt in any way, it can contain any information the user wants.
	Description pulumi.StringPtrOutput `pulumi:"description"`
	// An array of one or more disks to attach to the domain. The
	// `disk` object structure is documented below.
	Disks DomainDiskArrayOutput `pulumi:"disks"`
	// The path of the emulator to use
	Emulator pulumi.StringOutput `pulumi:"emulator"`
	// An array of one or more host filesystems to attach to
	// the domain. The `filesystem` object structure is documented
	// below.
	Filesystems DomainFilesystemArrayOutput `pulumi:"filesystems"`
	// The UEFI rom images for exercising UEFI secure boot in a qemu
	// environment. Users should usually specify one of the standard _Open Virtual Machine
	// Firmware_ (_OVMF_) images available for their distributions. The file will be opened
	// read-only.
	Firmware pulumi.StringPtrOutput `pulumi:"firmware"`
	// The name of the firmware config path where ignition file is stored: default is `opt/com.coreos/config`. If you are using [Flatcar Linux](https://docs.flatcar-linux.org/os/booting-with-libvirt/#creating-the-domain-xml), the value is `opt/org.flatcar-linux/config`.
	FwCfgName pulumi.StringPtrOutput  `pulumi:"fwCfgName"`
	Graphics  DomainGraphicsPtrOutput `pulumi:"graphics"`
	// The path of the initrd to boot.
	//
	// You can use it in the same way as the kernel.
	Initrd pulumi.StringPtrOutput `pulumi:"initrd"`
	// The path of the kernel to boot
	//
	// If you are using a qcow2 volume, you can pass the id of the volume (eg. `${libvirt_volume.kernel.id}`)
	// as they are local to the hypervisor.
	//
	// Given that you can define a volume from a remote http file, this means, you can also have remote kernels.
	//
	// ```go
	// package main
	//
	// import (
	// 	"github.com/pulumi/pulumi-libvirt/sdk/go/libvirt"
	// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	// )
	//
	// func main() {
	// 	pulumi.Run(func(ctx *pulumi.Context) error {
	// 		kernel, err := libvirt.NewVolume(ctx, "kernel", &libvirt.VolumeArgs{
	// 			Source: pulumi.String("http://download.opensuse.org/tumbleweed/repo/oss/boot/x86_64/loader/linux"),
	// 			Pool:   pulumi.String("default"),
	// 			Format: pulumi.String("raw"),
	// 		})
	// 		if err != nil {
	// 			return err
	// 		}
	// 		_, err = libvirt.NewDomain(ctx, "domain-suse", &libvirt.DomainArgs{
	// 			Memory: pulumi.Int(1024),
	// 			Vcpu:   pulumi.Int(1),
	// 			Kernel: kernel.ID(),
	// 		})
	// 		if err != nil {
	// 			return err
	// 		}
	// 		return nil
	// 	})
	// }
	// ```
	Kernel pulumi.StringPtrOutput `pulumi:"kernel"`
	// The machine type,
	// you normally won't need to set this unless you are running on a platform that
	// defaults to the wrong machine type for your template
	Machine pulumi.StringOutput `pulumi:"machine"`
	// The amount of memory in MiB. If not specified the domain
	// will be created with 512 MiB of memory be used.
	Memory   pulumi.IntPtrOutput    `pulumi:"memory"`
	Metadata pulumi.StringPtrOutput `pulumi:"metadata"`
	// A unique name for the resource, required by libvirt.
	// Changing this forces a new resource to be created.
	Name pulumi.StringOutput `pulumi:"name"`
	// An array of one or more network interfaces to
	// attach to the domain. The `networkInterface` object structure is documented
	// below.
	NetworkInterfaces DomainNetworkInterfaceArrayOutput `pulumi:"networkInterfaces"`
	// this block allows specifying the following attributes related to the _nvram_:
	Nvram DomainNvramPtrOutput `pulumi:"nvram"`
	// By default is disabled, set to true for enabling it. More info [qemu-agent](https://wiki.libvirt.org/page/Qemu_guest_agent).
	QemuAgent pulumi.BoolPtrOutput `pulumi:"qemuAgent"`
	// Use `false` to turn off the instance. If not specified,
	// true is assumed and the instance, if stopped, will be started at next apply.
	Running pulumi.BoolPtrOutput `pulumi:"running"`
	// TPM device to attach to the domain. The `tpm` object structure is documented below.
	Tpm DomainTpmPtrOutput `pulumi:"tpm"`
	// The amount of virtual CPUs. If not specified, a single CPU
	// will be created.
	Vcpu  pulumi.IntPtrOutput  `pulumi:"vcpu"`
	Video DomainVideoPtrOutput `pulumi:"video"`
	Xml   DomainXmlPtrOutput   `pulumi:"xml"`
}

// NewDomain registers a new resource with the given unique name, arguments, and options.
func NewDomain(ctx *pulumi.Context,
	name string, args *DomainArgs, opts ...pulumi.ResourceOption) (*Domain, error) {
	if args == nil {
		args = &DomainArgs{}
	}

	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Domain
	err := ctx.RegisterResource("libvirt:index/domain:Domain", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetDomain gets an existing Domain resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetDomain(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *DomainState, opts ...pulumi.ResourceOption) (*Domain, error) {
	var resource Domain
	err := ctx.ReadResource("libvirt:index/domain:Domain", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Domain resources.
type domainState struct {
	// The architecture for the VM (probably x8664 or i686),
	// you normally won't need to set this unless you are building a special VM
	Arch *string `pulumi:"arch"`
	// Set to `true` to start the domain on host boot up.
	// If not specified `false` is assumed.
	Autostart *bool `pulumi:"autostart"`
	// A list of devices (dev) which defines boot order. Example
	// below.
	BootDevices []DomainBootDevice `pulumi:"bootDevices"`
	// The `CloudInitDisk` disk that has to be used by
	// the domain. This is going to be attached as a CDROM ISO. Changing the
	// cloud-init won't cause the domain to be recreated, however the change will
	// have effect on the next reboot.
	Cloudinit *string `pulumi:"cloudinit"`
	// Arguments to the kernel
	//
	// ```go
	// package main
	//
	// import (
	// 	"github.com/pulumi/pulumi-libvirt/sdk/go/libvirt"
	// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	// )
	//
	// func main() {
	// 	pulumi.Run(func(ctx *pulumi.Context) error {
	// 		_, err := libvirt.NewDomain(ctx, "domain-suse", &libvirt.DomainArgs{
	// 			Memory: pulumi.Int(1024),
	// 			Vcpu:   pulumi.Int(1),
	// 			Kernel: pulumi.Any(libvirt_volume.Kernel.Id),
	// 			Cmdlines: pulumi.AnyMapArray{
	// 				pulumi.AnyMap{
	// 					"arg1": pulumi.Any("value1"),
	// 					"arg2": pulumi.Any("value2"),
	// 					"_":    pulumi.Any("rw nosplash"),
	// 				},
	// 			},
	// 		})
	// 		if err != nil {
	// 			return err
	// 		}
	// 		return nil
	// 	})
	// }
	// ```
	//
	// Kernel params that don't have a keyword identifier can be specified using the
	// special `"_"` keyword. Multiple keyword-less params have to be specified using
	// the same `"_"` keyword, like in the example above.
	//
	// Also note that the `cmd` block is actually a list of maps, so it is possible to
	// declare several of them by using either the literal list and map syntax as in
	// the following examples:
	Cmdlines []map[string]interface{} `pulumi:"cmdlines"`
	Consoles []DomainConsole          `pulumi:"consoles"`
	// The
	// [Ignition](https://www.terraform.io/docs/providers/libvirt/r/coreos_ignition.html) resource
	// that is to be used by the CoreOS domain.
	CoreosIgnition *string `pulumi:"coreosIgnition"`
	// Configures CPU mode. See below for more
	// details.
	Cpu *DomainCpu `pulumi:"cpu"`
	// The description for domain.
	// Changing this forces a new resource to be created.
	// This data is not used by libvirt in any way, it can contain any information the user wants.
	Description *string `pulumi:"description"`
	// An array of one or more disks to attach to the domain. The
	// `disk` object structure is documented below.
	Disks []DomainDisk `pulumi:"disks"`
	// The path of the emulator to use
	Emulator *string `pulumi:"emulator"`
	// An array of one or more host filesystems to attach to
	// the domain. The `filesystem` object structure is documented
	// below.
	Filesystems []DomainFilesystem `pulumi:"filesystems"`
	// The UEFI rom images for exercising UEFI secure boot in a qemu
	// environment. Users should usually specify one of the standard _Open Virtual Machine
	// Firmware_ (_OVMF_) images available for their distributions. The file will be opened
	// read-only.
	Firmware *string `pulumi:"firmware"`
	// The name of the firmware config path where ignition file is stored: default is `opt/com.coreos/config`. If you are using [Flatcar Linux](https://docs.flatcar-linux.org/os/booting-with-libvirt/#creating-the-domain-xml), the value is `opt/org.flatcar-linux/config`.
	FwCfgName *string         `pulumi:"fwCfgName"`
	Graphics  *DomainGraphics `pulumi:"graphics"`
	// The path of the initrd to boot.
	//
	// You can use it in the same way as the kernel.
	Initrd *string `pulumi:"initrd"`
	// The path of the kernel to boot
	//
	// If you are using a qcow2 volume, you can pass the id of the volume (eg. `${libvirt_volume.kernel.id}`)
	// as they are local to the hypervisor.
	//
	// Given that you can define a volume from a remote http file, this means, you can also have remote kernels.
	//
	// ```go
	// package main
	//
	// import (
	// 	"github.com/pulumi/pulumi-libvirt/sdk/go/libvirt"
	// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	// )
	//
	// func main() {
	// 	pulumi.Run(func(ctx *pulumi.Context) error {
	// 		kernel, err := libvirt.NewVolume(ctx, "kernel", &libvirt.VolumeArgs{
	// 			Source: pulumi.String("http://download.opensuse.org/tumbleweed/repo/oss/boot/x86_64/loader/linux"),
	// 			Pool:   pulumi.String("default"),
	// 			Format: pulumi.String("raw"),
	// 		})
	// 		if err != nil {
	// 			return err
	// 		}
	// 		_, err = libvirt.NewDomain(ctx, "domain-suse", &libvirt.DomainArgs{
	// 			Memory: pulumi.Int(1024),
	// 			Vcpu:   pulumi.Int(1),
	// 			Kernel: kernel.ID(),
	// 		})
	// 		if err != nil {
	// 			return err
	// 		}
	// 		return nil
	// 	})
	// }
	// ```
	Kernel *string `pulumi:"kernel"`
	// The machine type,
	// you normally won't need to set this unless you are running on a platform that
	// defaults to the wrong machine type for your template
	Machine *string `pulumi:"machine"`
	// The amount of memory in MiB. If not specified the domain
	// will be created with 512 MiB of memory be used.
	Memory   *int    `pulumi:"memory"`
	Metadata *string `pulumi:"metadata"`
	// A unique name for the resource, required by libvirt.
	// Changing this forces a new resource to be created.
	Name *string `pulumi:"name"`
	// An array of one or more network interfaces to
	// attach to the domain. The `networkInterface` object structure is documented
	// below.
	NetworkInterfaces []DomainNetworkInterface `pulumi:"networkInterfaces"`
	// this block allows specifying the following attributes related to the _nvram_:
	Nvram *DomainNvram `pulumi:"nvram"`
	// By default is disabled, set to true for enabling it. More info [qemu-agent](https://wiki.libvirt.org/page/Qemu_guest_agent).
	QemuAgent *bool `pulumi:"qemuAgent"`
	// Use `false` to turn off the instance. If not specified,
	// true is assumed and the instance, if stopped, will be started at next apply.
	Running *bool `pulumi:"running"`
	// TPM device to attach to the domain. The `tpm` object structure is documented below.
	Tpm *DomainTpm `pulumi:"tpm"`
	// The amount of virtual CPUs. If not specified, a single CPU
	// will be created.
	Vcpu  *int         `pulumi:"vcpu"`
	Video *DomainVideo `pulumi:"video"`
	Xml   *DomainXml   `pulumi:"xml"`
}

type DomainState struct {
	// The architecture for the VM (probably x8664 or i686),
	// you normally won't need to set this unless you are building a special VM
	Arch pulumi.StringPtrInput
	// Set to `true` to start the domain on host boot up.
	// If not specified `false` is assumed.
	Autostart pulumi.BoolPtrInput
	// A list of devices (dev) which defines boot order. Example
	// below.
	BootDevices DomainBootDeviceArrayInput
	// The `CloudInitDisk` disk that has to be used by
	// the domain. This is going to be attached as a CDROM ISO. Changing the
	// cloud-init won't cause the domain to be recreated, however the change will
	// have effect on the next reboot.
	Cloudinit pulumi.StringPtrInput
	// Arguments to the kernel
	//
	// ```go
	// package main
	//
	// import (
	// 	"github.com/pulumi/pulumi-libvirt/sdk/go/libvirt"
	// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	// )
	//
	// func main() {
	// 	pulumi.Run(func(ctx *pulumi.Context) error {
	// 		_, err := libvirt.NewDomain(ctx, "domain-suse", &libvirt.DomainArgs{
	// 			Memory: pulumi.Int(1024),
	// 			Vcpu:   pulumi.Int(1),
	// 			Kernel: pulumi.Any(libvirt_volume.Kernel.Id),
	// 			Cmdlines: pulumi.AnyMapArray{
	// 				pulumi.AnyMap{
	// 					"arg1": pulumi.Any("value1"),
	// 					"arg2": pulumi.Any("value2"),
	// 					"_":    pulumi.Any("rw nosplash"),
	// 				},
	// 			},
	// 		})
	// 		if err != nil {
	// 			return err
	// 		}
	// 		return nil
	// 	})
	// }
	// ```
	//
	// Kernel params that don't have a keyword identifier can be specified using the
	// special `"_"` keyword. Multiple keyword-less params have to be specified using
	// the same `"_"` keyword, like in the example above.
	//
	// Also note that the `cmd` block is actually a list of maps, so it is possible to
	// declare several of them by using either the literal list and map syntax as in
	// the following examples:
	Cmdlines pulumi.MapArrayInput
	Consoles DomainConsoleArrayInput
	// The
	// [Ignition](https://www.terraform.io/docs/providers/libvirt/r/coreos_ignition.html) resource
	// that is to be used by the CoreOS domain.
	CoreosIgnition pulumi.StringPtrInput
	// Configures CPU mode. See below for more
	// details.
	Cpu DomainCpuPtrInput
	// The description for domain.
	// Changing this forces a new resource to be created.
	// This data is not used by libvirt in any way, it can contain any information the user wants.
	Description pulumi.StringPtrInput
	// An array of one or more disks to attach to the domain. The
	// `disk` object structure is documented below.
	Disks DomainDiskArrayInput
	// The path of the emulator to use
	Emulator pulumi.StringPtrInput
	// An array of one or more host filesystems to attach to
	// the domain. The `filesystem` object structure is documented
	// below.
	Filesystems DomainFilesystemArrayInput
	// The UEFI rom images for exercising UEFI secure boot in a qemu
	// environment. Users should usually specify one of the standard _Open Virtual Machine
	// Firmware_ (_OVMF_) images available for their distributions. The file will be opened
	// read-only.
	Firmware pulumi.StringPtrInput
	// The name of the firmware config path where ignition file is stored: default is `opt/com.coreos/config`. If you are using [Flatcar Linux](https://docs.flatcar-linux.org/os/booting-with-libvirt/#creating-the-domain-xml), the value is `opt/org.flatcar-linux/config`.
	FwCfgName pulumi.StringPtrInput
	Graphics  DomainGraphicsPtrInput
	// The path of the initrd to boot.
	//
	// You can use it in the same way as the kernel.
	Initrd pulumi.StringPtrInput
	// The path of the kernel to boot
	//
	// If you are using a qcow2 volume, you can pass the id of the volume (eg. `${libvirt_volume.kernel.id}`)
	// as they are local to the hypervisor.
	//
	// Given that you can define a volume from a remote http file, this means, you can also have remote kernels.
	//
	// ```go
	// package main
	//
	// import (
	// 	"github.com/pulumi/pulumi-libvirt/sdk/go/libvirt"
	// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	// )
	//
	// func main() {
	// 	pulumi.Run(func(ctx *pulumi.Context) error {
	// 		kernel, err := libvirt.NewVolume(ctx, "kernel", &libvirt.VolumeArgs{
	// 			Source: pulumi.String("http://download.opensuse.org/tumbleweed/repo/oss/boot/x86_64/loader/linux"),
	// 			Pool:   pulumi.String("default"),
	// 			Format: pulumi.String("raw"),
	// 		})
	// 		if err != nil {
	// 			return err
	// 		}
	// 		_, err = libvirt.NewDomain(ctx, "domain-suse", &libvirt.DomainArgs{
	// 			Memory: pulumi.Int(1024),
	// 			Vcpu:   pulumi.Int(1),
	// 			Kernel: kernel.ID(),
	// 		})
	// 		if err != nil {
	// 			return err
	// 		}
	// 		return nil
	// 	})
	// }
	// ```
	Kernel pulumi.StringPtrInput
	// The machine type,
	// you normally won't need to set this unless you are running on a platform that
	// defaults to the wrong machine type for your template
	Machine pulumi.StringPtrInput
	// The amount of memory in MiB. If not specified the domain
	// will be created with 512 MiB of memory be used.
	Memory   pulumi.IntPtrInput
	Metadata pulumi.StringPtrInput
	// A unique name for the resource, required by libvirt.
	// Changing this forces a new resource to be created.
	Name pulumi.StringPtrInput
	// An array of one or more network interfaces to
	// attach to the domain. The `networkInterface` object structure is documented
	// below.
	NetworkInterfaces DomainNetworkInterfaceArrayInput
	// this block allows specifying the following attributes related to the _nvram_:
	Nvram DomainNvramPtrInput
	// By default is disabled, set to true for enabling it. More info [qemu-agent](https://wiki.libvirt.org/page/Qemu_guest_agent).
	QemuAgent pulumi.BoolPtrInput
	// Use `false` to turn off the instance. If not specified,
	// true is assumed and the instance, if stopped, will be started at next apply.
	Running pulumi.BoolPtrInput
	// TPM device to attach to the domain. The `tpm` object structure is documented below.
	Tpm DomainTpmPtrInput
	// The amount of virtual CPUs. If not specified, a single CPU
	// will be created.
	Vcpu  pulumi.IntPtrInput
	Video DomainVideoPtrInput
	Xml   DomainXmlPtrInput
}

func (DomainState) ElementType() reflect.Type {
	return reflect.TypeOf((*domainState)(nil)).Elem()
}

type domainArgs struct {
	// The architecture for the VM (probably x8664 or i686),
	// you normally won't need to set this unless you are building a special VM
	Arch *string `pulumi:"arch"`
	// Set to `true` to start the domain on host boot up.
	// If not specified `false` is assumed.
	Autostart *bool `pulumi:"autostart"`
	// A list of devices (dev) which defines boot order. Example
	// below.
	BootDevices []DomainBootDevice `pulumi:"bootDevices"`
	// The `CloudInitDisk` disk that has to be used by
	// the domain. This is going to be attached as a CDROM ISO. Changing the
	// cloud-init won't cause the domain to be recreated, however the change will
	// have effect on the next reboot.
	Cloudinit *string `pulumi:"cloudinit"`
	// Arguments to the kernel
	//
	// ```go
	// package main
	//
	// import (
	// 	"github.com/pulumi/pulumi-libvirt/sdk/go/libvirt"
	// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	// )
	//
	// func main() {
	// 	pulumi.Run(func(ctx *pulumi.Context) error {
	// 		_, err := libvirt.NewDomain(ctx, "domain-suse", &libvirt.DomainArgs{
	// 			Memory: pulumi.Int(1024),
	// 			Vcpu:   pulumi.Int(1),
	// 			Kernel: pulumi.Any(libvirt_volume.Kernel.Id),
	// 			Cmdlines: pulumi.AnyMapArray{
	// 				pulumi.AnyMap{
	// 					"arg1": pulumi.Any("value1"),
	// 					"arg2": pulumi.Any("value2"),
	// 					"_":    pulumi.Any("rw nosplash"),
	// 				},
	// 			},
	// 		})
	// 		if err != nil {
	// 			return err
	// 		}
	// 		return nil
	// 	})
	// }
	// ```
	//
	// Kernel params that don't have a keyword identifier can be specified using the
	// special `"_"` keyword. Multiple keyword-less params have to be specified using
	// the same `"_"` keyword, like in the example above.
	//
	// Also note that the `cmd` block is actually a list of maps, so it is possible to
	// declare several of them by using either the literal list and map syntax as in
	// the following examples:
	Cmdlines []map[string]interface{} `pulumi:"cmdlines"`
	Consoles []DomainConsole          `pulumi:"consoles"`
	// The
	// [Ignition](https://www.terraform.io/docs/providers/libvirt/r/coreos_ignition.html) resource
	// that is to be used by the CoreOS domain.
	CoreosIgnition *string `pulumi:"coreosIgnition"`
	// Configures CPU mode. See below for more
	// details.
	Cpu *DomainCpu `pulumi:"cpu"`
	// The description for domain.
	// Changing this forces a new resource to be created.
	// This data is not used by libvirt in any way, it can contain any information the user wants.
	Description *string `pulumi:"description"`
	// An array of one or more disks to attach to the domain. The
	// `disk` object structure is documented below.
	Disks []DomainDisk `pulumi:"disks"`
	// The path of the emulator to use
	Emulator *string `pulumi:"emulator"`
	// An array of one or more host filesystems to attach to
	// the domain. The `filesystem` object structure is documented
	// below.
	Filesystems []DomainFilesystem `pulumi:"filesystems"`
	// The UEFI rom images for exercising UEFI secure boot in a qemu
	// environment. Users should usually specify one of the standard _Open Virtual Machine
	// Firmware_ (_OVMF_) images available for their distributions. The file will be opened
	// read-only.
	Firmware *string `pulumi:"firmware"`
	// The name of the firmware config path where ignition file is stored: default is `opt/com.coreos/config`. If you are using [Flatcar Linux](https://docs.flatcar-linux.org/os/booting-with-libvirt/#creating-the-domain-xml), the value is `opt/org.flatcar-linux/config`.
	FwCfgName *string         `pulumi:"fwCfgName"`
	Graphics  *DomainGraphics `pulumi:"graphics"`
	// The path of the initrd to boot.
	//
	// You can use it in the same way as the kernel.
	Initrd *string `pulumi:"initrd"`
	// The path of the kernel to boot
	//
	// If you are using a qcow2 volume, you can pass the id of the volume (eg. `${libvirt_volume.kernel.id}`)
	// as they are local to the hypervisor.
	//
	// Given that you can define a volume from a remote http file, this means, you can also have remote kernels.
	//
	// ```go
	// package main
	//
	// import (
	// 	"github.com/pulumi/pulumi-libvirt/sdk/go/libvirt"
	// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	// )
	//
	// func main() {
	// 	pulumi.Run(func(ctx *pulumi.Context) error {
	// 		kernel, err := libvirt.NewVolume(ctx, "kernel", &libvirt.VolumeArgs{
	// 			Source: pulumi.String("http://download.opensuse.org/tumbleweed/repo/oss/boot/x86_64/loader/linux"),
	// 			Pool:   pulumi.String("default"),
	// 			Format: pulumi.String("raw"),
	// 		})
	// 		if err != nil {
	// 			return err
	// 		}
	// 		_, err = libvirt.NewDomain(ctx, "domain-suse", &libvirt.DomainArgs{
	// 			Memory: pulumi.Int(1024),
	// 			Vcpu:   pulumi.Int(1),
	// 			Kernel: kernel.ID(),
	// 		})
	// 		if err != nil {
	// 			return err
	// 		}
	// 		return nil
	// 	})
	// }
	// ```
	Kernel *string `pulumi:"kernel"`
	// The machine type,
	// you normally won't need to set this unless you are running on a platform that
	// defaults to the wrong machine type for your template
	Machine *string `pulumi:"machine"`
	// The amount of memory in MiB. If not specified the domain
	// will be created with 512 MiB of memory be used.
	Memory   *int    `pulumi:"memory"`
	Metadata *string `pulumi:"metadata"`
	// A unique name for the resource, required by libvirt.
	// Changing this forces a new resource to be created.
	Name *string `pulumi:"name"`
	// An array of one or more network interfaces to
	// attach to the domain. The `networkInterface` object structure is documented
	// below.
	NetworkInterfaces []DomainNetworkInterface `pulumi:"networkInterfaces"`
	// this block allows specifying the following attributes related to the _nvram_:
	Nvram *DomainNvram `pulumi:"nvram"`
	// By default is disabled, set to true for enabling it. More info [qemu-agent](https://wiki.libvirt.org/page/Qemu_guest_agent).
	QemuAgent *bool `pulumi:"qemuAgent"`
	// Use `false` to turn off the instance. If not specified,
	// true is assumed and the instance, if stopped, will be started at next apply.
	Running *bool `pulumi:"running"`
	// TPM device to attach to the domain. The `tpm` object structure is documented below.
	Tpm *DomainTpm `pulumi:"tpm"`
	// The amount of virtual CPUs. If not specified, a single CPU
	// will be created.
	Vcpu  *int         `pulumi:"vcpu"`
	Video *DomainVideo `pulumi:"video"`
	Xml   *DomainXml   `pulumi:"xml"`
}

// The set of arguments for constructing a Domain resource.
type DomainArgs struct {
	// The architecture for the VM (probably x8664 or i686),
	// you normally won't need to set this unless you are building a special VM
	Arch pulumi.StringPtrInput
	// Set to `true` to start the domain on host boot up.
	// If not specified `false` is assumed.
	Autostart pulumi.BoolPtrInput
	// A list of devices (dev) which defines boot order. Example
	// below.
	BootDevices DomainBootDeviceArrayInput
	// The `CloudInitDisk` disk that has to be used by
	// the domain. This is going to be attached as a CDROM ISO. Changing the
	// cloud-init won't cause the domain to be recreated, however the change will
	// have effect on the next reboot.
	Cloudinit pulumi.StringPtrInput
	// Arguments to the kernel
	//
	// ```go
	// package main
	//
	// import (
	// 	"github.com/pulumi/pulumi-libvirt/sdk/go/libvirt"
	// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	// )
	//
	// func main() {
	// 	pulumi.Run(func(ctx *pulumi.Context) error {
	// 		_, err := libvirt.NewDomain(ctx, "domain-suse", &libvirt.DomainArgs{
	// 			Memory: pulumi.Int(1024),
	// 			Vcpu:   pulumi.Int(1),
	// 			Kernel: pulumi.Any(libvirt_volume.Kernel.Id),
	// 			Cmdlines: pulumi.AnyMapArray{
	// 				pulumi.AnyMap{
	// 					"arg1": pulumi.Any("value1"),
	// 					"arg2": pulumi.Any("value2"),
	// 					"_":    pulumi.Any("rw nosplash"),
	// 				},
	// 			},
	// 		})
	// 		if err != nil {
	// 			return err
	// 		}
	// 		return nil
	// 	})
	// }
	// ```
	//
	// Kernel params that don't have a keyword identifier can be specified using the
	// special `"_"` keyword. Multiple keyword-less params have to be specified using
	// the same `"_"` keyword, like in the example above.
	//
	// Also note that the `cmd` block is actually a list of maps, so it is possible to
	// declare several of them by using either the literal list and map syntax as in
	// the following examples:
	Cmdlines pulumi.MapArrayInput
	Consoles DomainConsoleArrayInput
	// The
	// [Ignition](https://www.terraform.io/docs/providers/libvirt/r/coreos_ignition.html) resource
	// that is to be used by the CoreOS domain.
	CoreosIgnition pulumi.StringPtrInput
	// Configures CPU mode. See below for more
	// details.
	Cpu DomainCpuPtrInput
	// The description for domain.
	// Changing this forces a new resource to be created.
	// This data is not used by libvirt in any way, it can contain any information the user wants.
	Description pulumi.StringPtrInput
	// An array of one or more disks to attach to the domain. The
	// `disk` object structure is documented below.
	Disks DomainDiskArrayInput
	// The path of the emulator to use
	Emulator pulumi.StringPtrInput
	// An array of one or more host filesystems to attach to
	// the domain. The `filesystem` object structure is documented
	// below.
	Filesystems DomainFilesystemArrayInput
	// The UEFI rom images for exercising UEFI secure boot in a qemu
	// environment. Users should usually specify one of the standard _Open Virtual Machine
	// Firmware_ (_OVMF_) images available for their distributions. The file will be opened
	// read-only.
	Firmware pulumi.StringPtrInput
	// The name of the firmware config path where ignition file is stored: default is `opt/com.coreos/config`. If you are using [Flatcar Linux](https://docs.flatcar-linux.org/os/booting-with-libvirt/#creating-the-domain-xml), the value is `opt/org.flatcar-linux/config`.
	FwCfgName pulumi.StringPtrInput
	Graphics  DomainGraphicsPtrInput
	// The path of the initrd to boot.
	//
	// You can use it in the same way as the kernel.
	Initrd pulumi.StringPtrInput
	// The path of the kernel to boot
	//
	// If you are using a qcow2 volume, you can pass the id of the volume (eg. `${libvirt_volume.kernel.id}`)
	// as they are local to the hypervisor.
	//
	// Given that you can define a volume from a remote http file, this means, you can also have remote kernels.
	//
	// ```go
	// package main
	//
	// import (
	// 	"github.com/pulumi/pulumi-libvirt/sdk/go/libvirt"
	// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	// )
	//
	// func main() {
	// 	pulumi.Run(func(ctx *pulumi.Context) error {
	// 		kernel, err := libvirt.NewVolume(ctx, "kernel", &libvirt.VolumeArgs{
	// 			Source: pulumi.String("http://download.opensuse.org/tumbleweed/repo/oss/boot/x86_64/loader/linux"),
	// 			Pool:   pulumi.String("default"),
	// 			Format: pulumi.String("raw"),
	// 		})
	// 		if err != nil {
	// 			return err
	// 		}
	// 		_, err = libvirt.NewDomain(ctx, "domain-suse", &libvirt.DomainArgs{
	// 			Memory: pulumi.Int(1024),
	// 			Vcpu:   pulumi.Int(1),
	// 			Kernel: kernel.ID(),
	// 		})
	// 		if err != nil {
	// 			return err
	// 		}
	// 		return nil
	// 	})
	// }
	// ```
	Kernel pulumi.StringPtrInput
	// The machine type,
	// you normally won't need to set this unless you are running on a platform that
	// defaults to the wrong machine type for your template
	Machine pulumi.StringPtrInput
	// The amount of memory in MiB. If not specified the domain
	// will be created with 512 MiB of memory be used.
	Memory   pulumi.IntPtrInput
	Metadata pulumi.StringPtrInput
	// A unique name for the resource, required by libvirt.
	// Changing this forces a new resource to be created.
	Name pulumi.StringPtrInput
	// An array of one or more network interfaces to
	// attach to the domain. The `networkInterface` object structure is documented
	// below.
	NetworkInterfaces DomainNetworkInterfaceArrayInput
	// this block allows specifying the following attributes related to the _nvram_:
	Nvram DomainNvramPtrInput
	// By default is disabled, set to true for enabling it. More info [qemu-agent](https://wiki.libvirt.org/page/Qemu_guest_agent).
	QemuAgent pulumi.BoolPtrInput
	// Use `false` to turn off the instance. If not specified,
	// true is assumed and the instance, if stopped, will be started at next apply.
	Running pulumi.BoolPtrInput
	// TPM device to attach to the domain. The `tpm` object structure is documented below.
	Tpm DomainTpmPtrInput
	// The amount of virtual CPUs. If not specified, a single CPU
	// will be created.
	Vcpu  pulumi.IntPtrInput
	Video DomainVideoPtrInput
	Xml   DomainXmlPtrInput
}

func (DomainArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*domainArgs)(nil)).Elem()
}

type DomainInput interface {
	pulumi.Input

	ToDomainOutput() DomainOutput
	ToDomainOutputWithContext(ctx context.Context) DomainOutput
}

func (*Domain) ElementType() reflect.Type {
	return reflect.TypeOf((**Domain)(nil)).Elem()
}

func (i *Domain) ToDomainOutput() DomainOutput {
	return i.ToDomainOutputWithContext(context.Background())
}

func (i *Domain) ToDomainOutputWithContext(ctx context.Context) DomainOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DomainOutput)
}

func (i *Domain) ToOutput(ctx context.Context) pulumix.Output[*Domain] {
	return pulumix.Output[*Domain]{
		OutputState: i.ToDomainOutputWithContext(ctx).OutputState,
	}
}

// DomainArrayInput is an input type that accepts DomainArray and DomainArrayOutput values.
// You can construct a concrete instance of `DomainArrayInput` via:
//
//	DomainArray{ DomainArgs{...} }
type DomainArrayInput interface {
	pulumi.Input

	ToDomainArrayOutput() DomainArrayOutput
	ToDomainArrayOutputWithContext(context.Context) DomainArrayOutput
}

type DomainArray []DomainInput

func (DomainArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Domain)(nil)).Elem()
}

func (i DomainArray) ToDomainArrayOutput() DomainArrayOutput {
	return i.ToDomainArrayOutputWithContext(context.Background())
}

func (i DomainArray) ToDomainArrayOutputWithContext(ctx context.Context) DomainArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DomainArrayOutput)
}

func (i DomainArray) ToOutput(ctx context.Context) pulumix.Output[[]*Domain] {
	return pulumix.Output[[]*Domain]{
		OutputState: i.ToDomainArrayOutputWithContext(ctx).OutputState,
	}
}

// DomainMapInput is an input type that accepts DomainMap and DomainMapOutput values.
// You can construct a concrete instance of `DomainMapInput` via:
//
//	DomainMap{ "key": DomainArgs{...} }
type DomainMapInput interface {
	pulumi.Input

	ToDomainMapOutput() DomainMapOutput
	ToDomainMapOutputWithContext(context.Context) DomainMapOutput
}

type DomainMap map[string]DomainInput

func (DomainMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Domain)(nil)).Elem()
}

func (i DomainMap) ToDomainMapOutput() DomainMapOutput {
	return i.ToDomainMapOutputWithContext(context.Background())
}

func (i DomainMap) ToDomainMapOutputWithContext(ctx context.Context) DomainMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DomainMapOutput)
}

func (i DomainMap) ToOutput(ctx context.Context) pulumix.Output[map[string]*Domain] {
	return pulumix.Output[map[string]*Domain]{
		OutputState: i.ToDomainMapOutputWithContext(ctx).OutputState,
	}
}

type DomainOutput struct{ *pulumi.OutputState }

func (DomainOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Domain)(nil)).Elem()
}

func (o DomainOutput) ToDomainOutput() DomainOutput {
	return o
}

func (o DomainOutput) ToDomainOutputWithContext(ctx context.Context) DomainOutput {
	return o
}

func (o DomainOutput) ToOutput(ctx context.Context) pulumix.Output[*Domain] {
	return pulumix.Output[*Domain]{
		OutputState: o.OutputState,
	}
}

// The architecture for the VM (probably x8664 or i686),
// you normally won't need to set this unless you are building a special VM
func (o DomainOutput) Arch() pulumi.StringOutput {
	return o.ApplyT(func(v *Domain) pulumi.StringOutput { return v.Arch }).(pulumi.StringOutput)
}

// Set to `true` to start the domain on host boot up.
// If not specified `false` is assumed.
func (o DomainOutput) Autostart() pulumi.BoolOutput {
	return o.ApplyT(func(v *Domain) pulumi.BoolOutput { return v.Autostart }).(pulumi.BoolOutput)
}

// A list of devices (dev) which defines boot order. Example
// below.
func (o DomainOutput) BootDevices() DomainBootDeviceArrayOutput {
	return o.ApplyT(func(v *Domain) DomainBootDeviceArrayOutput { return v.BootDevices }).(DomainBootDeviceArrayOutput)
}

// The `CloudInitDisk` disk that has to be used by
// the domain. This is going to be attached as a CDROM ISO. Changing the
// cloud-init won't cause the domain to be recreated, however the change will
// have effect on the next reboot.
func (o DomainOutput) Cloudinit() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Domain) pulumi.StringPtrOutput { return v.Cloudinit }).(pulumi.StringPtrOutput)
}

// Arguments to the kernel
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-libvirt/sdk/go/libvirt"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := libvirt.NewDomain(ctx, "domain-suse", &libvirt.DomainArgs{
//				Memory: pulumi.Int(1024),
//				Vcpu:   pulumi.Int(1),
//				Kernel: pulumi.Any(libvirt_volume.Kernel.Id),
//				Cmdlines: pulumi.AnyMapArray{
//					pulumi.AnyMap{
//						"arg1": pulumi.Any("value1"),
//						"arg2": pulumi.Any("value2"),
//						"_":    pulumi.Any("rw nosplash"),
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// Kernel params that don't have a keyword identifier can be specified using the
// special `"_"` keyword. Multiple keyword-less params have to be specified using
// the same `"_"` keyword, like in the example above.
//
// Also note that the `cmd` block is actually a list of maps, so it is possible to
// declare several of them by using either the literal list and map syntax as in
// the following examples:
func (o DomainOutput) Cmdlines() pulumi.MapArrayOutput {
	return o.ApplyT(func(v *Domain) pulumi.MapArrayOutput { return v.Cmdlines }).(pulumi.MapArrayOutput)
}

func (o DomainOutput) Consoles() DomainConsoleArrayOutput {
	return o.ApplyT(func(v *Domain) DomainConsoleArrayOutput { return v.Consoles }).(DomainConsoleArrayOutput)
}

// The
// [Ignition](https://www.terraform.io/docs/providers/libvirt/r/coreos_ignition.html) resource
// that is to be used by the CoreOS domain.
func (o DomainOutput) CoreosIgnition() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Domain) pulumi.StringPtrOutput { return v.CoreosIgnition }).(pulumi.StringPtrOutput)
}

// Configures CPU mode. See below for more
// details.
func (o DomainOutput) Cpu() DomainCpuOutput {
	return o.ApplyT(func(v *Domain) DomainCpuOutput { return v.Cpu }).(DomainCpuOutput)
}

// The description for domain.
// Changing this forces a new resource to be created.
// This data is not used by libvirt in any way, it can contain any information the user wants.
func (o DomainOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Domain) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

// An array of one or more disks to attach to the domain. The
// `disk` object structure is documented below.
func (o DomainOutput) Disks() DomainDiskArrayOutput {
	return o.ApplyT(func(v *Domain) DomainDiskArrayOutput { return v.Disks }).(DomainDiskArrayOutput)
}

// The path of the emulator to use
func (o DomainOutput) Emulator() pulumi.StringOutput {
	return o.ApplyT(func(v *Domain) pulumi.StringOutput { return v.Emulator }).(pulumi.StringOutput)
}

// An array of one or more host filesystems to attach to
// the domain. The `filesystem` object structure is documented
// below.
func (o DomainOutput) Filesystems() DomainFilesystemArrayOutput {
	return o.ApplyT(func(v *Domain) DomainFilesystemArrayOutput { return v.Filesystems }).(DomainFilesystemArrayOutput)
}

// The UEFI rom images for exercising UEFI secure boot in a qemu
// environment. Users should usually specify one of the standard _Open Virtual Machine
// Firmware_ (_OVMF_) images available for their distributions. The file will be opened
// read-only.
func (o DomainOutput) Firmware() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Domain) pulumi.StringPtrOutput { return v.Firmware }).(pulumi.StringPtrOutput)
}

// The name of the firmware config path where ignition file is stored: default is `opt/com.coreos/config`. If you are using [Flatcar Linux](https://docs.flatcar-linux.org/os/booting-with-libvirt/#creating-the-domain-xml), the value is `opt/org.flatcar-linux/config`.
func (o DomainOutput) FwCfgName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Domain) pulumi.StringPtrOutput { return v.FwCfgName }).(pulumi.StringPtrOutput)
}

func (o DomainOutput) Graphics() DomainGraphicsPtrOutput {
	return o.ApplyT(func(v *Domain) DomainGraphicsPtrOutput { return v.Graphics }).(DomainGraphicsPtrOutput)
}

// The path of the initrd to boot.
//
// You can use it in the same way as the kernel.
func (o DomainOutput) Initrd() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Domain) pulumi.StringPtrOutput { return v.Initrd }).(pulumi.StringPtrOutput)
}

// The path of the kernel to boot
//
// If you are using a qcow2 volume, you can pass the id of the volume (eg. `${libvirt_volume.kernel.id}`)
// as they are local to the hypervisor.
//
// Given that you can define a volume from a remote http file, this means, you can also have remote kernels.
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-libvirt/sdk/go/libvirt"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			kernel, err := libvirt.NewVolume(ctx, "kernel", &libvirt.VolumeArgs{
//				Source: pulumi.String("http://download.opensuse.org/tumbleweed/repo/oss/boot/x86_64/loader/linux"),
//				Pool:   pulumi.String("default"),
//				Format: pulumi.String("raw"),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = libvirt.NewDomain(ctx, "domain-suse", &libvirt.DomainArgs{
//				Memory: pulumi.Int(1024),
//				Vcpu:   pulumi.Int(1),
//				Kernel: kernel.ID(),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
func (o DomainOutput) Kernel() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Domain) pulumi.StringPtrOutput { return v.Kernel }).(pulumi.StringPtrOutput)
}

// The machine type,
// you normally won't need to set this unless you are running on a platform that
// defaults to the wrong machine type for your template
func (o DomainOutput) Machine() pulumi.StringOutput {
	return o.ApplyT(func(v *Domain) pulumi.StringOutput { return v.Machine }).(pulumi.StringOutput)
}

// The amount of memory in MiB. If not specified the domain
// will be created with 512 MiB of memory be used.
func (o DomainOutput) Memory() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *Domain) pulumi.IntPtrOutput { return v.Memory }).(pulumi.IntPtrOutput)
}

func (o DomainOutput) Metadata() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Domain) pulumi.StringPtrOutput { return v.Metadata }).(pulumi.StringPtrOutput)
}

// A unique name for the resource, required by libvirt.
// Changing this forces a new resource to be created.
func (o DomainOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *Domain) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// An array of one or more network interfaces to
// attach to the domain. The `networkInterface` object structure is documented
// below.
func (o DomainOutput) NetworkInterfaces() DomainNetworkInterfaceArrayOutput {
	return o.ApplyT(func(v *Domain) DomainNetworkInterfaceArrayOutput { return v.NetworkInterfaces }).(DomainNetworkInterfaceArrayOutput)
}

// this block allows specifying the following attributes related to the _nvram_:
func (o DomainOutput) Nvram() DomainNvramPtrOutput {
	return o.ApplyT(func(v *Domain) DomainNvramPtrOutput { return v.Nvram }).(DomainNvramPtrOutput)
}

// By default is disabled, set to true for enabling it. More info [qemu-agent](https://wiki.libvirt.org/page/Qemu_guest_agent).
func (o DomainOutput) QemuAgent() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *Domain) pulumi.BoolPtrOutput { return v.QemuAgent }).(pulumi.BoolPtrOutput)
}

// Use `false` to turn off the instance. If not specified,
// true is assumed and the instance, if stopped, will be started at next apply.
func (o DomainOutput) Running() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *Domain) pulumi.BoolPtrOutput { return v.Running }).(pulumi.BoolPtrOutput)
}

// TPM device to attach to the domain. The `tpm` object structure is documented below.
func (o DomainOutput) Tpm() DomainTpmPtrOutput {
	return o.ApplyT(func(v *Domain) DomainTpmPtrOutput { return v.Tpm }).(DomainTpmPtrOutput)
}

// The amount of virtual CPUs. If not specified, a single CPU
// will be created.
func (o DomainOutput) Vcpu() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *Domain) pulumi.IntPtrOutput { return v.Vcpu }).(pulumi.IntPtrOutput)
}

func (o DomainOutput) Video() DomainVideoPtrOutput {
	return o.ApplyT(func(v *Domain) DomainVideoPtrOutput { return v.Video }).(DomainVideoPtrOutput)
}

func (o DomainOutput) Xml() DomainXmlPtrOutput {
	return o.ApplyT(func(v *Domain) DomainXmlPtrOutput { return v.Xml }).(DomainXmlPtrOutput)
}

type DomainArrayOutput struct{ *pulumi.OutputState }

func (DomainArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Domain)(nil)).Elem()
}

func (o DomainArrayOutput) ToDomainArrayOutput() DomainArrayOutput {
	return o
}

func (o DomainArrayOutput) ToDomainArrayOutputWithContext(ctx context.Context) DomainArrayOutput {
	return o
}

func (o DomainArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[]*Domain] {
	return pulumix.Output[[]*Domain]{
		OutputState: o.OutputState,
	}
}

func (o DomainArrayOutput) Index(i pulumi.IntInput) DomainOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Domain {
		return vs[0].([]*Domain)[vs[1].(int)]
	}).(DomainOutput)
}

type DomainMapOutput struct{ *pulumi.OutputState }

func (DomainMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Domain)(nil)).Elem()
}

func (o DomainMapOutput) ToDomainMapOutput() DomainMapOutput {
	return o
}

func (o DomainMapOutput) ToDomainMapOutputWithContext(ctx context.Context) DomainMapOutput {
	return o
}

func (o DomainMapOutput) ToOutput(ctx context.Context) pulumix.Output[map[string]*Domain] {
	return pulumix.Output[map[string]*Domain]{
		OutputState: o.OutputState,
	}
}

func (o DomainMapOutput) MapIndex(k pulumi.StringInput) DomainOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Domain {
		return vs[0].(map[string]*Domain)[vs[1].(string)]
	}).(DomainOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*DomainInput)(nil)).Elem(), &Domain{})
	pulumi.RegisterInputType(reflect.TypeOf((*DomainArrayInput)(nil)).Elem(), DomainArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*DomainMapInput)(nil)).Elem(), DomainMap{})
	pulumi.RegisterOutputType(DomainOutput{})
	pulumi.RegisterOutputType(DomainArrayOutput{})
	pulumi.RegisterOutputType(DomainMapOutput{})
}
