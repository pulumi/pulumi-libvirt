// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.libvirt;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Export;
import com.pulumi.core.annotations.ResourceType;
import com.pulumi.core.internal.Codegen;
import com.pulumi.libvirt.DomainArgs;
import com.pulumi.libvirt.Utilities;
import com.pulumi.libvirt.inputs.DomainState;
import com.pulumi.libvirt.outputs.DomainBootDevice;
import com.pulumi.libvirt.outputs.DomainConsole;
import com.pulumi.libvirt.outputs.DomainCpu;
import com.pulumi.libvirt.outputs.DomainDisk;
import com.pulumi.libvirt.outputs.DomainFilesystem;
import com.pulumi.libvirt.outputs.DomainGraphics;
import com.pulumi.libvirt.outputs.DomainNetworkInterface;
import com.pulumi.libvirt.outputs.DomainNvram;
import com.pulumi.libvirt.outputs.DomainTpm;
import com.pulumi.libvirt.outputs.DomainVideo;
import com.pulumi.libvirt.outputs.DomainXml;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.Object;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import javax.annotation.Nullable;

/**
 * Manages a VM domain resource within libvirt. For more information see
 * [the official documentation](https://libvirt.org/formatdomain.html).
 * 
 * ## Example Usage
 * ```java
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.libvirt.Domain;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var default_ = new Domain(&#34;default&#34;);
 * 
 *     }
 * }
 * ```
 * 
 */
@ResourceType(type="libvirt:index/domain:Domain")
public class Domain extends com.pulumi.resources.CustomResource {
    /**
     * The architecture for the VM (probably x86_64 or i686),
     * you normally won&#39;t need to set this unless you are building a special VM
     * 
     */
    @Export(name="arch", type=String.class, parameters={})
    private Output<String> arch;

    /**
     * @return The architecture for the VM (probably x86_64 or i686),
     * you normally won&#39;t need to set this unless you are building a special VM
     * 
     */
    public Output<String> arch() {
        return this.arch;
    }
    /**
     * Set to `true` to start the domain on host boot up.
     * If not specified `false` is assumed.
     * 
     */
    @Export(name="autostart", type=Boolean.class, parameters={})
    private Output</* @Nullable */ Boolean> autostart;

    /**
     * @return Set to `true` to start the domain on host boot up.
     * If not specified `false` is assumed.
     * 
     */
    public Output<Optional<Boolean>> autostart() {
        return Codegen.optional(this.autostart);
    }
    /**
     * A list of devices (dev) which defines boot order. Example
     * below.
     * 
     */
    @Export(name="bootDevices", type=List.class, parameters={DomainBootDevice.class})
    private Output</* @Nullable */ List<DomainBootDevice>> bootDevices;

    /**
     * @return A list of devices (dev) which defines boot order. Example
     * below.
     * 
     */
    public Output<Optional<List<DomainBootDevice>>> bootDevices() {
        return Codegen.optional(this.bootDevices);
    }
    /**
     * The `libvirt.CloudInitDisk` disk that has to be used by
     * the domain. This is going to be attached as a CDROM ISO. Changing the
     * cloud-init won&#39;t cause the domain to be recreated, however the change will
     * have effect on the next reboot.
     * 
     */
    @Export(name="cloudinit", type=String.class, parameters={})
    private Output</* @Nullable */ String> cloudinit;

    /**
     * @return The `libvirt.CloudInitDisk` disk that has to be used by
     * the domain. This is going to be attached as a CDROM ISO. Changing the
     * cloud-init won&#39;t cause the domain to be recreated, however the change will
     * have effect on the next reboot.
     * 
     */
    public Output<Optional<String>> cloudinit() {
        return Codegen.optional(this.cloudinit);
    }
    /**
     * Arguments to the kernel
     * 
     */
    @Export(name="cmdlines", type=List.class, parameters={Map.class})
    private Output</* @Nullable */ List<Map<String,Object>>> cmdlines;

    /**
     * @return Arguments to the kernel
     * 
     */
    public Output<Optional<List<Map<String,Object>>>> cmdlines() {
        return Codegen.optional(this.cmdlines);
    }
    @Export(name="consoles", type=List.class, parameters={DomainConsole.class})
    private Output</* @Nullable */ List<DomainConsole>> consoles;

    public Output<Optional<List<DomainConsole>>> consoles() {
        return Codegen.optional(this.consoles);
    }
    /**
     * The
     * [libvirt.Ignition](https://www.terraform.io/docs/providers/libvirt/r/coreos_ignition.html) resource
     * that is to be used by the CoreOS domain.
     * 
     */
    @Export(name="coreosIgnition", type=String.class, parameters={})
    private Output</* @Nullable */ String> coreosIgnition;

    /**
     * @return The
     * [libvirt.Ignition](https://www.terraform.io/docs/providers/libvirt/r/coreos_ignition.html) resource
     * that is to be used by the CoreOS domain.
     * 
     */
    public Output<Optional<String>> coreosIgnition() {
        return Codegen.optional(this.coreosIgnition);
    }
    /**
     * Configures CPU mode. See below for more
     * details.
     * 
     */
    @Export(name="cpu", type=DomainCpu.class, parameters={})
    private Output</* @Nullable */ DomainCpu> cpu;

    /**
     * @return Configures CPU mode. See below for more
     * details.
     * 
     */
    public Output<Optional<DomainCpu>> cpu() {
        return Codegen.optional(this.cpu);
    }
    /**
     * The description for domain.
     * Changing this forces a new resource to be created.
     * This data is not used by libvirt in any way, it can contain any information the user wants.
     * 
     */
    @Export(name="description", type=String.class, parameters={})
    private Output</* @Nullable */ String> description;

    /**
     * @return The description for domain.
     * Changing this forces a new resource to be created.
     * This data is not used by libvirt in any way, it can contain any information the user wants.
     * 
     */
    public Output<Optional<String>> description() {
        return Codegen.optional(this.description);
    }
    /**
     * An array of one or more disks to attach to the domain. The
     * `disk` object structure is documented below.
     * 
     */
    @Export(name="disks", type=List.class, parameters={DomainDisk.class})
    private Output</* @Nullable */ List<DomainDisk>> disks;

    /**
     * @return An array of one or more disks to attach to the domain. The
     * `disk` object structure is documented below.
     * 
     */
    public Output<Optional<List<DomainDisk>>> disks() {
        return Codegen.optional(this.disks);
    }
    /**
     * The path of the emulator to use
     * 
     */
    @Export(name="emulator", type=String.class, parameters={})
    private Output<String> emulator;

    /**
     * @return The path of the emulator to use
     * 
     */
    public Output<String> emulator() {
        return this.emulator;
    }
    /**
     * An array of one or more host filesystems to attach to
     * the domain. The `filesystem` object structure is documented
     * below.
     * 
     */
    @Export(name="filesystems", type=List.class, parameters={DomainFilesystem.class})
    private Output</* @Nullable */ List<DomainFilesystem>> filesystems;

    /**
     * @return An array of one or more host filesystems to attach to
     * the domain. The `filesystem` object structure is documented
     * below.
     * 
     */
    public Output<Optional<List<DomainFilesystem>>> filesystems() {
        return Codegen.optional(this.filesystems);
    }
    /**
     * The UEFI rom images for exercising UEFI secure boot in a qemu
     * environment. Users should usually specify one of the standard _Open Virtual Machine
     * Firmware_ (_OVMF_) images available for their distributions. The file will be opened
     * read-only.
     * 
     */
    @Export(name="firmware", type=String.class, parameters={})
    private Output</* @Nullable */ String> firmware;

    /**
     * @return The UEFI rom images for exercising UEFI secure boot in a qemu
     * environment. Users should usually specify one of the standard _Open Virtual Machine
     * Firmware_ (_OVMF_) images available for their distributions. The file will be opened
     * read-only.
     * 
     */
    public Output<Optional<String>> firmware() {
        return Codegen.optional(this.firmware);
    }
    /**
     * The name of the firmware config path where ignition file is stored: default is `opt/com.coreos/config`. If you are using [Flatcar Linux](https://docs.flatcar-linux.org/os/booting-with-libvirt/#creating-the-domain-xml), the value is `opt/org.flatcar-linux/config`.
     * 
     */
    @Export(name="fwCfgName", type=String.class, parameters={})
    private Output</* @Nullable */ String> fwCfgName;

    /**
     * @return The name of the firmware config path where ignition file is stored: default is `opt/com.coreos/config`. If you are using [Flatcar Linux](https://docs.flatcar-linux.org/os/booting-with-libvirt/#creating-the-domain-xml), the value is `opt/org.flatcar-linux/config`.
     * 
     */
    public Output<Optional<String>> fwCfgName() {
        return Codegen.optional(this.fwCfgName);
    }
    @Export(name="graphics", type=DomainGraphics.class, parameters={})
    private Output</* @Nullable */ DomainGraphics> graphics;

    public Output<Optional<DomainGraphics>> graphics() {
        return Codegen.optional(this.graphics);
    }
    /**
     * The path of the initrd to boot.
     * 
     */
    @Export(name="initrd", type=String.class, parameters={})
    private Output</* @Nullable */ String> initrd;

    /**
     * @return The path of the initrd to boot.
     * 
     */
    public Output<Optional<String>> initrd() {
        return Codegen.optional(this.initrd);
    }
    /**
     * The path of the kernel to boot
     * 
     */
    @Export(name="kernel", type=String.class, parameters={})
    private Output</* @Nullable */ String> kernel;

    /**
     * @return The path of the kernel to boot
     * 
     */
    public Output<Optional<String>> kernel() {
        return Codegen.optional(this.kernel);
    }
    /**
     * The machine type,
     * you normally won&#39;t need to set this unless you are running on a platform that
     * defaults to the wrong machine type for your template
     * 
     */
    @Export(name="machine", type=String.class, parameters={})
    private Output<String> machine;

    /**
     * @return The machine type,
     * you normally won&#39;t need to set this unless you are running on a platform that
     * defaults to the wrong machine type for your template
     * 
     */
    public Output<String> machine() {
        return this.machine;
    }
    /**
     * The amount of memory in MiB. If not specified the domain
     * will be created with 512 MiB of memory be used.
     * 
     */
    @Export(name="memory", type=Integer.class, parameters={})
    private Output</* @Nullable */ Integer> memory;

    /**
     * @return The amount of memory in MiB. If not specified the domain
     * will be created with 512 MiB of memory be used.
     * 
     */
    public Output<Optional<Integer>> memory() {
        return Codegen.optional(this.memory);
    }
    @Export(name="metadata", type=String.class, parameters={})
    private Output</* @Nullable */ String> metadata;

    public Output<Optional<String>> metadata() {
        return Codegen.optional(this.metadata);
    }
    /**
     * A unique name for the resource, required by libvirt.
     * Changing this forces a new resource to be created.
     * 
     */
    @Export(name="name", type=String.class, parameters={})
    private Output<String> name;

    /**
     * @return A unique name for the resource, required by libvirt.
     * Changing this forces a new resource to be created.
     * 
     */
    public Output<String> name() {
        return this.name;
    }
    /**
     * An array of one or more network interfaces to
     * attach to the domain. The `network_interface` object structure is documented
     * below.
     * 
     */
    @Export(name="networkInterfaces", type=List.class, parameters={DomainNetworkInterface.class})
    private Output</* @Nullable */ List<DomainNetworkInterface>> networkInterfaces;

    /**
     * @return An array of one or more network interfaces to
     * attach to the domain. The `network_interface` object structure is documented
     * below.
     * 
     */
    public Output<Optional<List<DomainNetworkInterface>>> networkInterfaces() {
        return Codegen.optional(this.networkInterfaces);
    }
    /**
     * this block allows specifying the following attributes related to the _nvram_:
     * 
     */
    @Export(name="nvram", type=DomainNvram.class, parameters={})
    private Output</* @Nullable */ DomainNvram> nvram;

    /**
     * @return this block allows specifying the following attributes related to the _nvram_:
     * 
     */
    public Output<Optional<DomainNvram>> nvram() {
        return Codegen.optional(this.nvram);
    }
    /**
     * By default is disabled, set to true for enabling it. More info [qemu-agent](https://wiki.libvirt.org/page/Qemu_guest_agent).
     * 
     */
    @Export(name="qemuAgent", type=Boolean.class, parameters={})
    private Output</* @Nullable */ Boolean> qemuAgent;

    /**
     * @return By default is disabled, set to true for enabling it. More info [qemu-agent](https://wiki.libvirt.org/page/Qemu_guest_agent).
     * 
     */
    public Output<Optional<Boolean>> qemuAgent() {
        return Codegen.optional(this.qemuAgent);
    }
    /**
     * Use `false` to turn off the instance. If not specified,
     * true is assumed and the instance, if stopped, will be started at next apply.
     * 
     */
    @Export(name="running", type=Boolean.class, parameters={})
    private Output</* @Nullable */ Boolean> running;

    /**
     * @return Use `false` to turn off the instance. If not specified,
     * true is assumed and the instance, if stopped, will be started at next apply.
     * 
     */
    public Output<Optional<Boolean>> running() {
        return Codegen.optional(this.running);
    }
    /**
     * TPM device to attach to the domain. The `tpm` object structure is documented below.
     * 
     */
    @Export(name="tpm", type=DomainTpm.class, parameters={})
    private Output</* @Nullable */ DomainTpm> tpm;

    /**
     * @return TPM device to attach to the domain. The `tpm` object structure is documented below.
     * 
     */
    public Output<Optional<DomainTpm>> tpm() {
        return Codegen.optional(this.tpm);
    }
    /**
     * The amount of virtual CPUs. If not specified, a single CPU
     * will be created.
     * 
     */
    @Export(name="vcpu", type=Integer.class, parameters={})
    private Output</* @Nullable */ Integer> vcpu;

    /**
     * @return The amount of virtual CPUs. If not specified, a single CPU
     * will be created.
     * 
     */
    public Output<Optional<Integer>> vcpu() {
        return Codegen.optional(this.vcpu);
    }
    @Export(name="video", type=DomainVideo.class, parameters={})
    private Output</* @Nullable */ DomainVideo> video;

    public Output<Optional<DomainVideo>> video() {
        return Codegen.optional(this.video);
    }
    @Export(name="xml", type=DomainXml.class, parameters={})
    private Output</* @Nullable */ DomainXml> xml;

    public Output<Optional<DomainXml>> xml() {
        return Codegen.optional(this.xml);
    }

    /**
     *
     * @param name The _unique_ name of the resulting resource.
     */
    public Domain(String name) {
        this(name, DomainArgs.Empty);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     */
    public Domain(String name, @Nullable DomainArgs args) {
        this(name, args, null);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param options A bag of options that control this resource's behavior.
     */
    public Domain(String name, @Nullable DomainArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("libvirt:index/domain:Domain", name, args == null ? DomainArgs.Empty : args, makeResourceOptions(options, Codegen.empty()));
    }

    private Domain(String name, Output<String> id, @Nullable DomainState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("libvirt:index/domain:Domain", name, state, makeResourceOptions(options, id));
    }

    private static com.pulumi.resources.CustomResourceOptions makeResourceOptions(@Nullable com.pulumi.resources.CustomResourceOptions options, @Nullable Output<String> id) {
        var defaultOptions = com.pulumi.resources.CustomResourceOptions.builder()
            .version(Utilities.getVersion())
            .build();
        return com.pulumi.resources.CustomResourceOptions.merge(defaultOptions, options, id);
    }

    /**
     * Get an existing Host resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state
     * @param options Optional settings to control the behavior of the CustomResource.
     */
    public static Domain get(String name, Output<String> id, @Nullable DomainState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        return new Domain(name, id, state, options);
    }
}
