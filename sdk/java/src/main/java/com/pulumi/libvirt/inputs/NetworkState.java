// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.libvirt.inputs;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.libvirt.inputs.NetworkDhcpArgs;
import com.pulumi.libvirt.inputs.NetworkDnsArgs;
import com.pulumi.libvirt.inputs.NetworkDnsmasqOptionsArgs;
import com.pulumi.libvirt.inputs.NetworkRouteArgs;
import com.pulumi.libvirt.inputs.NetworkXmlArgs;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class NetworkState extends com.pulumi.resources.ResourceArgs {

    public static final NetworkState Empty = new NetworkState();

    /**
     * A list of (0 or 1) IPv4 and (0 or 1) IPv6 subnets in
     * CIDR notation.  This defines the subnets associated to that network.
     * This argument is also used to define the address on the real host.
     * If `dhcp {  enabled = true }` addresses is also used to define the address range served by
     * the DHCP server.
     * No DHCP server will be started if `addresses` is omitted.
     * 
     */
    @Import(name="addresses")
    private @Nullable Output<List<String>> addresses;

    /**
     * @return A list of (0 or 1) IPv4 and (0 or 1) IPv6 subnets in
     * CIDR notation.  This defines the subnets associated to that network.
     * This argument is also used to define the address on the real host.
     * If `dhcp {  enabled = true }` addresses is also used to define the address range served by
     * the DHCP server.
     * No DHCP server will be started if `addresses` is omitted.
     * 
     */
    public Optional<Output<List<String>>> addresses() {
        return Optional.ofNullable(this.addresses);
    }

    /**
     * Set to `true` to start the network on host boot up.
     * If not specified `false` is assumed.
     * 
     */
    @Import(name="autostart")
    private @Nullable Output<Boolean> autostart;

    /**
     * @return Set to `true` to start the network on host boot up.
     * If not specified `false` is assumed.
     * 
     */
    public Optional<Output<Boolean>> autostart() {
        return Optional.ofNullable(this.autostart);
    }

    /**
     * The bridge device defines the name of a bridge
     * device which will be used to construct the virtual network (when not provided,
     * it will be automatically obtained by libvirt in `none`, `nat`, `route` and `open` modes).
     * 
     */
    @Import(name="bridge")
    private @Nullable Output<String> bridge;

    /**
     * @return The bridge device defines the name of a bridge
     * device which will be used to construct the virtual network (when not provided,
     * it will be automatically obtained by libvirt in `none`, `nat`, `route` and `open` modes).
     * 
     */
    public Optional<Output<String>> bridge() {
        return Optional.ofNullable(this.bridge);
    }

    @Import(name="dhcp")
    private @Nullable Output<NetworkDhcpArgs> dhcp;

    public Optional<Output<NetworkDhcpArgs>> dhcp() {
        return Optional.ofNullable(this.dhcp);
    }

    /**
     * configuration of DNS specific settings for the network
     * 
     */
    @Import(name="dns")
    private @Nullable Output<NetworkDnsArgs> dns;

    /**
     * @return configuration of DNS specific settings for the network
     * 
     */
    public Optional<Output<NetworkDnsArgs>> dns() {
        return Optional.ofNullable(this.dns);
    }

    @Import(name="dnsmasqOptions")
    private @Nullable Output<NetworkDnsmasqOptionsArgs> dnsmasqOptions;

    public Optional<Output<NetworkDnsmasqOptionsArgs>> dnsmasqOptions() {
        return Optional.ofNullable(this.dnsmasqOptions);
    }

    /**
     * The domain used by the DNS server.
     * 
     */
    @Import(name="domain")
    private @Nullable Output<String> domain;

    /**
     * @return The domain used by the DNS server.
     * 
     */
    public Optional<Output<String>> domain() {
        return Optional.ofNullable(this.domain);
    }

    /**
     * One of:
     * - &#34;none&#34;: the guests can talk to each other and the host OS, but cannot reach
     *   any other machines on the LAN.
     * - &#34;nat&#34;: it is the default network mode. This is a configuration that
     *   allows guest OS to get outbound connectivity regardless of whether the host
     *   uses ethernet, wireless, dialup, or VPN networking without requiring any
     *   specific admin configuration. In the absence of host networking, it at
     *   least allows guests to talk directly to each other.
     * - &#34;route&#34;: this is a variant on the default network which routes traffic from
     *   the virtual network to the LAN **without applying any NAT**. It requires that
     *   the IP address range be pre-configured in the routing tables of the router
     *   on the host network.
     * - &#34;open&#34;: similar to `route`, but no firewall rules are added.
     * - &#34;bridge&#34;: use a pre-existing host bridge. The guests will effectively be
     *   directly connected to the physical network (i.e. their IP addresses will
     *   all be on the subnet of the physical network, and there will be no
     *   restrictions on inbound or outbound connections). The `bridge` network
     *   attribute is mandatory in this case.
     * 
     */
    @Import(name="mode")
    private @Nullable Output<String> mode;

    /**
     * @return One of:
     * - &#34;none&#34;: the guests can talk to each other and the host OS, but cannot reach
     *   any other machines on the LAN.
     * - &#34;nat&#34;: it is the default network mode. This is a configuration that
     *   allows guest OS to get outbound connectivity regardless of whether the host
     *   uses ethernet, wireless, dialup, or VPN networking without requiring any
     *   specific admin configuration. In the absence of host networking, it at
     *   least allows guests to talk directly to each other.
     * - &#34;route&#34;: this is a variant on the default network which routes traffic from
     *   the virtual network to the LAN **without applying any NAT**. It requires that
     *   the IP address range be pre-configured in the routing tables of the router
     *   on the host network.
     * - &#34;open&#34;: similar to `route`, but no firewall rules are added.
     * - &#34;bridge&#34;: use a pre-existing host bridge. The guests will effectively be
     *   directly connected to the physical network (i.e. their IP addresses will
     *   all be on the subnet of the physical network, and there will be no
     *   restrictions on inbound or outbound connections). The `bridge` network
     *   attribute is mandatory in this case.
     * 
     */
    public Optional<Output<String>> mode() {
        return Optional.ofNullable(this.mode);
    }

    /**
     * The MTU to set for the underlying network interfaces. When
     * not supplied, libvirt will use the default for the interface, usually 1500.
     * Libvirt version 5.1 and greater will advertise this value to nodes via DHCP.
     * 
     */
    @Import(name="mtu")
    private @Nullable Output<Integer> mtu;

    /**
     * @return The MTU to set for the underlying network interfaces. When
     * not supplied, libvirt will use the default for the interface, usually 1500.
     * Libvirt version 5.1 and greater will advertise this value to nodes via DHCP.
     * 
     */
    public Optional<Output<Integer>> mtu() {
        return Optional.ofNullable(this.mtu);
    }

    /**
     * A unique name for the resource, required by libvirt.
     * Changing this forces a new resource to be created.
     * 
     */
    @Import(name="name")
    private @Nullable Output<String> name;

    /**
     * @return A unique name for the resource, required by libvirt.
     * Changing this forces a new resource to be created.
     * 
     */
    public Optional<Output<String>> name() {
        return Optional.ofNullable(this.name);
    }

    /**
     * a list of static routes. A `cidr` and a `gateway` must
     * be provided. The `gateway` must be reachable via the bridge interface.
     * 
     */
    @Import(name="routes")
    private @Nullable Output<List<NetworkRouteArgs>> routes;

    /**
     * @return a list of static routes. A `cidr` and a `gateway` must
     * be provided. The `gateway` must be reachable via the bridge interface.
     * 
     */
    public Optional<Output<List<NetworkRouteArgs>>> routes() {
        return Optional.ofNullable(this.routes);
    }

    @Import(name="xml")
    private @Nullable Output<NetworkXmlArgs> xml;

    public Optional<Output<NetworkXmlArgs>> xml() {
        return Optional.ofNullable(this.xml);
    }

    private NetworkState() {}

    private NetworkState(NetworkState $) {
        this.addresses = $.addresses;
        this.autostart = $.autostart;
        this.bridge = $.bridge;
        this.dhcp = $.dhcp;
        this.dns = $.dns;
        this.dnsmasqOptions = $.dnsmasqOptions;
        this.domain = $.domain;
        this.mode = $.mode;
        this.mtu = $.mtu;
        this.name = $.name;
        this.routes = $.routes;
        this.xml = $.xml;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(NetworkState defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private NetworkState $;

        public Builder() {
            $ = new NetworkState();
        }

        public Builder(NetworkState defaults) {
            $ = new NetworkState(Objects.requireNonNull(defaults));
        }

        /**
         * @param addresses A list of (0 or 1) IPv4 and (0 or 1) IPv6 subnets in
         * CIDR notation.  This defines the subnets associated to that network.
         * This argument is also used to define the address on the real host.
         * If `dhcp {  enabled = true }` addresses is also used to define the address range served by
         * the DHCP server.
         * No DHCP server will be started if `addresses` is omitted.
         * 
         * @return builder
         * 
         */
        public Builder addresses(@Nullable Output<List<String>> addresses) {
            $.addresses = addresses;
            return this;
        }

        /**
         * @param addresses A list of (0 or 1) IPv4 and (0 or 1) IPv6 subnets in
         * CIDR notation.  This defines the subnets associated to that network.
         * This argument is also used to define the address on the real host.
         * If `dhcp {  enabled = true }` addresses is also used to define the address range served by
         * the DHCP server.
         * No DHCP server will be started if `addresses` is omitted.
         * 
         * @return builder
         * 
         */
        public Builder addresses(List<String> addresses) {
            return addresses(Output.of(addresses));
        }

        /**
         * @param addresses A list of (0 or 1) IPv4 and (0 or 1) IPv6 subnets in
         * CIDR notation.  This defines the subnets associated to that network.
         * This argument is also used to define the address on the real host.
         * If `dhcp {  enabled = true }` addresses is also used to define the address range served by
         * the DHCP server.
         * No DHCP server will be started if `addresses` is omitted.
         * 
         * @return builder
         * 
         */
        public Builder addresses(String... addresses) {
            return addresses(List.of(addresses));
        }

        /**
         * @param autostart Set to `true` to start the network on host boot up.
         * If not specified `false` is assumed.
         * 
         * @return builder
         * 
         */
        public Builder autostart(@Nullable Output<Boolean> autostart) {
            $.autostart = autostart;
            return this;
        }

        /**
         * @param autostart Set to `true` to start the network on host boot up.
         * If not specified `false` is assumed.
         * 
         * @return builder
         * 
         */
        public Builder autostart(Boolean autostart) {
            return autostart(Output.of(autostart));
        }

        /**
         * @param bridge The bridge device defines the name of a bridge
         * device which will be used to construct the virtual network (when not provided,
         * it will be automatically obtained by libvirt in `none`, `nat`, `route` and `open` modes).
         * 
         * @return builder
         * 
         */
        public Builder bridge(@Nullable Output<String> bridge) {
            $.bridge = bridge;
            return this;
        }

        /**
         * @param bridge The bridge device defines the name of a bridge
         * device which will be used to construct the virtual network (when not provided,
         * it will be automatically obtained by libvirt in `none`, `nat`, `route` and `open` modes).
         * 
         * @return builder
         * 
         */
        public Builder bridge(String bridge) {
            return bridge(Output.of(bridge));
        }

        public Builder dhcp(@Nullable Output<NetworkDhcpArgs> dhcp) {
            $.dhcp = dhcp;
            return this;
        }

        public Builder dhcp(NetworkDhcpArgs dhcp) {
            return dhcp(Output.of(dhcp));
        }

        /**
         * @param dns configuration of DNS specific settings for the network
         * 
         * @return builder
         * 
         */
        public Builder dns(@Nullable Output<NetworkDnsArgs> dns) {
            $.dns = dns;
            return this;
        }

        /**
         * @param dns configuration of DNS specific settings for the network
         * 
         * @return builder
         * 
         */
        public Builder dns(NetworkDnsArgs dns) {
            return dns(Output.of(dns));
        }

        public Builder dnsmasqOptions(@Nullable Output<NetworkDnsmasqOptionsArgs> dnsmasqOptions) {
            $.dnsmasqOptions = dnsmasqOptions;
            return this;
        }

        public Builder dnsmasqOptions(NetworkDnsmasqOptionsArgs dnsmasqOptions) {
            return dnsmasqOptions(Output.of(dnsmasqOptions));
        }

        /**
         * @param domain The domain used by the DNS server.
         * 
         * @return builder
         * 
         */
        public Builder domain(@Nullable Output<String> domain) {
            $.domain = domain;
            return this;
        }

        /**
         * @param domain The domain used by the DNS server.
         * 
         * @return builder
         * 
         */
        public Builder domain(String domain) {
            return domain(Output.of(domain));
        }

        /**
         * @param mode One of:
         * - &#34;none&#34;: the guests can talk to each other and the host OS, but cannot reach
         *   any other machines on the LAN.
         * - &#34;nat&#34;: it is the default network mode. This is a configuration that
         *   allows guest OS to get outbound connectivity regardless of whether the host
         *   uses ethernet, wireless, dialup, or VPN networking without requiring any
         *   specific admin configuration. In the absence of host networking, it at
         *   least allows guests to talk directly to each other.
         * - &#34;route&#34;: this is a variant on the default network which routes traffic from
         *   the virtual network to the LAN **without applying any NAT**. It requires that
         *   the IP address range be pre-configured in the routing tables of the router
         *   on the host network.
         * - &#34;open&#34;: similar to `route`, but no firewall rules are added.
         * - &#34;bridge&#34;: use a pre-existing host bridge. The guests will effectively be
         *   directly connected to the physical network (i.e. their IP addresses will
         *   all be on the subnet of the physical network, and there will be no
         *   restrictions on inbound or outbound connections). The `bridge` network
         *   attribute is mandatory in this case.
         * 
         * @return builder
         * 
         */
        public Builder mode(@Nullable Output<String> mode) {
            $.mode = mode;
            return this;
        }

        /**
         * @param mode One of:
         * - &#34;none&#34;: the guests can talk to each other and the host OS, but cannot reach
         *   any other machines on the LAN.
         * - &#34;nat&#34;: it is the default network mode. This is a configuration that
         *   allows guest OS to get outbound connectivity regardless of whether the host
         *   uses ethernet, wireless, dialup, or VPN networking without requiring any
         *   specific admin configuration. In the absence of host networking, it at
         *   least allows guests to talk directly to each other.
         * - &#34;route&#34;: this is a variant on the default network which routes traffic from
         *   the virtual network to the LAN **without applying any NAT**. It requires that
         *   the IP address range be pre-configured in the routing tables of the router
         *   on the host network.
         * - &#34;open&#34;: similar to `route`, but no firewall rules are added.
         * - &#34;bridge&#34;: use a pre-existing host bridge. The guests will effectively be
         *   directly connected to the physical network (i.e. their IP addresses will
         *   all be on the subnet of the physical network, and there will be no
         *   restrictions on inbound or outbound connections). The `bridge` network
         *   attribute is mandatory in this case.
         * 
         * @return builder
         * 
         */
        public Builder mode(String mode) {
            return mode(Output.of(mode));
        }

        /**
         * @param mtu The MTU to set for the underlying network interfaces. When
         * not supplied, libvirt will use the default for the interface, usually 1500.
         * Libvirt version 5.1 and greater will advertise this value to nodes via DHCP.
         * 
         * @return builder
         * 
         */
        public Builder mtu(@Nullable Output<Integer> mtu) {
            $.mtu = mtu;
            return this;
        }

        /**
         * @param mtu The MTU to set for the underlying network interfaces. When
         * not supplied, libvirt will use the default for the interface, usually 1500.
         * Libvirt version 5.1 and greater will advertise this value to nodes via DHCP.
         * 
         * @return builder
         * 
         */
        public Builder mtu(Integer mtu) {
            return mtu(Output.of(mtu));
        }

        /**
         * @param name A unique name for the resource, required by libvirt.
         * Changing this forces a new resource to be created.
         * 
         * @return builder
         * 
         */
        public Builder name(@Nullable Output<String> name) {
            $.name = name;
            return this;
        }

        /**
         * @param name A unique name for the resource, required by libvirt.
         * Changing this forces a new resource to be created.
         * 
         * @return builder
         * 
         */
        public Builder name(String name) {
            return name(Output.of(name));
        }

        /**
         * @param routes a list of static routes. A `cidr` and a `gateway` must
         * be provided. The `gateway` must be reachable via the bridge interface.
         * 
         * @return builder
         * 
         */
        public Builder routes(@Nullable Output<List<NetworkRouteArgs>> routes) {
            $.routes = routes;
            return this;
        }

        /**
         * @param routes a list of static routes. A `cidr` and a `gateway` must
         * be provided. The `gateway` must be reachable via the bridge interface.
         * 
         * @return builder
         * 
         */
        public Builder routes(List<NetworkRouteArgs> routes) {
            return routes(Output.of(routes));
        }

        /**
         * @param routes a list of static routes. A `cidr` and a `gateway` must
         * be provided. The `gateway` must be reachable via the bridge interface.
         * 
         * @return builder
         * 
         */
        public Builder routes(NetworkRouteArgs... routes) {
            return routes(List.of(routes));
        }

        public Builder xml(@Nullable Output<NetworkXmlArgs> xml) {
            $.xml = xml;
            return this;
        }

        public Builder xml(NetworkXmlArgs xml) {
            return xml(Output.of(xml));
        }

        public NetworkState build() {
            return $;
        }
    }

}
