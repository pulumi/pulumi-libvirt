# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from . import _utilities
from . import outputs

__all__ = [
    'DomainBootDevice',
    'DomainConsole',
    'DomainCpu',
    'DomainDisk',
    'DomainFilesystem',
    'DomainGraphics',
    'DomainNetworkInterface',
    'DomainNvram',
    'DomainTpm',
    'DomainVideo',
    'DomainXml',
    'NetworkDhcp',
    'NetworkDns',
    'NetworkDnsForwarder',
    'NetworkDnsHost',
    'NetworkDnsSrv',
    'NetworkDnsmasqOptions',
    'NetworkDnsmasqOptionsOption',
    'NetworkRoute',
    'NetworkXml',
    'PoolXml',
    'VolumeXml',
]

@pulumi.output_type
class DomainBootDevice(dict):
    def __init__(__self__, *,
                 devs: Optional[Sequence[str]] = None):
        if devs is not None:
            pulumi.set(__self__, "devs", devs)

    @property
    @pulumi.getter
    def devs(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "devs")


@pulumi.output_type
class DomainConsole(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetPort":
            suggest = "target_port"
        elif key == "sourceHost":
            suggest = "source_host"
        elif key == "sourcePath":
            suggest = "source_path"
        elif key == "sourceService":
            suggest = "source_service"
        elif key == "targetType":
            suggest = "target_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainConsole. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainConsole.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainConsole.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 target_port: str,
                 type: str,
                 source_host: Optional[str] = None,
                 source_path: Optional[str] = None,
                 source_service: Optional[str] = None,
                 target_type: Optional[str] = None):
        """
        :param str target_port: Target port
        :param str type: Console device type. Valid values are "pty" and "tcp".
        :param str source_host: IP address to listen on. Defaults to 127.0.0.1.
        :param str source_path: Source path
               
               Additional attributes when type is "tcp":
        :param str source_service: Port number or a service name. Defaults to a
               random port.
               
               Note that you can repeat the `console` block to create more than one console.
               This works the same way as with the `disk` blocks (see above).
               
               See [libvirt Domain XML Console element](https://libvirt.org/formatdomain.html#elementsConsole)
               for more information.
        :param str target_type: for the first console and defaults to `serial`.
               Subsequent `console` blocks must have a different type - usually `virtio`.
               
               Additional attributes when type is "pty":
        """
        pulumi.set(__self__, "target_port", target_port)
        pulumi.set(__self__, "type", type)
        if source_host is not None:
            pulumi.set(__self__, "source_host", source_host)
        if source_path is not None:
            pulumi.set(__self__, "source_path", source_path)
        if source_service is not None:
            pulumi.set(__self__, "source_service", source_service)
        if target_type is not None:
            pulumi.set(__self__, "target_type", target_type)

    @property
    @pulumi.getter(name="targetPort")
    def target_port(self) -> str:
        """
        Target port
        """
        return pulumi.get(self, "target_port")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Console device type. Valid values are "pty" and "tcp".
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="sourceHost")
    def source_host(self) -> Optional[str]:
        """
        IP address to listen on. Defaults to 127.0.0.1.
        """
        return pulumi.get(self, "source_host")

    @property
    @pulumi.getter(name="sourcePath")
    def source_path(self) -> Optional[str]:
        """
        Source path

        Additional attributes when type is "tcp":
        """
        return pulumi.get(self, "source_path")

    @property
    @pulumi.getter(name="sourceService")
    def source_service(self) -> Optional[str]:
        """
        Port number or a service name. Defaults to a
        random port.

        Note that you can repeat the `console` block to create more than one console.
        This works the same way as with the `disk` blocks (see above).

        See [libvirt Domain XML Console element](https://libvirt.org/formatdomain.html#elementsConsole)
        for more information.
        """
        return pulumi.get(self, "source_service")

    @property
    @pulumi.getter(name="targetType")
    def target_type(self) -> Optional[str]:
        """
        for the first console and defaults to `serial`.
        Subsequent `console` blocks must have a different type - usually `virtio`.

        Additional attributes when type is "pty":
        """
        return pulumi.get(self, "target_type")


@pulumi.output_type
class DomainCpu(dict):
    def __init__(__self__, *,
                 mode: Optional[str] = None):
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        return pulumi.get(self, "mode")


@pulumi.output_type
class DomainDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "blockDevice":
            suggest = "block_device"
        elif key == "volumeId":
            suggest = "volume_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 block_device: Optional[str] = None,
                 file: Optional[str] = None,
                 scsi: Optional[bool] = None,
                 url: Optional[str] = None,
                 volume_id: Optional[str] = None,
                 wwn: Optional[str] = None):
        """
        :param str block_device: The path to the host device to use as the block device for this disk. 
               
               While `volume_id`, `url`, `file` and `block_device` are optional, it is intended that you use one of them.
        :param str file: The filename to use as the block device for this disk (read-only)
        :param bool scsi: Use a scsi controller for this disk.  The controller
               model is set to `virtio-scsi`
        :param str url: The http url to use as the block device for this disk (read-only)
        :param str volume_id: The volume id to use for this disk.
        :param str wwn: Specify a WWN to use for the disk if the disk is using
               a scsi controller, if not specified then a random wwn is generated for the disk
               
               
               ```python
               import pulumi
               import pulumi_libvirt as libvirt
               
               leap = libvirt.Volume("leap",
                   name="leap",
                   source="http://someurl/openSUSE_Leap-42.1.qcow2")
               mydisk = libvirt.Volume("mydisk",
                   name="mydisk",
                   base_volume_id=leap.id)
               domain1 = libvirt.Domain("domain1",
                   name="domain1",
                   disks=[
                       libvirt.DomainDiskArgs(
                           volume_id=mydisk.id,
                           scsi=True,
                       ),
                       libvirt.DomainDiskArgs(
                           url="http://foo.com/install.iso",
                       ),
                       libvirt.DomainDiskArgs(
                           file="/absolute/path/to/disk.iso",
                       ),
                       libvirt.DomainDiskArgs(
                           block_device="/dev/mapper/36005076802810e55400000000000145f",
                       ),
                   ])
               ```
               
               Also note that the `disk` block is actually a list of maps, so it is possible to
               declare several of them by using either the literal list and map syntax as in
               the following examples:
        """
        if block_device is not None:
            pulumi.set(__self__, "block_device", block_device)
        if file is not None:
            pulumi.set(__self__, "file", file)
        if scsi is not None:
            pulumi.set(__self__, "scsi", scsi)
        if url is not None:
            pulumi.set(__self__, "url", url)
        if volume_id is not None:
            pulumi.set(__self__, "volume_id", volume_id)
        if wwn is not None:
            pulumi.set(__self__, "wwn", wwn)

    @property
    @pulumi.getter(name="blockDevice")
    def block_device(self) -> Optional[str]:
        """
        The path to the host device to use as the block device for this disk. 

        While `volume_id`, `url`, `file` and `block_device` are optional, it is intended that you use one of them.
        """
        return pulumi.get(self, "block_device")

    @property
    @pulumi.getter
    def file(self) -> Optional[str]:
        """
        The filename to use as the block device for this disk (read-only)
        """
        return pulumi.get(self, "file")

    @property
    @pulumi.getter
    def scsi(self) -> Optional[bool]:
        """
        Use a scsi controller for this disk.  The controller
        model is set to `virtio-scsi`
        """
        return pulumi.get(self, "scsi")

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        """
        The http url to use as the block device for this disk (read-only)
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter(name="volumeId")
    def volume_id(self) -> Optional[str]:
        """
        The volume id to use for this disk.
        """
        return pulumi.get(self, "volume_id")

    @property
    @pulumi.getter
    def wwn(self) -> Optional[str]:
        """
        Specify a WWN to use for the disk if the disk is using
        a scsi controller, if not specified then a random wwn is generated for the disk


        ```python
        import pulumi
        import pulumi_libvirt as libvirt

        leap = libvirt.Volume("leap",
            name="leap",
            source="http://someurl/openSUSE_Leap-42.1.qcow2")
        mydisk = libvirt.Volume("mydisk",
            name="mydisk",
            base_volume_id=leap.id)
        domain1 = libvirt.Domain("domain1",
            name="domain1",
            disks=[
                libvirt.DomainDiskArgs(
                    volume_id=mydisk.id,
                    scsi=True,
                ),
                libvirt.DomainDiskArgs(
                    url="http://foo.com/install.iso",
                ),
                libvirt.DomainDiskArgs(
                    file="/absolute/path/to/disk.iso",
                ),
                libvirt.DomainDiskArgs(
                    block_device="/dev/mapper/36005076802810e55400000000000145f",
                ),
            ])
        ```

        Also note that the `disk` block is actually a list of maps, so it is possible to
        declare several of them by using either the literal list and map syntax as in
        the following examples:
        """
        return pulumi.get(self, "wwn")


@pulumi.output_type
class DomainFilesystem(dict):
    def __init__(__self__, *,
                 source: str,
                 target: str,
                 accessmode: Optional[str] = None,
                 readonly: Optional[bool] = None):
        """
        :param str source: the directory of the host to be shared with the guest.
        :param str target: an arbitrary string tag that is exported to the guest as a hint for
               where to mount the source.
        :param str accessmode: specifies the security mode for accessing the source. By default
               the `mapped` mode is chosen.
        :param bool readonly: enables exporting filesystem as a readonly mount for guest, by
               default read-only access is given.
               
               Example:
        """
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "target", target)
        if accessmode is not None:
            pulumi.set(__self__, "accessmode", accessmode)
        if readonly is not None:
            pulumi.set(__self__, "readonly", readonly)

    @property
    @pulumi.getter
    def source(self) -> str:
        """
        the directory of the host to be shared with the guest.
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def target(self) -> str:
        """
        an arbitrary string tag that is exported to the guest as a hint for
        where to mount the source.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def accessmode(self) -> Optional[str]:
        """
        specifies the security mode for accessing the source. By default
        the `mapped` mode is chosen.
        """
        return pulumi.get(self, "accessmode")

    @property
    @pulumi.getter
    def readonly(self) -> Optional[bool]:
        """
        enables exporting filesystem as a readonly mount for guest, by
        default read-only access is given.

        Example:
        """
        return pulumi.get(self, "readonly")


@pulumi.output_type
class DomainGraphics(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "listenAddress":
            suggest = "listen_address"
        elif key == "listenType":
            suggest = "listen_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainGraphics. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainGraphics.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainGraphics.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 autoport: Optional[bool] = None,
                 listen_address: Optional[str] = None,
                 listen_type: Optional[str] = None,
                 type: Optional[str] = None,
                 websocket: Optional[int] = None):
        """
        :param bool autoport: defaults to "yes"
        :param str listen_address: IP Address where the VNC listener should be started if
               `listen_type` is set to `address`. Defaults to 127.0.0.1
        :param str listen_type: "listen type", defaults to "none"
        :param str type: the type of graphics emulation (default is "spice")
        :param int websocket: Port to listen on for VNC WebSocket functionality (-1 meaning auto-allocation)
               
               On occasion we have found it necessary to set a `type` of `vnc` and a
               `listen_type` of `address` with certain builds of QEMU.
               
               With `listen_address` it is possible to specify a listener address for the virtual
               machines VNC server. Usually this is an IP of the host system.
               
               The `graphics` block will look as follows:
        """
        if autoport is not None:
            pulumi.set(__self__, "autoport", autoport)
        if listen_address is not None:
            pulumi.set(__self__, "listen_address", listen_address)
        if listen_type is not None:
            pulumi.set(__self__, "listen_type", listen_type)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if websocket is not None:
            pulumi.set(__self__, "websocket", websocket)

    @property
    @pulumi.getter
    def autoport(self) -> Optional[bool]:
        """
        defaults to "yes"
        """
        return pulumi.get(self, "autoport")

    @property
    @pulumi.getter(name="listenAddress")
    def listen_address(self) -> Optional[str]:
        """
        IP Address where the VNC listener should be started if
        `listen_type` is set to `address`. Defaults to 127.0.0.1
        """
        return pulumi.get(self, "listen_address")

    @property
    @pulumi.getter(name="listenType")
    def listen_type(self) -> Optional[str]:
        """
        "listen type", defaults to "none"
        """
        return pulumi.get(self, "listen_type")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        the type of graphics emulation (default is "spice")
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def websocket(self) -> Optional[int]:
        """
        Port to listen on for VNC WebSocket functionality (-1 meaning auto-allocation)

        On occasion we have found it necessary to set a `type` of `vnc` and a
        `listen_type` of `address` with certain builds of QEMU.

        With `listen_address` it is possible to specify a listener address for the virtual
        machines VNC server. Usually this is an IP of the host system.

        The `graphics` block will look as follows:
        """
        return pulumi.get(self, "websocket")


@pulumi.output_type
class DomainNetworkInterface(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "networkId":
            suggest = "network_id"
        elif key == "networkName":
            suggest = "network_name"
        elif key == "waitForLease":
            suggest = "wait_for_lease"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainNetworkInterface. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainNetworkInterface.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainNetworkInterface.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 addresses: Optional[Sequence[str]] = None,
                 bridge: Optional[str] = None,
                 hostname: Optional[str] = None,
                 mac: Optional[str] = None,
                 macvtap: Optional[str] = None,
                 network_id: Optional[str] = None,
                 network_name: Optional[str] = None,
                 passthrough: Optional[str] = None,
                 vepa: Optional[str] = None,
                 wait_for_lease: Optional[bool] = None):
        if addresses is not None:
            pulumi.set(__self__, "addresses", addresses)
        if bridge is not None:
            pulumi.set(__self__, "bridge", bridge)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if mac is not None:
            pulumi.set(__self__, "mac", mac)
        if macvtap is not None:
            pulumi.set(__self__, "macvtap", macvtap)
        if network_id is not None:
            pulumi.set(__self__, "network_id", network_id)
        if network_name is not None:
            pulumi.set(__self__, "network_name", network_name)
        if passthrough is not None:
            pulumi.set(__self__, "passthrough", passthrough)
        if vepa is not None:
            pulumi.set(__self__, "vepa", vepa)
        if wait_for_lease is not None:
            pulumi.set(__self__, "wait_for_lease", wait_for_lease)

    @property
    @pulumi.getter
    def addresses(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "addresses")

    @property
    @pulumi.getter
    def bridge(self) -> Optional[str]:
        return pulumi.get(self, "bridge")

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def mac(self) -> Optional[str]:
        return pulumi.get(self, "mac")

    @property
    @pulumi.getter
    def macvtap(self) -> Optional[str]:
        return pulumi.get(self, "macvtap")

    @property
    @pulumi.getter(name="networkId")
    def network_id(self) -> Optional[str]:
        return pulumi.get(self, "network_id")

    @property
    @pulumi.getter(name="networkName")
    def network_name(self) -> Optional[str]:
        return pulumi.get(self, "network_name")

    @property
    @pulumi.getter
    def passthrough(self) -> Optional[str]:
        return pulumi.get(self, "passthrough")

    @property
    @pulumi.getter
    def vepa(self) -> Optional[str]:
        return pulumi.get(self, "vepa")

    @property
    @pulumi.getter(name="waitForLease")
    def wait_for_lease(self) -> Optional[bool]:
        return pulumi.get(self, "wait_for_lease")


@pulumi.output_type
class DomainNvram(dict):
    def __init__(__self__, *,
                 file: str,
                 template: Optional[str] = None):
        pulumi.set(__self__, "file", file)
        if template is not None:
            pulumi.set(__self__, "template", template)

    @property
    @pulumi.getter
    def file(self) -> str:
        return pulumi.get(self, "file")

    @property
    @pulumi.getter
    def template(self) -> Optional[str]:
        return pulumi.get(self, "template")


@pulumi.output_type
class DomainTpm(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backendDevicePath":
            suggest = "backend_device_path"
        elif key == "backendEncryptionSecret":
            suggest = "backend_encryption_secret"
        elif key == "backendPersistentState":
            suggest = "backend_persistent_state"
        elif key == "backendType":
            suggest = "backend_type"
        elif key == "backendVersion":
            suggest = "backend_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainTpm. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainTpm.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainTpm.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backend_device_path: Optional[str] = None,
                 backend_encryption_secret: Optional[str] = None,
                 backend_persistent_state: Optional[bool] = None,
                 backend_type: Optional[str] = None,
                 backend_version: Optional[str] = None,
                 model: Optional[str] = None):
        """
        :param str backend_device_path: Path to TPM device on the host, ex: `/dev/tpm0`
               
               Additional attributes when `backend_type` is "emulator":
        :param str backend_encryption_secret: [Secret object](https://libvirt.org/formatsecret.html) for encrypting the TPM state
        :param bool backend_persistent_state: Keep the TPM state when a transient domain is powered off or undefined
        :param str backend_type: TPM backend, either `passthrough` or `emulator` (default: `emulator`)
               
               Additional attributes when `backend_type` is "passthrough":
        :param str backend_version: TPM version
        :param str model: TPM model provided to the guest
        """
        if backend_device_path is not None:
            pulumi.set(__self__, "backend_device_path", backend_device_path)
        if backend_encryption_secret is not None:
            pulumi.set(__self__, "backend_encryption_secret", backend_encryption_secret)
        if backend_persistent_state is not None:
            pulumi.set(__self__, "backend_persistent_state", backend_persistent_state)
        if backend_type is not None:
            pulumi.set(__self__, "backend_type", backend_type)
        if backend_version is not None:
            pulumi.set(__self__, "backend_version", backend_version)
        if model is not None:
            pulumi.set(__self__, "model", model)

    @property
    @pulumi.getter(name="backendDevicePath")
    def backend_device_path(self) -> Optional[str]:
        """
        Path to TPM device on the host, ex: `/dev/tpm0`

        Additional attributes when `backend_type` is "emulator":
        """
        return pulumi.get(self, "backend_device_path")

    @property
    @pulumi.getter(name="backendEncryptionSecret")
    def backend_encryption_secret(self) -> Optional[str]:
        """
        [Secret object](https://libvirt.org/formatsecret.html) for encrypting the TPM state
        """
        return pulumi.get(self, "backend_encryption_secret")

    @property
    @pulumi.getter(name="backendPersistentState")
    def backend_persistent_state(self) -> Optional[bool]:
        """
        Keep the TPM state when a transient domain is powered off or undefined
        """
        return pulumi.get(self, "backend_persistent_state")

    @property
    @pulumi.getter(name="backendType")
    def backend_type(self) -> Optional[str]:
        """
        TPM backend, either `passthrough` or `emulator` (default: `emulator`)

        Additional attributes when `backend_type` is "passthrough":
        """
        return pulumi.get(self, "backend_type")

    @property
    @pulumi.getter(name="backendVersion")
    def backend_version(self) -> Optional[str]:
        """
        TPM version
        """
        return pulumi.get(self, "backend_version")

    @property
    @pulumi.getter
    def model(self) -> Optional[str]:
        """
        TPM model provided to the guest
        """
        return pulumi.get(self, "model")


@pulumi.output_type
class DomainVideo(dict):
    def __init__(__self__, *,
                 type: Optional[str] = None):
        """
        :param str type: The type of hypervisor to use for the domain.  Defaults to `kvm`, other values can be found [here](https://libvirt.org/formatdomain.html#id1)
        """
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of hypervisor to use for the domain.  Defaults to `kvm`, other values can be found [here](https://libvirt.org/formatdomain.html#id1)
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class DomainXml(dict):
    def __init__(__self__, *,
                 xslt: Optional[str] = None):
        if xslt is not None:
            pulumi.set(__self__, "xslt", xslt)

    @property
    @pulumi.getter
    def xslt(self) -> Optional[str]:
        return pulumi.get(self, "xslt")


@pulumi.output_type
class NetworkDhcp(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class NetworkDns(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "localOnly":
            suggest = "local_only"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkDns. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkDns.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkDns.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 forwarders: Optional[Sequence['outputs.NetworkDnsForwarder']] = None,
                 hosts: Optional[Sequence['outputs.NetworkDnsHost']] = None,
                 local_only: Optional[bool] = None,
                 srvs: Optional[Sequence['outputs.NetworkDnsSrv']] = None):
        """
        :param Sequence['NetworkDnsForwarderArgs'] forwarders: Either `address`, `domain`, or both must be set
        :param Sequence['NetworkDnsHostArgs'] hosts: a DNS host entry block. You can have one or more of these
               blocks in your DNS definition. You must specify both `ip` and `hostname`.
               
               An advanced example of round-robin DNS (using DNS host templates) follows:
        :param bool local_only: true/false: true means 'do not forward unresolved requests for this domain to the part DNS server
        :param Sequence['NetworkDnsSrvArgs'] srvs: a DNS SRV entry block. You can have one or more of these blocks
               in your DNS definition. You must specify `service` and `protocol`.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if forwarders is not None:
            pulumi.set(__self__, "forwarders", forwarders)
        if hosts is not None:
            pulumi.set(__self__, "hosts", hosts)
        if local_only is not None:
            pulumi.set(__self__, "local_only", local_only)
        if srvs is not None:
            pulumi.set(__self__, "srvs", srvs)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def forwarders(self) -> Optional[Sequence['outputs.NetworkDnsForwarder']]:
        """
        Either `address`, `domain`, or both must be set
        """
        return pulumi.get(self, "forwarders")

    @property
    @pulumi.getter
    def hosts(self) -> Optional[Sequence['outputs.NetworkDnsHost']]:
        """
        a DNS host entry block. You can have one or more of these
        blocks in your DNS definition. You must specify both `ip` and `hostname`.

        An advanced example of round-robin DNS (using DNS host templates) follows:
        """
        return pulumi.get(self, "hosts")

    @property
    @pulumi.getter(name="localOnly")
    def local_only(self) -> Optional[bool]:
        """
        true/false: true means 'do not forward unresolved requests for this domain to the part DNS server
        """
        return pulumi.get(self, "local_only")

    @property
    @pulumi.getter
    def srvs(self) -> Optional[Sequence['outputs.NetworkDnsSrv']]:
        """
        a DNS SRV entry block. You can have one or more of these blocks
        in your DNS definition. You must specify `service` and `protocol`.
        """
        return pulumi.get(self, "srvs")


@pulumi.output_type
class NetworkDnsForwarder(dict):
    def __init__(__self__, *,
                 address: Optional[str] = None,
                 domain: Optional[str] = None):
        """
        :param str domain: The domain used by the DNS server.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if domain is not None:
            pulumi.set(__self__, "domain", domain)

    @property
    @pulumi.getter
    def address(self) -> Optional[str]:
        return pulumi.get(self, "address")

    @property
    @pulumi.getter
    def domain(self) -> Optional[str]:
        """
        The domain used by the DNS server.
        """
        return pulumi.get(self, "domain")


@pulumi.output_type
class NetworkDnsHost(dict):
    def __init__(__self__, *,
                 hostname: Optional[str] = None,
                 ip: Optional[str] = None):
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def ip(self) -> Optional[str]:
        return pulumi.get(self, "ip")


@pulumi.output_type
class NetworkDnsSrv(dict):
    def __init__(__self__, *,
                 domain: Optional[str] = None,
                 port: Optional[str] = None,
                 priority: Optional[str] = None,
                 protocol: Optional[str] = None,
                 service: Optional[str] = None,
                 target: Optional[str] = None,
                 weight: Optional[str] = None):
        """
        :param str domain: The domain used by the DNS server.
        """
        if domain is not None:
            pulumi.set(__self__, "domain", domain)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if service is not None:
            pulumi.set(__self__, "service", service)
        if target is not None:
            pulumi.set(__self__, "target", target)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def domain(self) -> Optional[str]:
        """
        The domain used by the DNS server.
        """
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter
    def port(self) -> Optional[str]:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def priority(self) -> Optional[str]:
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter
    def service(self) -> Optional[str]:
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def target(self) -> Optional[str]:
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def weight(self) -> Optional[str]:
        return pulumi.get(self, "weight")


@pulumi.output_type
class NetworkDnsmasqOptions(dict):
    def __init__(__self__, *,
                 options: Optional[Sequence['outputs.NetworkDnsmasqOptionsOption']] = None):
        if options is not None:
            pulumi.set(__self__, "options", options)

    @property
    @pulumi.getter
    def options(self) -> Optional[Sequence['outputs.NetworkDnsmasqOptionsOption']]:
        return pulumi.get(self, "options")


@pulumi.output_type
class NetworkDnsmasqOptionsOption(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "optionName":
            suggest = "option_name"
        elif key == "optionValue":
            suggest = "option_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkDnsmasqOptionsOption. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkDnsmasqOptionsOption.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkDnsmasqOptionsOption.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 option_name: Optional[str] = None,
                 option_value: Optional[str] = None):
        if option_name is not None:
            pulumi.set(__self__, "option_name", option_name)
        if option_value is not None:
            pulumi.set(__self__, "option_value", option_value)

    @property
    @pulumi.getter(name="optionName")
    def option_name(self) -> Optional[str]:
        return pulumi.get(self, "option_name")

    @property
    @pulumi.getter(name="optionValue")
    def option_value(self) -> Optional[str]:
        return pulumi.get(self, "option_value")


@pulumi.output_type
class NetworkRoute(dict):
    def __init__(__self__, *,
                 cidr: str,
                 gateway: str):
        pulumi.set(__self__, "cidr", cidr)
        pulumi.set(__self__, "gateway", gateway)

    @property
    @pulumi.getter
    def cidr(self) -> str:
        return pulumi.get(self, "cidr")

    @property
    @pulumi.getter
    def gateway(self) -> str:
        return pulumi.get(self, "gateway")


@pulumi.output_type
class NetworkXml(dict):
    def __init__(__self__, *,
                 xslt: Optional[str] = None):
        if xslt is not None:
            pulumi.set(__self__, "xslt", xslt)

    @property
    @pulumi.getter
    def xslt(self) -> Optional[str]:
        return pulumi.get(self, "xslt")


@pulumi.output_type
class PoolXml(dict):
    def __init__(__self__, *,
                 xslt: Optional[str] = None):
        if xslt is not None:
            pulumi.set(__self__, "xslt", xslt)

    @property
    @pulumi.getter
    def xslt(self) -> Optional[str]:
        return pulumi.get(self, "xslt")


@pulumi.output_type
class VolumeXml(dict):
    def __init__(__self__, *,
                 xslt: Optional[str] = None):
        if xslt is not None:
            pulumi.set(__self__, "xslt", xslt)

    @property
    @pulumi.getter
    def xslt(self) -> Optional[str]:
        return pulumi.get(self, "xslt")


