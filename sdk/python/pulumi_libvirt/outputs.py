# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from . import _utilities
from . import outputs

__all__ = [
    'DomainBootDevice',
    'DomainConsole',
    'DomainCpu',
    'DomainDisk',
    'DomainFilesystem',
    'DomainGraphics',
    'DomainNetworkInterface',
    'DomainNvram',
    'DomainTpm',
    'DomainVideo',
    'DomainXml',
    'NetworkDhcp',
    'NetworkDns',
    'NetworkDnsForwarder',
    'NetworkDnsHost',
    'NetworkDnsSrv',
    'NetworkDnsmasqOptions',
    'NetworkDnsmasqOptionsOption',
    'NetworkRoute',
    'NetworkXml',
    'PoolXml',
    'VolumeXml',
]

@pulumi.output_type
class DomainBootDevice(dict):
    def __init__(__self__, *,
                 devs: Optional[Sequence[str]] = None):
        DomainBootDevice._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            devs=devs,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             devs: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if devs is not None:
            _setter("devs", devs)

    @property
    @pulumi.getter
    def devs(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "devs")


@pulumi.output_type
class DomainConsole(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetPort":
            suggest = "target_port"
        elif key == "sourceHost":
            suggest = "source_host"
        elif key == "sourcePath":
            suggest = "source_path"
        elif key == "sourceService":
            suggest = "source_service"
        elif key == "targetType":
            suggest = "target_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainConsole. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainConsole.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainConsole.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 target_port: str,
                 type: str,
                 source_host: Optional[str] = None,
                 source_path: Optional[str] = None,
                 source_service: Optional[str] = None,
                 target_type: Optional[str] = None):
        """
        :param str target_port: Target port
        :param str type: Console device type. Valid values are "pty" and "tcp".
        :param str source_host: IP address to listen on. Defaults to 127.0.0.1.
        :param str source_path: Source path
               
               Additional attributes when type is "tcp":
        :param str source_service: Port number or a service name. Defaults to a
               random port.
               
               Note that you can repeat the `console` block to create more than one console.
               This works the same way as with the `disk` blocks (see above).
               
               See [libvirt Domain XML Console element](https://libvirt.org/formatdomain.html#elementsConsole)
               for more information.
        :param str target_type: for the first console and defaults to `serial`.
               Subsequent `console` blocks must have a different type - usually `virtio`.
               
               Additional attributes when type is "pty":
        """
        DomainConsole._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            target_port=target_port,
            type=type,
            source_host=source_host,
            source_path=source_path,
            source_service=source_service,
            target_type=target_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             target_port: str,
             type: str,
             source_host: Optional[str] = None,
             source_path: Optional[str] = None,
             source_service: Optional[str] = None,
             target_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("target_port", target_port)
        _setter("type", type)
        if source_host is not None:
            _setter("source_host", source_host)
        if source_path is not None:
            _setter("source_path", source_path)
        if source_service is not None:
            _setter("source_service", source_service)
        if target_type is not None:
            _setter("target_type", target_type)

    @property
    @pulumi.getter(name="targetPort")
    def target_port(self) -> str:
        """
        Target port
        """
        return pulumi.get(self, "target_port")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Console device type. Valid values are "pty" and "tcp".
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="sourceHost")
    def source_host(self) -> Optional[str]:
        """
        IP address to listen on. Defaults to 127.0.0.1.
        """
        return pulumi.get(self, "source_host")

    @property
    @pulumi.getter(name="sourcePath")
    def source_path(self) -> Optional[str]:
        """
        Source path

        Additional attributes when type is "tcp":
        """
        return pulumi.get(self, "source_path")

    @property
    @pulumi.getter(name="sourceService")
    def source_service(self) -> Optional[str]:
        """
        Port number or a service name. Defaults to a
        random port.

        Note that you can repeat the `console` block to create more than one console.
        This works the same way as with the `disk` blocks (see above).

        See [libvirt Domain XML Console element](https://libvirt.org/formatdomain.html#elementsConsole)
        for more information.
        """
        return pulumi.get(self, "source_service")

    @property
    @pulumi.getter(name="targetType")
    def target_type(self) -> Optional[str]:
        """
        for the first console and defaults to `serial`.
        Subsequent `console` blocks must have a different type - usually `virtio`.

        Additional attributes when type is "pty":
        """
        return pulumi.get(self, "target_type")


@pulumi.output_type
class DomainCpu(dict):
    def __init__(__self__, *,
                 mode: Optional[str] = None):
        DomainCpu._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            mode=mode,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             mode: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if mode is not None:
            _setter("mode", mode)

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        return pulumi.get(self, "mode")


@pulumi.output_type
class DomainDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "blockDevice":
            suggest = "block_device"
        elif key == "volumeId":
            suggest = "volume_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 block_device: Optional[str] = None,
                 file: Optional[str] = None,
                 scsi: Optional[bool] = None,
                 url: Optional[str] = None,
                 volume_id: Optional[str] = None,
                 wwn: Optional[str] = None):
        """
        :param str block_device: The path to the host device to use as the block device for this disk. 
               
               While `volume_id`, `url`, `file` and `block_device` are optional, it is intended that you use one of them.
        :param str file: The filename to use as the block device for this disk (read-only)
        :param bool scsi: Use a scsi controller for this disk.  The controller
               model is set to `virtio-scsi`
        :param str url: The http url to use as the block device for this disk (read-only)
        :param str volume_id: The volume id to use for this disk.
        :param str wwn: Specify a WWN to use for the disk if the disk is using
               a scsi controller, if not specified then a random wwn is generated for the disk
               
               
               ```python
               import pulumi
               import pulumi_libvirt as libvirt
               
               leap = libvirt.Volume("leap", source="http://someurl/openSUSE_Leap-42.1.qcow2")
               mydisk = libvirt.Volume("mydisk", base_volume_id=leap.id)
               domain1 = libvirt.Domain("domain1", disks=[
                   libvirt.DomainDiskArgs(
                       volume_id=mydisk.id,
                       scsi=True,
                   ),
                   libvirt.DomainDiskArgs(
                       url="http://foo.com/install.iso",
                   ),
                   libvirt.DomainDiskArgs(
                       file="/absolute/path/to/disk.iso",
                   ),
                   libvirt.DomainDiskArgs(
                       block_device="/dev/mapper/36005076802810e55400000000000145f",
                   ),
               ])
               ```
               
               Also note that the `disk` block is actually a list of maps, so it is possible to
               declare several of them by using either the literal list and map syntax as in
               the following examples:
        """
        DomainDisk._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            block_device=block_device,
            file=file,
            scsi=scsi,
            url=url,
            volume_id=volume_id,
            wwn=wwn,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             block_device: Optional[str] = None,
             file: Optional[str] = None,
             scsi: Optional[bool] = None,
             url: Optional[str] = None,
             volume_id: Optional[str] = None,
             wwn: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if block_device is not None:
            _setter("block_device", block_device)
        if file is not None:
            _setter("file", file)
        if scsi is not None:
            _setter("scsi", scsi)
        if url is not None:
            _setter("url", url)
        if volume_id is not None:
            _setter("volume_id", volume_id)
        if wwn is not None:
            _setter("wwn", wwn)

    @property
    @pulumi.getter(name="blockDevice")
    def block_device(self) -> Optional[str]:
        """
        The path to the host device to use as the block device for this disk. 

        While `volume_id`, `url`, `file` and `block_device` are optional, it is intended that you use one of them.
        """
        return pulumi.get(self, "block_device")

    @property
    @pulumi.getter
    def file(self) -> Optional[str]:
        """
        The filename to use as the block device for this disk (read-only)
        """
        return pulumi.get(self, "file")

    @property
    @pulumi.getter
    def scsi(self) -> Optional[bool]:
        """
        Use a scsi controller for this disk.  The controller
        model is set to `virtio-scsi`
        """
        return pulumi.get(self, "scsi")

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        """
        The http url to use as the block device for this disk (read-only)
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter(name="volumeId")
    def volume_id(self) -> Optional[str]:
        """
        The volume id to use for this disk.
        """
        return pulumi.get(self, "volume_id")

    @property
    @pulumi.getter
    def wwn(self) -> Optional[str]:
        """
        Specify a WWN to use for the disk if the disk is using
        a scsi controller, if not specified then a random wwn is generated for the disk


        ```python
        import pulumi
        import pulumi_libvirt as libvirt

        leap = libvirt.Volume("leap", source="http://someurl/openSUSE_Leap-42.1.qcow2")
        mydisk = libvirt.Volume("mydisk", base_volume_id=leap.id)
        domain1 = libvirt.Domain("domain1", disks=[
            libvirt.DomainDiskArgs(
                volume_id=mydisk.id,
                scsi=True,
            ),
            libvirt.DomainDiskArgs(
                url="http://foo.com/install.iso",
            ),
            libvirt.DomainDiskArgs(
                file="/absolute/path/to/disk.iso",
            ),
            libvirt.DomainDiskArgs(
                block_device="/dev/mapper/36005076802810e55400000000000145f",
            ),
        ])
        ```

        Also note that the `disk` block is actually a list of maps, so it is possible to
        declare several of them by using either the literal list and map syntax as in
        the following examples:
        """
        return pulumi.get(self, "wwn")


@pulumi.output_type
class DomainFilesystem(dict):
    def __init__(__self__, *,
                 source: str,
                 target: str,
                 accessmode: Optional[str] = None,
                 readonly: Optional[bool] = None):
        """
        :param str source: the directory of the host to be shared with the guest.
        :param str target: an arbitrary string tag that is exported to the guest as a hint for
               where to mount the source.
        :param str accessmode: specifies the security mode for accessing the source. By default
               the `mapped` mode is chosen.
        :param bool readonly: enables exporting filesystem as a readonly mount for guest, by
               default read-only access is given.
               
               Example:
               
               ```python
               import pulumi
               ```
               
               The exported filesystems can be mounted inside of the guest in this way:
               
               
               This can be automated inside of `/etc/fstab`:
        """
        DomainFilesystem._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            source=source,
            target=target,
            accessmode=accessmode,
            readonly=readonly,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             source: str,
             target: str,
             accessmode: Optional[str] = None,
             readonly: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("source", source)
        _setter("target", target)
        if accessmode is not None:
            _setter("accessmode", accessmode)
        if readonly is not None:
            _setter("readonly", readonly)

    @property
    @pulumi.getter
    def source(self) -> str:
        """
        the directory of the host to be shared with the guest.
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def target(self) -> str:
        """
        an arbitrary string tag that is exported to the guest as a hint for
        where to mount the source.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def accessmode(self) -> Optional[str]:
        """
        specifies the security mode for accessing the source. By default
        the `mapped` mode is chosen.
        """
        return pulumi.get(self, "accessmode")

    @property
    @pulumi.getter
    def readonly(self) -> Optional[bool]:
        """
        enables exporting filesystem as a readonly mount for guest, by
        default read-only access is given.

        Example:

        ```python
        import pulumi
        ```

        The exported filesystems can be mounted inside of the guest in this way:


        This can be automated inside of `/etc/fstab`:
        """
        return pulumi.get(self, "readonly")


@pulumi.output_type
class DomainGraphics(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "listenAddress":
            suggest = "listen_address"
        elif key == "listenType":
            suggest = "listen_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainGraphics. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainGraphics.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainGraphics.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 autoport: Optional[bool] = None,
                 listen_address: Optional[str] = None,
                 listen_type: Optional[str] = None,
                 type: Optional[str] = None,
                 websocket: Optional[int] = None):
        """
        :param bool autoport: defaults to "yes"
        :param str listen_address: IP Address where the VNC listener should be started if
               `listen_type` is set to `address`. Defaults to 127.0.0.1
        :param str listen_type: "listen type", defaults to "none"
        :param str type: Console device type. Valid values are "pty" and "tcp".
        :param int websocket: Port to listen on for VNC WebSocket functionality (-1 meaning auto-allocation)
               
               On occasion we have found it necessary to set a `type` of `vnc` and a
               `listen_type` of `address` with certain builds of QEMU.
               
               With `listen_address` it is possible to specify a listener address for the virtual
               machines VNC server. Usually this is an IP of the host system.
               
               The `graphics` block will look as follows:
               
               
               The video card type can be changed from libvirt default `cirrus` to
               `vga` or others as described in [Video Card Elements](https://libvirt.org/formatdomain.html#elementsVideo)
               
               
               > **Note well:** the `graphics` block is ignored for the architectures
               `s390x` and `ppc64`.
        """
        DomainGraphics._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            autoport=autoport,
            listen_address=listen_address,
            listen_type=listen_type,
            type=type,
            websocket=websocket,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             autoport: Optional[bool] = None,
             listen_address: Optional[str] = None,
             listen_type: Optional[str] = None,
             type: Optional[str] = None,
             websocket: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if autoport is not None:
            _setter("autoport", autoport)
        if listen_address is not None:
            _setter("listen_address", listen_address)
        if listen_type is not None:
            _setter("listen_type", listen_type)
        if type is not None:
            _setter("type", type)
        if websocket is not None:
            _setter("websocket", websocket)

    @property
    @pulumi.getter
    def autoport(self) -> Optional[bool]:
        """
        defaults to "yes"
        """
        return pulumi.get(self, "autoport")

    @property
    @pulumi.getter(name="listenAddress")
    def listen_address(self) -> Optional[str]:
        """
        IP Address where the VNC listener should be started if
        `listen_type` is set to `address`. Defaults to 127.0.0.1
        """
        return pulumi.get(self, "listen_address")

    @property
    @pulumi.getter(name="listenType")
    def listen_type(self) -> Optional[str]:
        """
        "listen type", defaults to "none"
        """
        return pulumi.get(self, "listen_type")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Console device type. Valid values are "pty" and "tcp".
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def websocket(self) -> Optional[int]:
        """
        Port to listen on for VNC WebSocket functionality (-1 meaning auto-allocation)

        On occasion we have found it necessary to set a `type` of `vnc` and a
        `listen_type` of `address` with certain builds of QEMU.

        With `listen_address` it is possible to specify a listener address for the virtual
        machines VNC server. Usually this is an IP of the host system.

        The `graphics` block will look as follows:


        The video card type can be changed from libvirt default `cirrus` to
        `vga` or others as described in [Video Card Elements](https://libvirt.org/formatdomain.html#elementsVideo)


        > **Note well:** the `graphics` block is ignored for the architectures
        `s390x` and `ppc64`.
        """
        return pulumi.get(self, "websocket")


@pulumi.output_type
class DomainNetworkInterface(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "networkId":
            suggest = "network_id"
        elif key == "networkName":
            suggest = "network_name"
        elif key == "waitForLease":
            suggest = "wait_for_lease"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainNetworkInterface. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainNetworkInterface.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainNetworkInterface.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 addresses: Optional[Sequence[str]] = None,
                 bridge: Optional[str] = None,
                 hostname: Optional[str] = None,
                 mac: Optional[str] = None,
                 macvtap: Optional[str] = None,
                 network_id: Optional[str] = None,
                 network_name: Optional[str] = None,
                 passthrough: Optional[str] = None,
                 vepa: Optional[str] = None,
                 wait_for_lease: Optional[bool] = None):
        """
        :param Sequence[str] addresses: An IP address for this domain in this network.
        :param str bridge: Provides a bridge from the VM directly to the LAN. This assumes
               there is a bridge device on the host which has one or more of the hosts
               physical NICs enslaved. The guest VM will have an associated _tun_ device
               created and enslaved to the bridge. The IP range / network configuration is
               whatever is used on the LAN. This provides the guest VM full incoming &
               outgoing net access just like a physical machine.
        :param str hostname: A hostname that will be assigned to this domain
               resource in this network.
        :param str mac: The specific MAC address to use for this interface.
        :param str macvtap: Packets whose destination is on the same host as where they
               originate from are directly delivered to the target macvtap device. Both
               origin and destination devices need to be in bridge mode for direct delivery.
               If either one of them is in vepa mode, a VEPA capable bridge is required.
        :param str passthrough: This feature attaches a virtual function of a SRIOV capable
               NIC directly to a VM without losing the migration capability. All packets are
               sent to the VF/IF of the configured network device. Depending on the
               capabilities of the device additional prerequisites or limitations may apply;
               for example, on Linux this requires kernel 2.6.38 or newer.
               
               Example of a `macvtap` interface:
               
               
               **Warning:** the [Qemu guest agent](http://wiki.libvirt.org/page/Qemu_guest_agent)
               must be installed and running inside of the domain in order to discover the IP
               addresses of all the network interfaces attached to a LAN.
        :param str vepa: All VMs' packets are sent to the external bridge. Packets whose
               destination is a VM on the same host as where the packet originates from are
               sent back to the host by the VEPA capable bridge (today's bridges are
               typically not VEPA capable).
        :param bool wait_for_lease: When creating the domain resource, wait until the
               network interface gets a DHCP lease from libvirt, so that the computed IP
               addresses will be available when the domain is up and the plan applied.
               
               When connecting to a LAN, users can specify a target device with:
        """
        DomainNetworkInterface._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            addresses=addresses,
            bridge=bridge,
            hostname=hostname,
            mac=mac,
            macvtap=macvtap,
            network_id=network_id,
            network_name=network_name,
            passthrough=passthrough,
            vepa=vepa,
            wait_for_lease=wait_for_lease,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             addresses: Optional[Sequence[str]] = None,
             bridge: Optional[str] = None,
             hostname: Optional[str] = None,
             mac: Optional[str] = None,
             macvtap: Optional[str] = None,
             network_id: Optional[str] = None,
             network_name: Optional[str] = None,
             passthrough: Optional[str] = None,
             vepa: Optional[str] = None,
             wait_for_lease: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if addresses is not None:
            _setter("addresses", addresses)
        if bridge is not None:
            _setter("bridge", bridge)
        if hostname is not None:
            _setter("hostname", hostname)
        if mac is not None:
            _setter("mac", mac)
        if macvtap is not None:
            _setter("macvtap", macvtap)
        if network_id is not None:
            _setter("network_id", network_id)
        if network_name is not None:
            _setter("network_name", network_name)
        if passthrough is not None:
            _setter("passthrough", passthrough)
        if vepa is not None:
            _setter("vepa", vepa)
        if wait_for_lease is not None:
            _setter("wait_for_lease", wait_for_lease)

    @property
    @pulumi.getter
    def addresses(self) -> Optional[Sequence[str]]:
        """
        An IP address for this domain in this network.
        """
        return pulumi.get(self, "addresses")

    @property
    @pulumi.getter
    def bridge(self) -> Optional[str]:
        """
        Provides a bridge from the VM directly to the LAN. This assumes
        there is a bridge device on the host which has one or more of the hosts
        physical NICs enslaved. The guest VM will have an associated _tun_ device
        created and enslaved to the bridge. The IP range / network configuration is
        whatever is used on the LAN. This provides the guest VM full incoming &
        outgoing net access just like a physical machine.
        """
        return pulumi.get(self, "bridge")

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        """
        A hostname that will be assigned to this domain
        resource in this network.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def mac(self) -> Optional[str]:
        """
        The specific MAC address to use for this interface.
        """
        return pulumi.get(self, "mac")

    @property
    @pulumi.getter
    def macvtap(self) -> Optional[str]:
        """
        Packets whose destination is on the same host as where they
        originate from are directly delivered to the target macvtap device. Both
        origin and destination devices need to be in bridge mode for direct delivery.
        If either one of them is in vepa mode, a VEPA capable bridge is required.
        """
        return pulumi.get(self, "macvtap")

    @property
    @pulumi.getter(name="networkId")
    def network_id(self) -> Optional[str]:
        return pulumi.get(self, "network_id")

    @property
    @pulumi.getter(name="networkName")
    def network_name(self) -> Optional[str]:
        return pulumi.get(self, "network_name")

    @property
    @pulumi.getter
    def passthrough(self) -> Optional[str]:
        """
        This feature attaches a virtual function of a SRIOV capable
        NIC directly to a VM without losing the migration capability. All packets are
        sent to the VF/IF of the configured network device. Depending on the
        capabilities of the device additional prerequisites or limitations may apply;
        for example, on Linux this requires kernel 2.6.38 or newer.

        Example of a `macvtap` interface:


        **Warning:** the [Qemu guest agent](http://wiki.libvirt.org/page/Qemu_guest_agent)
        must be installed and running inside of the domain in order to discover the IP
        addresses of all the network interfaces attached to a LAN.
        """
        return pulumi.get(self, "passthrough")

    @property
    @pulumi.getter
    def vepa(self) -> Optional[str]:
        """
        All VMs' packets are sent to the external bridge. Packets whose
        destination is a VM on the same host as where the packet originates from are
        sent back to the host by the VEPA capable bridge (today's bridges are
        typically not VEPA capable).
        """
        return pulumi.get(self, "vepa")

    @property
    @pulumi.getter(name="waitForLease")
    def wait_for_lease(self) -> Optional[bool]:
        """
        When creating the domain resource, wait until the
        network interface gets a DHCP lease from libvirt, so that the computed IP
        addresses will be available when the domain is up and the plan applied.

        When connecting to a LAN, users can specify a target device with:
        """
        return pulumi.get(self, "wait_for_lease")


@pulumi.output_type
class DomainNvram(dict):
    def __init__(__self__, *,
                 file: str,
                 template: Optional[str] = None):
        """
        :param str file: The filename to use as the block device for this disk (read-only)
        :param str template: path to the file used to override variables from the master NVRAM
               store.
               
               So you should typically use the firmware as this,
               
               
               and `/etc/libvirt/qemu.conf` should contain:
               
               ```python
               import pulumi
               ```
               
               In case you need (or want) to specify the path for the NVRAM store, the domain definition should
               look like this:
               
               
               Finally, if you want the initial values for the NVRAM to be overridden by custom initial values
               coming from a template, the domain definition should look like this:
        """
        DomainNvram._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            file=file,
            template=template,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             file: str,
             template: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("file", file)
        if template is not None:
            _setter("template", template)

    @property
    @pulumi.getter
    def file(self) -> str:
        """
        The filename to use as the block device for this disk (read-only)
        """
        return pulumi.get(self, "file")

    @property
    @pulumi.getter
    def template(self) -> Optional[str]:
        """
        path to the file used to override variables from the master NVRAM
        store.

        So you should typically use the firmware as this,


        and `/etc/libvirt/qemu.conf` should contain:

        ```python
        import pulumi
        ```

        In case you need (or want) to specify the path for the NVRAM store, the domain definition should
        look like this:


        Finally, if you want the initial values for the NVRAM to be overridden by custom initial values
        coming from a template, the domain definition should look like this:
        """
        return pulumi.get(self, "template")


@pulumi.output_type
class DomainTpm(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backendDevicePath":
            suggest = "backend_device_path"
        elif key == "backendEncryptionSecret":
            suggest = "backend_encryption_secret"
        elif key == "backendPersistentState":
            suggest = "backend_persistent_state"
        elif key == "backendType":
            suggest = "backend_type"
        elif key == "backendVersion":
            suggest = "backend_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainTpm. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainTpm.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainTpm.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backend_device_path: Optional[str] = None,
                 backend_encryption_secret: Optional[str] = None,
                 backend_persistent_state: Optional[bool] = None,
                 backend_type: Optional[str] = None,
                 backend_version: Optional[str] = None,
                 model: Optional[str] = None):
        """
        :param str backend_device_path: Path to TPM device on the host, ex: `/dev/tpm0`
               
               Additional attributes when `backend_type` is "emulator":
        :param str backend_encryption_secret: [Secret object](https://libvirt.org/formatsecret.html) for encrypting the TPM state
        :param bool backend_persistent_state: Keep the TPM state when a transient domain is powered off or undefined
        :param str backend_type: TPM backend, either `passthrough` or `emulator` (default: `emulator`)
               
               Additional attributes when `backend_type` is "passthrough":
        :param str backend_version: TPM version
        :param str model: TPM model provided to the guest
        """
        DomainTpm._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            backend_device_path=backend_device_path,
            backend_encryption_secret=backend_encryption_secret,
            backend_persistent_state=backend_persistent_state,
            backend_type=backend_type,
            backend_version=backend_version,
            model=model,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             backend_device_path: Optional[str] = None,
             backend_encryption_secret: Optional[str] = None,
             backend_persistent_state: Optional[bool] = None,
             backend_type: Optional[str] = None,
             backend_version: Optional[str] = None,
             model: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if backend_device_path is not None:
            _setter("backend_device_path", backend_device_path)
        if backend_encryption_secret is not None:
            _setter("backend_encryption_secret", backend_encryption_secret)
        if backend_persistent_state is not None:
            _setter("backend_persistent_state", backend_persistent_state)
        if backend_type is not None:
            _setter("backend_type", backend_type)
        if backend_version is not None:
            _setter("backend_version", backend_version)
        if model is not None:
            _setter("model", model)

    @property
    @pulumi.getter(name="backendDevicePath")
    def backend_device_path(self) -> Optional[str]:
        """
        Path to TPM device on the host, ex: `/dev/tpm0`

        Additional attributes when `backend_type` is "emulator":
        """
        return pulumi.get(self, "backend_device_path")

    @property
    @pulumi.getter(name="backendEncryptionSecret")
    def backend_encryption_secret(self) -> Optional[str]:
        """
        [Secret object](https://libvirt.org/formatsecret.html) for encrypting the TPM state
        """
        return pulumi.get(self, "backend_encryption_secret")

    @property
    @pulumi.getter(name="backendPersistentState")
    def backend_persistent_state(self) -> Optional[bool]:
        """
        Keep the TPM state when a transient domain is powered off or undefined
        """
        return pulumi.get(self, "backend_persistent_state")

    @property
    @pulumi.getter(name="backendType")
    def backend_type(self) -> Optional[str]:
        """
        TPM backend, either `passthrough` or `emulator` (default: `emulator`)

        Additional attributes when `backend_type` is "passthrough":
        """
        return pulumi.get(self, "backend_type")

    @property
    @pulumi.getter(name="backendVersion")
    def backend_version(self) -> Optional[str]:
        """
        TPM version
        """
        return pulumi.get(self, "backend_version")

    @property
    @pulumi.getter
    def model(self) -> Optional[str]:
        """
        TPM model provided to the guest
        """
        return pulumi.get(self, "model")


@pulumi.output_type
class DomainVideo(dict):
    def __init__(__self__, *,
                 type: Optional[str] = None):
        """
        :param str type: Console device type. Valid values are "pty" and "tcp".
        """
        DomainVideo._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Console device type. Valid values are "pty" and "tcp".
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class DomainXml(dict):
    def __init__(__self__, *,
                 xslt: Optional[str] = None):
        DomainXml._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            xslt=xslt,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             xslt: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if xslt is not None:
            _setter("xslt", xslt)

    @property
    @pulumi.getter
    def xslt(self) -> Optional[str]:
        return pulumi.get(self, "xslt")


@pulumi.output_type
class NetworkDhcp(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None):
        """
        :param bool enabled: when false, disable the DHCP server
        """
        NetworkDhcp._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if enabled is not None:
            _setter("enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        when false, disable the DHCP server
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class NetworkDns(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "localOnly":
            suggest = "local_only"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkDns. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkDns.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkDns.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 forwarders: Optional[Sequence['outputs.NetworkDnsForwarder']] = None,
                 hosts: Optional[Sequence['outputs.NetworkDnsHost']] = None,
                 local_only: Optional[bool] = None,
                 srvs: Optional[Sequence['outputs.NetworkDnsSrv']] = None):
        """
        :param bool enabled: when false, disable the DHCP server
        :param Sequence['NetworkDnsForwarderArgs'] forwarders: Either `address`, `domain`, or both must be set
        :param Sequence['NetworkDnsHostArgs'] hosts: a DNS host entry block. You can have one or more of these
               blocks in your DNS definition. You must specify both `ip` and `hostname`.
               
               An advanced example of round-robin DNS (using DNS host templates) follows:
               
               
               An advanced example of setting up multiple SRV records using DNS SRV templates is:
        :param bool local_only: true/false: true means 'do not forward unresolved requests for this domain to the part DNS server
        :param Sequence['NetworkDnsSrvArgs'] srvs: a DNS SRV entry block. You can have one or more of these blocks
               in your DNS definition. You must specify `service` and `protocol`.
        """
        NetworkDns._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
            forwarders=forwarders,
            hosts=hosts,
            local_only=local_only,
            srvs=srvs,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: Optional[bool] = None,
             forwarders: Optional[Sequence['outputs.NetworkDnsForwarder']] = None,
             hosts: Optional[Sequence['outputs.NetworkDnsHost']] = None,
             local_only: Optional[bool] = None,
             srvs: Optional[Sequence['outputs.NetworkDnsSrv']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if enabled is not None:
            _setter("enabled", enabled)
        if forwarders is not None:
            _setter("forwarders", forwarders)
        if hosts is not None:
            _setter("hosts", hosts)
        if local_only is not None:
            _setter("local_only", local_only)
        if srvs is not None:
            _setter("srvs", srvs)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        when false, disable the DHCP server
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def forwarders(self) -> Optional[Sequence['outputs.NetworkDnsForwarder']]:
        """
        Either `address`, `domain`, or both must be set
        """
        return pulumi.get(self, "forwarders")

    @property
    @pulumi.getter
    def hosts(self) -> Optional[Sequence['outputs.NetworkDnsHost']]:
        """
        a DNS host entry block. You can have one or more of these
        blocks in your DNS definition. You must specify both `ip` and `hostname`.

        An advanced example of round-robin DNS (using DNS host templates) follows:


        An advanced example of setting up multiple SRV records using DNS SRV templates is:
        """
        return pulumi.get(self, "hosts")

    @property
    @pulumi.getter(name="localOnly")
    def local_only(self) -> Optional[bool]:
        """
        true/false: true means 'do not forward unresolved requests for this domain to the part DNS server
        """
        return pulumi.get(self, "local_only")

    @property
    @pulumi.getter
    def srvs(self) -> Optional[Sequence['outputs.NetworkDnsSrv']]:
        """
        a DNS SRV entry block. You can have one or more of these blocks
        in your DNS definition. You must specify `service` and `protocol`.
        """
        return pulumi.get(self, "srvs")


@pulumi.output_type
class NetworkDnsForwarder(dict):
    def __init__(__self__, *,
                 address: Optional[str] = None,
                 domain: Optional[str] = None):
        """
        :param str domain: The domain used by the DNS server.
        """
        NetworkDnsForwarder._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            address=address,
            domain=domain,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             address: Optional[str] = None,
             domain: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if address is not None:
            _setter("address", address)
        if domain is not None:
            _setter("domain", domain)

    @property
    @pulumi.getter
    def address(self) -> Optional[str]:
        return pulumi.get(self, "address")

    @property
    @pulumi.getter
    def domain(self) -> Optional[str]:
        """
        The domain used by the DNS server.
        """
        return pulumi.get(self, "domain")


@pulumi.output_type
class NetworkDnsHost(dict):
    def __init__(__self__, *,
                 hostname: Optional[str] = None,
                 ip: Optional[str] = None):
        NetworkDnsHost._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            hostname=hostname,
            ip=ip,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             hostname: Optional[str] = None,
             ip: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if hostname is not None:
            _setter("hostname", hostname)
        if ip is not None:
            _setter("ip", ip)

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def ip(self) -> Optional[str]:
        return pulumi.get(self, "ip")


@pulumi.output_type
class NetworkDnsSrv(dict):
    def __init__(__self__, *,
                 domain: Optional[str] = None,
                 port: Optional[str] = None,
                 priority: Optional[str] = None,
                 protocol: Optional[str] = None,
                 service: Optional[str] = None,
                 target: Optional[str] = None,
                 weight: Optional[str] = None):
        """
        :param str domain: The domain used by the DNS server.
        """
        NetworkDnsSrv._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            domain=domain,
            port=port,
            priority=priority,
            protocol=protocol,
            service=service,
            target=target,
            weight=weight,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             domain: Optional[str] = None,
             port: Optional[str] = None,
             priority: Optional[str] = None,
             protocol: Optional[str] = None,
             service: Optional[str] = None,
             target: Optional[str] = None,
             weight: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if domain is not None:
            _setter("domain", domain)
        if port is not None:
            _setter("port", port)
        if priority is not None:
            _setter("priority", priority)
        if protocol is not None:
            _setter("protocol", protocol)
        if service is not None:
            _setter("service", service)
        if target is not None:
            _setter("target", target)
        if weight is not None:
            _setter("weight", weight)

    @property
    @pulumi.getter
    def domain(self) -> Optional[str]:
        """
        The domain used by the DNS server.
        """
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter
    def port(self) -> Optional[str]:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def priority(self) -> Optional[str]:
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter
    def service(self) -> Optional[str]:
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def target(self) -> Optional[str]:
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def weight(self) -> Optional[str]:
        return pulumi.get(self, "weight")


@pulumi.output_type
class NetworkDnsmasqOptions(dict):
    def __init__(__self__, *,
                 options: Optional[Sequence['outputs.NetworkDnsmasqOptionsOption']] = None):
        """
        :param Sequence['NetworkDnsmasqOptionsOptionArgs'] options: a Dnsmasq option entry block. You can have one or more of these
               blocks in your definition. You must specify `option_name` while `option_value` is
               optional to support value-less options.
               
               An example of setting Dnsmasq options (using Dnsmasq option templates) follows:
        """
        NetworkDnsmasqOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            options=options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             options: Optional[Sequence['outputs.NetworkDnsmasqOptionsOption']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if options is not None:
            _setter("options", options)

    @property
    @pulumi.getter
    def options(self) -> Optional[Sequence['outputs.NetworkDnsmasqOptionsOption']]:
        """
        a Dnsmasq option entry block. You can have one or more of these
        blocks in your definition. You must specify `option_name` while `option_value` is
        optional to support value-less options.

        An example of setting Dnsmasq options (using Dnsmasq option templates) follows:
        """
        return pulumi.get(self, "options")


@pulumi.output_type
class NetworkDnsmasqOptionsOption(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "optionName":
            suggest = "option_name"
        elif key == "optionValue":
            suggest = "option_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkDnsmasqOptionsOption. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkDnsmasqOptionsOption.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkDnsmasqOptionsOption.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 option_name: Optional[str] = None,
                 option_value: Optional[str] = None):
        NetworkDnsmasqOptionsOption._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            option_name=option_name,
            option_value=option_value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             option_name: Optional[str] = None,
             option_value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if option_name is not None:
            _setter("option_name", option_name)
        if option_value is not None:
            _setter("option_value", option_value)

    @property
    @pulumi.getter(name="optionName")
    def option_name(self) -> Optional[str]:
        return pulumi.get(self, "option_name")

    @property
    @pulumi.getter(name="optionValue")
    def option_value(self) -> Optional[str]:
        return pulumi.get(self, "option_value")


@pulumi.output_type
class NetworkRoute(dict):
    def __init__(__self__, *,
                 cidr: str,
                 gateway: str):
        NetworkRoute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cidr=cidr,
            gateway=gateway,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cidr: str,
             gateway: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("cidr", cidr)
        _setter("gateway", gateway)

    @property
    @pulumi.getter
    def cidr(self) -> str:
        return pulumi.get(self, "cidr")

    @property
    @pulumi.getter
    def gateway(self) -> str:
        return pulumi.get(self, "gateway")


@pulumi.output_type
class NetworkXml(dict):
    def __init__(__self__, *,
                 xslt: Optional[str] = None):
        NetworkXml._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            xslt=xslt,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             xslt: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if xslt is not None:
            _setter("xslt", xslt)

    @property
    @pulumi.getter
    def xslt(self) -> Optional[str]:
        return pulumi.get(self, "xslt")


@pulumi.output_type
class PoolXml(dict):
    def __init__(__self__, *,
                 xslt: Optional[str] = None):
        PoolXml._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            xslt=xslt,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             xslt: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if xslt is not None:
            _setter("xslt", xslt)

    @property
    @pulumi.getter
    def xslt(self) -> Optional[str]:
        return pulumi.get(self, "xslt")


@pulumi.output_type
class VolumeXml(dict):
    def __init__(__self__, *,
                 xslt: Optional[str] = None):
        VolumeXml._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            xslt=xslt,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             xslt: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if xslt is not None:
            _setter("xslt", xslt)

    @property
    @pulumi.getter
    def xslt(self) -> Optional[str]:
        return pulumi.get(self, "xslt")


