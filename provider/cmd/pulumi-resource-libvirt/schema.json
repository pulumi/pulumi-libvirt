{
    "name": "libvirt",
    "description": "A Pulumi package for creating and managing libvirt cloud resources.",
    "keywords": [
        "pulumi",
        "libvirt"
    ],
    "homepage": "https://pulumi.io",
    "license": "Apache-2.0",
    "attribution": "This Pulumi package is based on the [`libvirt` Terraform Provider](https://github.com/dmacvicar/terraform-provider-libvirt).",
    "repository": "https://github.com/pulumi/pulumi-libvirt",
    "meta": {
        "moduleFormat": "(.*)(?:/[^/]*)"
    },
    "language": {
        "csharp": {
            "packageReferences": {
                "Pulumi": "3.*"
            },
            "compatibility": "tfbridge20",
            "respectSchemaVersion": true
        },
        "go": {
            "importBasePath": "github.com/pulumi/pulumi-libvirt/sdk/go/libvirt",
            "generateResourceContainerTypes": true,
            "generateExtraInputTypes": true,
            "respectSchemaVersion": true
        },
        "nodejs": {
            "packageDescription": "A Pulumi package for creating and managing libvirt cloud resources.",
            "readme": "\u003e This provider is a derived work of the [Terraform Provider](https://github.com/dmacvicar/terraform-provider-libvirt)\n\u003e distributed under [MPL 2.0](https://www.mozilla.org/en-US/MPL/2.0/). If you encounter a bug or missing feature,\n\u003e first check the [`pulumi-libvirt` repo](https://github.com/pulumi/pulumi-libvirt/issues); however, if that doesn't turn up anything,\n\u003e please consult the source [`terraform-provider-libvirt` repo](https://github.com/dmacvicar/terraform-provider-libvirt/issues).",
            "dependencies": {
                "@pulumi/pulumi": "^3.0.0"
            },
            "devDependencies": {
                "@types/mime": "^2.0.0",
                "@types/node": "^10.0.0"
            },
            "compatibility": "tfbridge20",
            "disableUnionOutputTypes": true,
            "respectSchemaVersion": true
        },
        "python": {
            "requires": {
                "pulumi": "\u003e=3.0.0,\u003c4.0.0"
            },
            "readme": "\u003e This provider is a derived work of the [Terraform Provider](https://github.com/dmacvicar/terraform-provider-libvirt)\n\u003e distributed under [MPL 2.0](https://www.mozilla.org/en-US/MPL/2.0/). If you encounter a bug or missing feature,\n\u003e first check the [`pulumi-libvirt` repo](https://github.com/pulumi/pulumi-libvirt/issues); however, if that doesn't turn up anything,\n\u003e please consult the source [`terraform-provider-libvirt` repo](https://github.com/dmacvicar/terraform-provider-libvirt/issues).",
            "compatibility": "tfbridge20",
            "respectSchemaVersion": true,
            "pyproject": {
                "enabled": true
            }
        }
    },
    "config": {
        "variables": {
            "uri": {
                "type": "string",
                "description": "libvirt connection URI for operations. See https://libvirt.org/uri.html\n",
                "defaultInfo": {
                    "environment": [
                        "LIBVIRT_DEFAULT_URI"
                    ]
                }
            }
        },
        "defaults": [
            "uri"
        ]
    },
    "types": {
        "libvirt:index/DomainBootDevice:DomainBootDevice": {
            "properties": {
                "devs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            },
            "type": "object"
        },
        "libvirt:index/DomainConsole:DomainConsole": {
            "properties": {
                "sourceHost": {
                    "type": "string",
                    "description": "IP address to listen on. Defaults to 127.0.0.1.\n",
                    "willReplaceOnChanges": true
                },
                "sourcePath": {
                    "type": "string",
                    "description": "Source path\n\nAdditional attributes when type is \"tcp\":\n",
                    "willReplaceOnChanges": true
                },
                "sourceService": {
                    "type": "string",
                    "description": "Port number or a service name. Defaults to a\nrandom port.\n\nNote that you can repeat the `console` block to create more than one console.\nThis works the same way as with the `disk` blocks (see above).\n\nSee [libvirt Domain XML Console element](https://libvirt.org/formatdomain.html#elementsConsole)\nfor more information.\n",
                    "willReplaceOnChanges": true
                },
                "targetPort": {
                    "type": "string",
                    "description": "Target port\n",
                    "willReplaceOnChanges": true
                },
                "targetType": {
                    "type": "string",
                    "description": "for the first console and defaults to `serial`.\nSubsequent `console` blocks must have a different type - usually `virtio`.\n\nAdditional attributes when type is \"pty\":\n",
                    "willReplaceOnChanges": true
                },
                "type": {
                    "type": "string",
                    "description": "Console device type. Valid values are \"pty\" and \"tcp\".\n",
                    "willReplaceOnChanges": true
                }
            },
            "type": "object",
            "required": [
                "targetPort",
                "type"
            ]
        },
        "libvirt:index/DomainCpu:DomainCpu": {
            "properties": {
                "mode": {
                    "type": "string"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "mode"
                    ]
                }
            }
        },
        "libvirt:index/DomainDisk:DomainDisk": {
            "properties": {
                "blockDevice": {
                    "type": "string",
                    "description": "The path to the host device to use as the block device for this disk. \n\nWhile `volume_id`, `url`, `file` and `block_device` are optional, it is intended that you use one of them.\n"
                },
                "file": {
                    "type": "string",
                    "description": "The filename to use as the block device for this disk (read-only)\n"
                },
                "scsi": {
                    "type": "boolean",
                    "description": "Use a scsi controller for this disk.  The controller\nmodel is set to `virtio-scsi`\n",
                    "willReplaceOnChanges": true
                },
                "url": {
                    "type": "string",
                    "description": "The http url to use as the block device for this disk (read-only)\n"
                },
                "volumeId": {
                    "type": "string",
                    "description": "The volume id to use for this disk.\n"
                },
                "wwn": {
                    "type": "string",
                    "description": "Specify a WWN to use for the disk if the disk is using\na scsi controller, if not specified then a random wwn is generated for the disk\n\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as libvirt from \"@pulumi/libvirt\";\n\nconst leap = new libvirt.Volume(\"leap\", {\n    name: \"leap\",\n    source: \"http://someurl/openSUSE_Leap-42.1.qcow2\",\n});\nconst mydisk = new libvirt.Volume(\"mydisk\", {\n    name: \"mydisk\",\n    baseVolumeId: leap.id,\n});\nconst domain1 = new libvirt.Domain(\"domain1\", {\n    name: \"domain1\",\n    disks: [\n        {\n            volumeId: mydisk.id,\n            scsi: true,\n        },\n        {\n            url: \"http://foo.com/install.iso\",\n        },\n        {\n            file: \"/absolute/path/to/disk.iso\",\n        },\n        {\n            blockDevice: \"/dev/mapper/36005076802810e55400000000000145f\",\n        },\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_libvirt as libvirt\n\nleap = libvirt.Volume(\"leap\",\n    name=\"leap\",\n    source=\"http://someurl/openSUSE_Leap-42.1.qcow2\")\nmydisk = libvirt.Volume(\"mydisk\",\n    name=\"mydisk\",\n    base_volume_id=leap.id)\ndomain1 = libvirt.Domain(\"domain1\",\n    name=\"domain1\",\n    disks=[\n        libvirt.DomainDiskArgs(\n            volume_id=mydisk.id,\n            scsi=True,\n        ),\n        libvirt.DomainDiskArgs(\n            url=\"http://foo.com/install.iso\",\n        ),\n        libvirt.DomainDiskArgs(\n            file=\"/absolute/path/to/disk.iso\",\n        ),\n        libvirt.DomainDiskArgs(\n            block_device=\"/dev/mapper/36005076802810e55400000000000145f\",\n        ),\n    ])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Libvirt = Pulumi.Libvirt;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var leap = new Libvirt.Volume(\"leap\", new()\n    {\n        Name = \"leap\",\n        Source = \"http://someurl/openSUSE_Leap-42.1.qcow2\",\n    });\n\n    var mydisk = new Libvirt.Volume(\"mydisk\", new()\n    {\n        Name = \"mydisk\",\n        BaseVolumeId = leap.Id,\n    });\n\n    var domain1 = new Libvirt.Domain(\"domain1\", new()\n    {\n        Name = \"domain1\",\n        Disks = new[]\n        {\n            new Libvirt.Inputs.DomainDiskArgs\n            {\n                VolumeId = mydisk.Id,\n                Scsi = true,\n            },\n            new Libvirt.Inputs.DomainDiskArgs\n            {\n                Url = \"http://foo.com/install.iso\",\n            },\n            new Libvirt.Inputs.DomainDiskArgs\n            {\n                File = \"/absolute/path/to/disk.iso\",\n            },\n            new Libvirt.Inputs.DomainDiskArgs\n            {\n                BlockDevice = \"/dev/mapper/36005076802810e55400000000000145f\",\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-libvirt/sdk/go/libvirt\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tleap, err := libvirt.NewVolume(ctx, \"leap\", \u0026libvirt.VolumeArgs{\n\t\t\tName:   pulumi.String(\"leap\"),\n\t\t\tSource: pulumi.String(\"http://someurl/openSUSE_Leap-42.1.qcow2\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tmydisk, err := libvirt.NewVolume(ctx, \"mydisk\", \u0026libvirt.VolumeArgs{\n\t\t\tName:         pulumi.String(\"mydisk\"),\n\t\t\tBaseVolumeId: leap.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = libvirt.NewDomain(ctx, \"domain1\", \u0026libvirt.DomainArgs{\n\t\t\tName: pulumi.String(\"domain1\"),\n\t\t\tDisks: libvirt.DomainDiskArray{\n\t\t\t\t\u0026libvirt.DomainDiskArgs{\n\t\t\t\t\tVolumeId: mydisk.ID(),\n\t\t\t\t\tScsi:     pulumi.Bool(true),\n\t\t\t\t},\n\t\t\t\t\u0026libvirt.DomainDiskArgs{\n\t\t\t\t\tUrl: pulumi.String(\"http://foo.com/install.iso\"),\n\t\t\t\t},\n\t\t\t\t\u0026libvirt.DomainDiskArgs{\n\t\t\t\t\tFile: pulumi.String(\"/absolute/path/to/disk.iso\"),\n\t\t\t\t},\n\t\t\t\t\u0026libvirt.DomainDiskArgs{\n\t\t\t\t\tBlockDevice: pulumi.String(\"/dev/mapper/36005076802810e55400000000000145f\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.libvirt.Volume;\nimport com.pulumi.libvirt.VolumeArgs;\nimport com.pulumi.libvirt.Domain;\nimport com.pulumi.libvirt.DomainArgs;\nimport com.pulumi.libvirt.inputs.DomainDiskArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var leap = new Volume(\"leap\", VolumeArgs.builder()        \n            .name(\"leap\")\n            .source(\"http://someurl/openSUSE_Leap-42.1.qcow2\")\n            .build());\n\n        var mydisk = new Volume(\"mydisk\", VolumeArgs.builder()        \n            .name(\"mydisk\")\n            .baseVolumeId(leap.id())\n            .build());\n\n        var domain1 = new Domain(\"domain1\", DomainArgs.builder()        \n            .name(\"domain1\")\n            .disks(            \n                DomainDiskArgs.builder()\n                    .volumeId(mydisk.id())\n                    .scsi(\"true\")\n                    .build(),\n                DomainDiskArgs.builder()\n                    .url(\"http://foo.com/install.iso\")\n                    .build(),\n                DomainDiskArgs.builder()\n                    .file(\"/absolute/path/to/disk.iso\")\n                    .build(),\n                DomainDiskArgs.builder()\n                    .blockDevice(\"/dev/mapper/36005076802810e55400000000000145f\")\n                    .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  leap:\n    type: libvirt:Volume\n    properties:\n      name: leap\n      source: http://someurl/openSUSE_Leap-42.1.qcow2\n  mydisk:\n    type: libvirt:Volume\n    properties:\n      name: mydisk\n      baseVolumeId: ${leap.id}\n  domain1:\n    type: libvirt:Domain\n    properties:\n      name: domain1\n      disks:\n        - volumeId: ${mydisk.id}\n          scsi: 'true'\n        - url: http://foo.com/install.iso\n        - file: /absolute/path/to/disk.iso\n        - blockDevice: /dev/mapper/36005076802810e55400000000000145f\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\nAlso note that the `disk` block is actually a list of maps, so it is possible to\ndeclare several of them by using either the literal list and map syntax as in\nthe following examples:\n\n"
                }
            },
            "type": "object"
        },
        "libvirt:index/DomainFilesystem:DomainFilesystem": {
            "properties": {
                "accessmode": {
                    "type": "string"
                },
                "readonly": {
                    "type": "boolean"
                },
                "source": {
                    "type": "string"
                },
                "target": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "source",
                "target"
            ]
        },
        "libvirt:index/DomainGraphics:DomainGraphics": {
            "properties": {
                "autoport": {
                    "type": "boolean",
                    "description": "defaults to \"yes\"\n",
                    "willReplaceOnChanges": true
                },
                "listenAddress": {
                    "type": "string",
                    "description": "IP Address where the VNC listener should be started if\n`listen_type` is set to `address`. Defaults to 127.0.0.1\n",
                    "willReplaceOnChanges": true
                },
                "listenType": {
                    "type": "string",
                    "description": "\"listen type\", defaults to \"none\"\n",
                    "willReplaceOnChanges": true
                },
                "type": {
                    "type": "string",
                    "description": "the type of graphics emulation (default is \"spice\")\n",
                    "willReplaceOnChanges": true
                },
                "websocket": {
                    "type": "integer",
                    "description": "Port to listen on for VNC WebSocket functionality (-1 meaning auto-allocation)\n\nOn occasion we have found it necessary to set a `type` of `vnc` and a\n`listen_type` of `address` with certain builds of QEMU.\n\nWith `listen_address` it is possible to specify a listener address for the virtual\nmachines VNC server. Usually this is an IP of the host system.\n\nThe `graphics` block will look as follows:\n\n"
                }
            },
            "type": "object"
        },
        "libvirt:index/DomainNetworkInterface:DomainNetworkInterface": {
            "properties": {
                "addresses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "bridge": {
                    "type": "string"
                },
                "hostname": {
                    "type": "string"
                },
                "mac": {
                    "type": "string"
                },
                "macvtap": {
                    "type": "string"
                },
                "networkId": {
                    "type": "string"
                },
                "networkName": {
                    "type": "string"
                },
                "passthrough": {
                    "type": "string"
                },
                "vepa": {
                    "type": "string"
                },
                "waitForLease": {
                    "type": "boolean"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "addresses",
                        "hostname",
                        "mac",
                        "networkId",
                        "networkName"
                    ]
                }
            }
        },
        "libvirt:index/DomainNvram:DomainNvram": {
            "properties": {
                "file": {
                    "type": "string",
                    "willReplaceOnChanges": true
                },
                "template": {
                    "type": "string",
                    "willReplaceOnChanges": true
                }
            },
            "type": "object",
            "required": [
                "file"
            ]
        },
        "libvirt:index/DomainTpm:DomainTpm": {
            "properties": {
                "backendDevicePath": {
                    "type": "string",
                    "description": "Path to TPM device on the host, ex: `/dev/tpm0`\n\nAdditional attributes when `backend_type` is \"emulator\":\n",
                    "willReplaceOnChanges": true
                },
                "backendEncryptionSecret": {
                    "type": "string",
                    "description": "[Secret object](https://libvirt.org/formatsecret.html) for encrypting the TPM state\n",
                    "willReplaceOnChanges": true
                },
                "backendPersistentState": {
                    "type": "boolean",
                    "description": "Keep the TPM state when a transient domain is powered off or undefined\n",
                    "willReplaceOnChanges": true
                },
                "backendType": {
                    "type": "string",
                    "description": "TPM backend, either `passthrough` or `emulator` (default: `emulator`)\n\nAdditional attributes when `backend_type` is \"passthrough\":\n",
                    "willReplaceOnChanges": true
                },
                "backendVersion": {
                    "type": "string",
                    "description": "TPM version\n",
                    "willReplaceOnChanges": true
                },
                "model": {
                    "type": "string",
                    "description": "TPM model provided to the guest\n",
                    "willReplaceOnChanges": true
                }
            },
            "type": "object"
        },
        "libvirt:index/DomainVideo:DomainVideo": {
            "properties": {
                "type": {
                    "type": "string",
                    "description": "The type of hypervisor to use for the domain.  Defaults to `kvm`, other values can be found [here](https://libvirt.org/formatdomain.html#id1)\n"
                }
            },
            "type": "object"
        },
        "libvirt:index/DomainXml:DomainXml": {
            "properties": {
                "xslt": {
                    "type": "string",
                    "willReplaceOnChanges": true
                }
            },
            "type": "object"
        },
        "libvirt:index/NetworkDhcp:NetworkDhcp": {
            "properties": {
                "enabled": {
                    "type": "boolean"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "enabled"
                    ]
                }
            }
        },
        "libvirt:index/NetworkDns:NetworkDns": {
            "properties": {
                "enabled": {
                    "type": "boolean"
                },
                "forwarders": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/libvirt:index/NetworkDnsForwarder:NetworkDnsForwarder"
                    },
                    "description": "Either `address`, `domain`, or both must be set\n",
                    "willReplaceOnChanges": true
                },
                "hosts": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/libvirt:index/NetworkDnsHost:NetworkDnsHost"
                    },
                    "description": "a DNS host entry block. You can have one or more of these\nblocks in your DNS definition. You must specify both `ip` and `hostname`.\n\nAn advanced example of round-robin DNS (using DNS host templates) follows:\n\n"
                },
                "localOnly": {
                    "type": "boolean",
                    "description": "true/false: true means 'do not forward unresolved requests for this domain to the part DNS server\n"
                },
                "srvs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/libvirt:index/NetworkDnsSrv:NetworkDnsSrv"
                    },
                    "description": "a DNS SRV entry block. You can have one or more of these blocks\nin your DNS definition. You must specify `service` and `protocol`.\n",
                    "willReplaceOnChanges": true
                }
            },
            "type": "object"
        },
        "libvirt:index/NetworkDnsForwarder:NetworkDnsForwarder": {
            "properties": {
                "address": {
                    "type": "string",
                    "willReplaceOnChanges": true
                },
                "domain": {
                    "type": "string",
                    "description": "The domain used by the DNS server.\n",
                    "willReplaceOnChanges": true
                }
            },
            "type": "object"
        },
        "libvirt:index/NetworkDnsHost:NetworkDnsHost": {
            "properties": {
                "hostname": {
                    "type": "string"
                },
                "ip": {
                    "type": "string"
                }
            },
            "type": "object"
        },
        "libvirt:index/NetworkDnsSrv:NetworkDnsSrv": {
            "properties": {
                "domain": {
                    "type": "string",
                    "description": "The domain used by the DNS server.\n",
                    "willReplaceOnChanges": true
                },
                "port": {
                    "type": "string",
                    "willReplaceOnChanges": true
                },
                "priority": {
                    "type": "string",
                    "willReplaceOnChanges": true
                },
                "protocol": {
                    "type": "string",
                    "willReplaceOnChanges": true
                },
                "service": {
                    "type": "string",
                    "willReplaceOnChanges": true
                },
                "target": {
                    "type": "string",
                    "willReplaceOnChanges": true
                },
                "weight": {
                    "type": "string",
                    "willReplaceOnChanges": true
                }
            },
            "type": "object"
        },
        "libvirt:index/NetworkDnsmasqOptions:NetworkDnsmasqOptions": {
            "properties": {
                "options": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/libvirt:index/NetworkDnsmasqOptionsOption:NetworkDnsmasqOptionsOption"
                    }
                }
            },
            "type": "object"
        },
        "libvirt:index/NetworkDnsmasqOptionsOption:NetworkDnsmasqOptionsOption": {
            "properties": {
                "optionName": {
                    "type": "string"
                },
                "optionValue": {
                    "type": "string"
                }
            },
            "type": "object"
        },
        "libvirt:index/NetworkRoute:NetworkRoute": {
            "properties": {
                "cidr": {
                    "type": "string"
                },
                "gateway": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "cidr",
                "gateway"
            ]
        },
        "libvirt:index/NetworkXml:NetworkXml": {
            "properties": {
                "xslt": {
                    "type": "string",
                    "willReplaceOnChanges": true
                }
            },
            "type": "object"
        },
        "libvirt:index/PoolXml:PoolXml": {
            "properties": {
                "xslt": {
                    "type": "string",
                    "willReplaceOnChanges": true
                }
            },
            "type": "object"
        },
        "libvirt:index/VolumeXml:VolumeXml": {
            "properties": {
                "xslt": {
                    "type": "string",
                    "willReplaceOnChanges": true
                }
            },
            "type": "object"
        }
    },
    "provider": {
        "description": "The provider type for the libvirt package. By default, resources use package-wide configuration\nsettings, however an explicit `Provider` instance may be created and passed during resource\nconstruction to achieve fine-grained programmatic control over provider settings. See the\n[documentation](https://www.pulumi.com/docs/reference/programming-model/#providers) for more information.\n",
        "properties": {
            "uri": {
                "type": "string",
                "description": "libvirt connection URI for operations. See https://libvirt.org/uri.html\n"
            }
        },
        "inputProperties": {
            "uri": {
                "type": "string",
                "description": "libvirt connection URI for operations. See https://libvirt.org/uri.html\n",
                "defaultInfo": {
                    "environment": [
                        "LIBVIRT_DEFAULT_URI"
                    ]
                }
            }
        }
    },
    "resources": {
        "libvirt:index/cloudInitDisk:CloudInitDisk": {
            "properties": {
                "metaData": {
                    "type": "string",
                    "description": "cloud-init user data.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A unique name for the resource, required by libvirt.\n"
                },
                "networkConfig": {
                    "type": "string",
                    "description": "cloud-init network-config data.\n"
                },
                "pool": {
                    "type": "string",
                    "description": "The pool where the resource will be created.\nIf not given, the `default` pool will be used.\nFor user_data, network_config and meta_data parameters have a look at upstream doc:\nhttp://cloudinit.readthedocs.io/en/latest/topics/datasources/nocloud.html#datasource-nocloud\n"
                },
                "userData": {
                    "type": "string",
                    "description": "cloud-init user data.\n"
                }
            },
            "required": [
                "name"
            ],
            "inputProperties": {
                "metaData": {
                    "type": "string",
                    "description": "cloud-init user data.\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "A unique name for the resource, required by libvirt.\n",
                    "willReplaceOnChanges": true
                },
                "networkConfig": {
                    "type": "string",
                    "description": "cloud-init network-config data.\n",
                    "willReplaceOnChanges": true
                },
                "pool": {
                    "type": "string",
                    "description": "The pool where the resource will be created.\nIf not given, the `default` pool will be used.\nFor user_data, network_config and meta_data parameters have a look at upstream doc:\nhttp://cloudinit.readthedocs.io/en/latest/topics/datasources/nocloud.html#datasource-nocloud\n",
                    "willReplaceOnChanges": true
                },
                "userData": {
                    "type": "string",
                    "description": "cloud-init user data.\n",
                    "willReplaceOnChanges": true
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering CloudInitDisk resources.\n",
                "properties": {
                    "metaData": {
                        "type": "string",
                        "description": "cloud-init user data.\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "A unique name for the resource, required by libvirt.\n",
                        "willReplaceOnChanges": true
                    },
                    "networkConfig": {
                        "type": "string",
                        "description": "cloud-init network-config data.\n",
                        "willReplaceOnChanges": true
                    },
                    "pool": {
                        "type": "string",
                        "description": "The pool where the resource will be created.\nIf not given, the `default` pool will be used.\nFor user_data, network_config and meta_data parameters have a look at upstream doc:\nhttp://cloudinit.readthedocs.io/en/latest/topics/datasources/nocloud.html#datasource-nocloud\n",
                        "willReplaceOnChanges": true
                    },
                    "userData": {
                        "type": "string",
                        "description": "cloud-init user data.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "libvirt:index/domain:Domain": {
            "description": "Manages a VM domain resource within libvirt. For more information see\n[the official documentation](https://libvirt.org/formatdomain.html).\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as libvirt from \"@pulumi/libvirt\";\n\nconst _default = new libvirt.Domain(\"default\", {name: \"test\"});\n```\n```python\nimport pulumi\nimport pulumi_libvirt as libvirt\n\ndefault = libvirt.Domain(\"default\", name=\"test\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Libvirt = Pulumi.Libvirt;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var @default = new Libvirt.Domain(\"default\", new()\n    {\n        Name = \"test\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-libvirt/sdk/go/libvirt\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := libvirt.NewDomain(ctx, \"default\", \u0026libvirt.DomainArgs{\n\t\t\tName: pulumi.String(\"test\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.libvirt.Domain;\nimport com.pulumi.libvirt.DomainArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var default_ = new Domain(\"default\", DomainArgs.builder()        \n            .name(\"test\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  default:\n    type: libvirt:Domain\n    properties:\n      name: test\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "properties": {
                "arch": {
                    "type": "string",
                    "description": "The architecture for the VM (probably x86_64 or i686),\nyou normally won't need to set this unless you are building a special VM\n"
                },
                "autostart": {
                    "type": "boolean",
                    "description": "Set to `true` to start the domain on host boot up.\nIf not specified `false` is assumed.\n"
                },
                "bootDevices": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/libvirt:index/DomainBootDevice:DomainBootDevice"
                    },
                    "description": "A list of devices (dev) which defines boot order. Example\nbelow.\n"
                },
                "cloudinit": {
                    "type": "string",
                    "description": "The `libvirt.CloudInitDisk` disk that has to be used by\nthe domain. This is going to be attached as a CDROM ISO. Changing the\ncloud-init won't cause the domain to be recreated, however the change will\nhave effect on the next reboot.\n"
                },
                "cmdlines": {
                    "type": "array",
                    "items": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        }
                    }
                },
                "consoles": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/libvirt:index/DomainConsole:DomainConsole"
                    }
                },
                "coreosIgnition": {
                    "type": "string",
                    "description": "The\n[libvirt.Ignition](https://www.terraform.io/docs/providers/libvirt/r/coreos_ignition.html) resource\nthat is to be used by the CoreOS domain.\n"
                },
                "cpu": {
                    "$ref": "#/types/libvirt:index/DomainCpu:DomainCpu",
                    "description": "Configures CPU mode. See below for more\ndetails.\n"
                },
                "description": {
                    "type": "string",
                    "description": "The description for domain.\nChanging this forces a new resource to be created.\nThis data is not used by libvirt in any way, it can contain any information the user wants.\n"
                },
                "disks": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/libvirt:index/DomainDisk:DomainDisk"
                    },
                    "description": "An array of one or more disks to attach to the domain. The\n`disk` object structure is documented below.\n"
                },
                "emulator": {
                    "type": "string",
                    "description": "The path of the emulator to use\n"
                },
                "filesystems": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/libvirt:index/DomainFilesystem:DomainFilesystem"
                    },
                    "description": "An array of one or more host filesystems to attach to\nthe domain. The `filesystem` object structure is documented\nbelow.\n"
                },
                "firmware": {
                    "type": "string"
                },
                "fwCfgName": {
                    "type": "string",
                    "description": "The name of the firmware config path where ignition file is stored: default is `opt/com.coreos/config`. If you are using [Flatcar Linux](https://docs.flatcar-linux.org/os/booting-with-libvirt/#creating-the-domain-xml), the value is `opt/org.flatcar-linux/config`.\n"
                },
                "graphics": {
                    "$ref": "#/types/libvirt:index/DomainGraphics:DomainGraphics"
                },
                "initrd": {
                    "type": "string"
                },
                "kernel": {
                    "type": "string"
                },
                "machine": {
                    "type": "string",
                    "description": "The machine type,\nyou normally won't need to set this unless you are running on a platform that\ndefaults to the wrong machine type for your template\n"
                },
                "memory": {
                    "type": "integer",
                    "description": "The amount of memory in MiB. If not specified the domain\nwill be created with 512 MiB of memory be used.\n"
                },
                "metadata": {
                    "type": "string"
                },
                "name": {
                    "type": "string",
                    "description": "A unique name for the resource, required by libvirt.\nChanging this forces a new resource to be created.\n"
                },
                "networkInterfaces": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/libvirt:index/DomainNetworkInterface:DomainNetworkInterface"
                    },
                    "description": "An array of one or more network interfaces to\nattach to the domain. The `network_interface` object structure is documented\nbelow.\n"
                },
                "nvram": {
                    "$ref": "#/types/libvirt:index/DomainNvram:DomainNvram"
                },
                "qemuAgent": {
                    "type": "boolean",
                    "description": "By default is disabled, set to true for enabling it. More info [qemu-agent](https://wiki.libvirt.org/page/Qemu_guest_agent).\n"
                },
                "running": {
                    "type": "boolean",
                    "description": "Use `false` to turn off the instance. If not specified,\ntrue is assumed and the instance, if stopped, will be started at next apply.\n"
                },
                "tpm": {
                    "$ref": "#/types/libvirt:index/DomainTpm:DomainTpm",
                    "description": "TPM device to attach to the domain. The `tpm` object structure is documented below.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The type of hypervisor to use for the domain.  Defaults to `kvm`, other values can be found [here](https://libvirt.org/formatdomain.html#id1)\n"
                },
                "vcpu": {
                    "type": "integer",
                    "description": "The amount of virtual CPUs. If not specified, a single CPU\nwill be created.\n"
                },
                "video": {
                    "$ref": "#/types/libvirt:index/DomainVideo:DomainVideo"
                },
                "xml": {
                    "$ref": "#/types/libvirt:index/DomainXml:DomainXml"
                }
            },
            "required": [
                "arch",
                "autostart",
                "cpu",
                "emulator",
                "machine",
                "name"
            ],
            "inputProperties": {
                "arch": {
                    "type": "string",
                    "description": "The architecture for the VM (probably x86_64 or i686),\nyou normally won't need to set this unless you are building a special VM\n"
                },
                "autostart": {
                    "type": "boolean",
                    "description": "Set to `true` to start the domain on host boot up.\nIf not specified `false` is assumed.\n"
                },
                "bootDevices": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/libvirt:index/DomainBootDevice:DomainBootDevice"
                    },
                    "description": "A list of devices (dev) which defines boot order. Example\nbelow.\n"
                },
                "cloudinit": {
                    "type": "string",
                    "description": "The `libvirt.CloudInitDisk` disk that has to be used by\nthe domain. This is going to be attached as a CDROM ISO. Changing the\ncloud-init won't cause the domain to be recreated, however the change will\nhave effect on the next reboot.\n"
                },
                "cmdlines": {
                    "type": "array",
                    "items": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        }
                    },
                    "willReplaceOnChanges": true
                },
                "consoles": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/libvirt:index/DomainConsole:DomainConsole"
                    }
                },
                "coreosIgnition": {
                    "type": "string",
                    "description": "The\n[libvirt.Ignition](https://www.terraform.io/docs/providers/libvirt/r/coreos_ignition.html) resource\nthat is to be used by the CoreOS domain.\n",
                    "willReplaceOnChanges": true
                },
                "cpu": {
                    "$ref": "#/types/libvirt:index/DomainCpu:DomainCpu",
                    "description": "Configures CPU mode. See below for more\ndetails.\n",
                    "willReplaceOnChanges": true
                },
                "description": {
                    "type": "string",
                    "description": "The description for domain.\nChanging this forces a new resource to be created.\nThis data is not used by libvirt in any way, it can contain any information the user wants.\n",
                    "willReplaceOnChanges": true
                },
                "disks": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/libvirt:index/DomainDisk:DomainDisk"
                    },
                    "description": "An array of one or more disks to attach to the domain. The\n`disk` object structure is documented below.\n",
                    "willReplaceOnChanges": true
                },
                "emulator": {
                    "type": "string",
                    "description": "The path of the emulator to use\n"
                },
                "filesystems": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/libvirt:index/DomainFilesystem:DomainFilesystem"
                    },
                    "description": "An array of one or more host filesystems to attach to\nthe domain. The `filesystem` object structure is documented\nbelow.\n",
                    "willReplaceOnChanges": true
                },
                "firmware": {
                    "type": "string",
                    "willReplaceOnChanges": true
                },
                "fwCfgName": {
                    "type": "string",
                    "description": "The name of the firmware config path where ignition file is stored: default is `opt/com.coreos/config`. If you are using [Flatcar Linux](https://docs.flatcar-linux.org/os/booting-with-libvirt/#creating-the-domain-xml), the value is `opt/org.flatcar-linux/config`.\n",
                    "willReplaceOnChanges": true
                },
                "graphics": {
                    "$ref": "#/types/libvirt:index/DomainGraphics:DomainGraphics",
                    "willReplaceOnChanges": true
                },
                "initrd": {
                    "type": "string"
                },
                "kernel": {
                    "type": "string"
                },
                "machine": {
                    "type": "string",
                    "description": "The machine type,\nyou normally won't need to set this unless you are running on a platform that\ndefaults to the wrong machine type for your template\n"
                },
                "memory": {
                    "type": "integer",
                    "description": "The amount of memory in MiB. If not specified the domain\nwill be created with 512 MiB of memory be used.\n",
                    "willReplaceOnChanges": true
                },
                "metadata": {
                    "type": "string"
                },
                "name": {
                    "type": "string",
                    "description": "A unique name for the resource, required by libvirt.\nChanging this forces a new resource to be created.\n",
                    "willReplaceOnChanges": true
                },
                "networkInterfaces": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/libvirt:index/DomainNetworkInterface:DomainNetworkInterface"
                    },
                    "description": "An array of one or more network interfaces to\nattach to the domain. The `network_interface` object structure is documented\nbelow.\n"
                },
                "nvram": {
                    "$ref": "#/types/libvirt:index/DomainNvram:DomainNvram",
                    "willReplaceOnChanges": true
                },
                "qemuAgent": {
                    "type": "boolean",
                    "description": "By default is disabled, set to true for enabling it. More info [qemu-agent](https://wiki.libvirt.org/page/Qemu_guest_agent).\n"
                },
                "running": {
                    "type": "boolean",
                    "description": "Use `false` to turn off the instance. If not specified,\ntrue is assumed and the instance, if stopped, will be started at next apply.\n"
                },
                "tpm": {
                    "$ref": "#/types/libvirt:index/DomainTpm:DomainTpm",
                    "description": "TPM device to attach to the domain. The `tpm` object structure is documented below.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The type of hypervisor to use for the domain.  Defaults to `kvm`, other values can be found [here](https://libvirt.org/formatdomain.html#id1)\n",
                    "willReplaceOnChanges": true
                },
                "vcpu": {
                    "type": "integer",
                    "description": "The amount of virtual CPUs. If not specified, a single CPU\nwill be created.\n",
                    "willReplaceOnChanges": true
                },
                "video": {
                    "$ref": "#/types/libvirt:index/DomainVideo:DomainVideo"
                },
                "xml": {
                    "$ref": "#/types/libvirt:index/DomainXml:DomainXml"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Domain resources.\n",
                "properties": {
                    "arch": {
                        "type": "string",
                        "description": "The architecture for the VM (probably x86_64 or i686),\nyou normally won't need to set this unless you are building a special VM\n"
                    },
                    "autostart": {
                        "type": "boolean",
                        "description": "Set to `true` to start the domain on host boot up.\nIf not specified `false` is assumed.\n"
                    },
                    "bootDevices": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/libvirt:index/DomainBootDevice:DomainBootDevice"
                        },
                        "description": "A list of devices (dev) which defines boot order. Example\nbelow.\n"
                    },
                    "cloudinit": {
                        "type": "string",
                        "description": "The `libvirt.CloudInitDisk` disk that has to be used by\nthe domain. This is going to be attached as a CDROM ISO. Changing the\ncloud-init won't cause the domain to be recreated, however the change will\nhave effect on the next reboot.\n"
                    },
                    "cmdlines": {
                        "type": "array",
                        "items": {
                            "type": "object",
                            "additionalProperties": {
                                "$ref": "pulumi.json#/Any"
                            }
                        },
                        "willReplaceOnChanges": true
                    },
                    "consoles": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/libvirt:index/DomainConsole:DomainConsole"
                        }
                    },
                    "coreosIgnition": {
                        "type": "string",
                        "description": "The\n[libvirt.Ignition](https://www.terraform.io/docs/providers/libvirt/r/coreos_ignition.html) resource\nthat is to be used by the CoreOS domain.\n",
                        "willReplaceOnChanges": true
                    },
                    "cpu": {
                        "$ref": "#/types/libvirt:index/DomainCpu:DomainCpu",
                        "description": "Configures CPU mode. See below for more\ndetails.\n",
                        "willReplaceOnChanges": true
                    },
                    "description": {
                        "type": "string",
                        "description": "The description for domain.\nChanging this forces a new resource to be created.\nThis data is not used by libvirt in any way, it can contain any information the user wants.\n",
                        "willReplaceOnChanges": true
                    },
                    "disks": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/libvirt:index/DomainDisk:DomainDisk"
                        },
                        "description": "An array of one or more disks to attach to the domain. The\n`disk` object structure is documented below.\n",
                        "willReplaceOnChanges": true
                    },
                    "emulator": {
                        "type": "string",
                        "description": "The path of the emulator to use\n"
                    },
                    "filesystems": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/libvirt:index/DomainFilesystem:DomainFilesystem"
                        },
                        "description": "An array of one or more host filesystems to attach to\nthe domain. The `filesystem` object structure is documented\nbelow.\n",
                        "willReplaceOnChanges": true
                    },
                    "firmware": {
                        "type": "string",
                        "willReplaceOnChanges": true
                    },
                    "fwCfgName": {
                        "type": "string",
                        "description": "The name of the firmware config path where ignition file is stored: default is `opt/com.coreos/config`. If you are using [Flatcar Linux](https://docs.flatcar-linux.org/os/booting-with-libvirt/#creating-the-domain-xml), the value is `opt/org.flatcar-linux/config`.\n",
                        "willReplaceOnChanges": true
                    },
                    "graphics": {
                        "$ref": "#/types/libvirt:index/DomainGraphics:DomainGraphics",
                        "willReplaceOnChanges": true
                    },
                    "initrd": {
                        "type": "string"
                    },
                    "kernel": {
                        "type": "string"
                    },
                    "machine": {
                        "type": "string",
                        "description": "The machine type,\nyou normally won't need to set this unless you are running on a platform that\ndefaults to the wrong machine type for your template\n"
                    },
                    "memory": {
                        "type": "integer",
                        "description": "The amount of memory in MiB. If not specified the domain\nwill be created with 512 MiB of memory be used.\n",
                        "willReplaceOnChanges": true
                    },
                    "metadata": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string",
                        "description": "A unique name for the resource, required by libvirt.\nChanging this forces a new resource to be created.\n",
                        "willReplaceOnChanges": true
                    },
                    "networkInterfaces": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/libvirt:index/DomainNetworkInterface:DomainNetworkInterface"
                        },
                        "description": "An array of one or more network interfaces to\nattach to the domain. The `network_interface` object structure is documented\nbelow.\n"
                    },
                    "nvram": {
                        "$ref": "#/types/libvirt:index/DomainNvram:DomainNvram",
                        "willReplaceOnChanges": true
                    },
                    "qemuAgent": {
                        "type": "boolean",
                        "description": "By default is disabled, set to true for enabling it. More info [qemu-agent](https://wiki.libvirt.org/page/Qemu_guest_agent).\n"
                    },
                    "running": {
                        "type": "boolean",
                        "description": "Use `false` to turn off the instance. If not specified,\ntrue is assumed and the instance, if stopped, will be started at next apply.\n"
                    },
                    "tpm": {
                        "$ref": "#/types/libvirt:index/DomainTpm:DomainTpm",
                        "description": "TPM device to attach to the domain. The `tpm` object structure is documented below.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "The type of hypervisor to use for the domain.  Defaults to `kvm`, other values can be found [here](https://libvirt.org/formatdomain.html#id1)\n",
                        "willReplaceOnChanges": true
                    },
                    "vcpu": {
                        "type": "integer",
                        "description": "The amount of virtual CPUs. If not specified, a single CPU\nwill be created.\n",
                        "willReplaceOnChanges": true
                    },
                    "video": {
                        "$ref": "#/types/libvirt:index/DomainVideo:DomainVideo"
                    },
                    "xml": {
                        "$ref": "#/types/libvirt:index/DomainXml:DomainXml"
                    }
                },
                "type": "object"
            }
        },
        "libvirt:index/ignition:Ignition": {
            "properties": {
                "content": {
                    "type": "string"
                },
                "name": {
                    "type": "string",
                    "description": "A unique name for the resource, required by libvirt.\n"
                },
                "pool": {
                    "type": "string",
                    "description": "The pool where the resource will be created.\nIf not given, the `default` pool will be used.\n"
                }
            },
            "required": [
                "content",
                "name"
            ],
            "inputProperties": {
                "content": {
                    "type": "string",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "A unique name for the resource, required by libvirt.\n",
                    "willReplaceOnChanges": true
                },
                "pool": {
                    "type": "string",
                    "description": "The pool where the resource will be created.\nIf not given, the `default` pool will be used.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "content"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Ignition resources.\n",
                "properties": {
                    "content": {
                        "type": "string",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "A unique name for the resource, required by libvirt.\n",
                        "willReplaceOnChanges": true
                    },
                    "pool": {
                        "type": "string",
                        "description": "The pool where the resource will be created.\nIf not given, the `default` pool will be used.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "libvirt:index/network:Network": {
            "description": "Manages a VM network resource within libvirt. For more information see\n[the official documentation](https://libvirt.org/formatnetwork.html).\n\n",
            "properties": {
                "addresses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of (0 or 1) IPv4 and (0 or 1) IPv6 subnets in\nCIDR notation.  This defines the subnets associated to that network.\nThis argument is also used to define the address on the real host.\nIf `dhcp {  enabled = true }` addresses is also used to define the address range served by\nthe DHCP server.\nNo DHCP server will be started if `addresses` is omitted.\n"
                },
                "autostart": {
                    "type": "boolean",
                    "description": "Set to `true` to start the network on host boot up.\nIf not specified `false` is assumed.\n"
                },
                "bridge": {
                    "type": "string",
                    "description": "The bridge device defines the name of a bridge\ndevice which will be used to construct the virtual network (when not provided,\nit will be automatically obtained by libvirt in `none`, `nat`, `route` and `open` modes).\n"
                },
                "dhcp": {
                    "$ref": "#/types/libvirt:index/NetworkDhcp:NetworkDhcp"
                },
                "dns": {
                    "$ref": "#/types/libvirt:index/NetworkDns:NetworkDns",
                    "description": "configuration of DNS specific settings for the network\n"
                },
                "dnsmasqOptions": {
                    "$ref": "#/types/libvirt:index/NetworkDnsmasqOptions:NetworkDnsmasqOptions"
                },
                "domain": {
                    "type": "string",
                    "description": "The domain used by the DNS server.\n"
                },
                "mode": {
                    "type": "string",
                    "description": "One of:\n- \"none\": the guests can talk to each other and the host OS, but cannot reach\nany other machines on the LAN.\n- \"nat\": it is the default network mode. This is a configuration that\nallows guest OS to get outbound connectivity regardless of whether the host\nuses ethernet, wireless, dialup, or VPN networking without requiring any\nspecific admin configuration. In the absence of host networking, it at\nleast allows guests to talk directly to each other.\n- \"route\": this is a variant on the default network which routes traffic from\nthe virtual network to the LAN **without applying any NAT**. It requires that\nthe IP address range be pre-configured in the routing tables of the router\non the host network.\n- \"open\": similar to `route`, but no firewall rules are added.\n- \"bridge\": use a pre-existing host bridge. The guests will effectively be\ndirectly connected to the physical network (i.e. their IP addresses will\nall be on the subnet of the physical network, and there will be no\nrestrictions on inbound or outbound connections). The `bridge` network\nattribute is mandatory in this case.\n"
                },
                "mtu": {
                    "type": "integer",
                    "description": "The MTU to set for the underlying network interfaces. When\nnot supplied, libvirt will use the default for the interface, usually 1500.\nLibvirt version 5.1 and greater will advertise this value to nodes via DHCP.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A unique name for the resource, required by libvirt.\nChanging this forces a new resource to be created.\n"
                },
                "routes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/libvirt:index/NetworkRoute:NetworkRoute"
                    },
                    "description": "a list of static routes. A `cidr` and a `gateway` must\nbe provided. The `gateway` must be reachable via the bridge interface.\n"
                },
                "xml": {
                    "$ref": "#/types/libvirt:index/NetworkXml:NetworkXml"
                }
            },
            "required": [
                "autostart",
                "bridge",
                "dhcp",
                "dns",
                "name"
            ],
            "inputProperties": {
                "addresses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of (0 or 1) IPv4 and (0 or 1) IPv6 subnets in\nCIDR notation.  This defines the subnets associated to that network.\nThis argument is also used to define the address on the real host.\nIf `dhcp {  enabled = true }` addresses is also used to define the address range served by\nthe DHCP server.\nNo DHCP server will be started if `addresses` is omitted.\n",
                    "willReplaceOnChanges": true
                },
                "autostart": {
                    "type": "boolean",
                    "description": "Set to `true` to start the network on host boot up.\nIf not specified `false` is assumed.\n"
                },
                "bridge": {
                    "type": "string",
                    "description": "The bridge device defines the name of a bridge\ndevice which will be used to construct the virtual network (when not provided,\nit will be automatically obtained by libvirt in `none`, `nat`, `route` and `open` modes).\n",
                    "willReplaceOnChanges": true
                },
                "dhcp": {
                    "$ref": "#/types/libvirt:index/NetworkDhcp:NetworkDhcp",
                    "willReplaceOnChanges": true
                },
                "dns": {
                    "$ref": "#/types/libvirt:index/NetworkDns:NetworkDns",
                    "description": "configuration of DNS specific settings for the network\n"
                },
                "dnsmasqOptions": {
                    "$ref": "#/types/libvirt:index/NetworkDnsmasqOptions:NetworkDnsmasqOptions"
                },
                "domain": {
                    "type": "string",
                    "description": "The domain used by the DNS server.\n",
                    "willReplaceOnChanges": true
                },
                "mode": {
                    "type": "string",
                    "description": "One of:\n- \"none\": the guests can talk to each other and the host OS, but cannot reach\nany other machines on the LAN.\n- \"nat\": it is the default network mode. This is a configuration that\nallows guest OS to get outbound connectivity regardless of whether the host\nuses ethernet, wireless, dialup, or VPN networking without requiring any\nspecific admin configuration. In the absence of host networking, it at\nleast allows guests to talk directly to each other.\n- \"route\": this is a variant on the default network which routes traffic from\nthe virtual network to the LAN **without applying any NAT**. It requires that\nthe IP address range be pre-configured in the routing tables of the router\non the host network.\n- \"open\": similar to `route`, but no firewall rules are added.\n- \"bridge\": use a pre-existing host bridge. The guests will effectively be\ndirectly connected to the physical network (i.e. their IP addresses will\nall be on the subnet of the physical network, and there will be no\nrestrictions on inbound or outbound connections). The `bridge` network\nattribute is mandatory in this case.\n",
                    "willReplaceOnChanges": true
                },
                "mtu": {
                    "type": "integer",
                    "description": "The MTU to set for the underlying network interfaces. When\nnot supplied, libvirt will use the default for the interface, usually 1500.\nLibvirt version 5.1 and greater will advertise this value to nodes via DHCP.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A unique name for the resource, required by libvirt.\nChanging this forces a new resource to be created.\n",
                    "willReplaceOnChanges": true
                },
                "routes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/libvirt:index/NetworkRoute:NetworkRoute"
                    },
                    "description": "a list of static routes. A `cidr` and a `gateway` must\nbe provided. The `gateway` must be reachable via the bridge interface.\n",
                    "willReplaceOnChanges": true
                },
                "xml": {
                    "$ref": "#/types/libvirt:index/NetworkXml:NetworkXml",
                    "willReplaceOnChanges": true
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Network resources.\n",
                "properties": {
                    "addresses": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of (0 or 1) IPv4 and (0 or 1) IPv6 subnets in\nCIDR notation.  This defines the subnets associated to that network.\nThis argument is also used to define the address on the real host.\nIf `dhcp {  enabled = true }` addresses is also used to define the address range served by\nthe DHCP server.\nNo DHCP server will be started if `addresses` is omitted.\n",
                        "willReplaceOnChanges": true
                    },
                    "autostart": {
                        "type": "boolean",
                        "description": "Set to `true` to start the network on host boot up.\nIf not specified `false` is assumed.\n"
                    },
                    "bridge": {
                        "type": "string",
                        "description": "The bridge device defines the name of a bridge\ndevice which will be used to construct the virtual network (when not provided,\nit will be automatically obtained by libvirt in `none`, `nat`, `route` and `open` modes).\n",
                        "willReplaceOnChanges": true
                    },
                    "dhcp": {
                        "$ref": "#/types/libvirt:index/NetworkDhcp:NetworkDhcp",
                        "willReplaceOnChanges": true
                    },
                    "dns": {
                        "$ref": "#/types/libvirt:index/NetworkDns:NetworkDns",
                        "description": "configuration of DNS specific settings for the network\n"
                    },
                    "dnsmasqOptions": {
                        "$ref": "#/types/libvirt:index/NetworkDnsmasqOptions:NetworkDnsmasqOptions"
                    },
                    "domain": {
                        "type": "string",
                        "description": "The domain used by the DNS server.\n",
                        "willReplaceOnChanges": true
                    },
                    "mode": {
                        "type": "string",
                        "description": "One of:\n- \"none\": the guests can talk to each other and the host OS, but cannot reach\nany other machines on the LAN.\n- \"nat\": it is the default network mode. This is a configuration that\nallows guest OS to get outbound connectivity regardless of whether the host\nuses ethernet, wireless, dialup, or VPN networking without requiring any\nspecific admin configuration. In the absence of host networking, it at\nleast allows guests to talk directly to each other.\n- \"route\": this is a variant on the default network which routes traffic from\nthe virtual network to the LAN **without applying any NAT**. It requires that\nthe IP address range be pre-configured in the routing tables of the router\non the host network.\n- \"open\": similar to `route`, but no firewall rules are added.\n- \"bridge\": use a pre-existing host bridge. The guests will effectively be\ndirectly connected to the physical network (i.e. their IP addresses will\nall be on the subnet of the physical network, and there will be no\nrestrictions on inbound or outbound connections). The `bridge` network\nattribute is mandatory in this case.\n",
                        "willReplaceOnChanges": true
                    },
                    "mtu": {
                        "type": "integer",
                        "description": "The MTU to set for the underlying network interfaces. When\nnot supplied, libvirt will use the default for the interface, usually 1500.\nLibvirt version 5.1 and greater will advertise this value to nodes via DHCP.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "A unique name for the resource, required by libvirt.\nChanging this forces a new resource to be created.\n",
                        "willReplaceOnChanges": true
                    },
                    "routes": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/libvirt:index/NetworkRoute:NetworkRoute"
                        },
                        "description": "a list of static routes. A `cidr` and a `gateway` must\nbe provided. The `gateway` must be reachable via the bridge interface.\n",
                        "willReplaceOnChanges": true
                    },
                    "xml": {
                        "$ref": "#/types/libvirt:index/NetworkXml:NetworkXml",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "libvirt:index/pool:Pool": {
            "description": "Manages a storage pool in libvirt. Currently only directory-based storage pool are supported. For more information on\nstorage pools in libvirt, see [the official documentation](https://libvirt.org/formatstorage.html).\n\n**WARNING:** This is experimental API and may change in the future.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as libvirt from \"@pulumi/libvirt\";\n\n// A pool for all cluster volumes\nconst cluster = new libvirt.Pool(\"cluster\", {\n    name: \"cluster\",\n    type: \"dir\",\n    path: \"/home/user/cluster_storage\",\n});\nconst opensuseLeap = new libvirt.Volume(\"opensuse_leap\", {\n    name: \"opensuse_leap\",\n    pool: cluster.name,\n    source: \"http://download.opensuse.org/repositories/Cloud:/Images:/Leap_42.1/images/openSUSE-Leap-42.1-OpenStack.x86_64.qcow2\",\n});\n```\n```python\nimport pulumi\nimport pulumi_libvirt as libvirt\n\n# A pool for all cluster volumes\ncluster = libvirt.Pool(\"cluster\",\n    name=\"cluster\",\n    type=\"dir\",\n    path=\"/home/user/cluster_storage\")\nopensuse_leap = libvirt.Volume(\"opensuse_leap\",\n    name=\"opensuse_leap\",\n    pool=cluster.name,\n    source=\"http://download.opensuse.org/repositories/Cloud:/Images:/Leap_42.1/images/openSUSE-Leap-42.1-OpenStack.x86_64.qcow2\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Libvirt = Pulumi.Libvirt;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // A pool for all cluster volumes\n    var cluster = new Libvirt.Pool(\"cluster\", new()\n    {\n        Name = \"cluster\",\n        Type = \"dir\",\n        Path = \"/home/user/cluster_storage\",\n    });\n\n    var opensuseLeap = new Libvirt.Volume(\"opensuse_leap\", new()\n    {\n        Name = \"opensuse_leap\",\n        Pool = cluster.Name,\n        Source = \"http://download.opensuse.org/repositories/Cloud:/Images:/Leap_42.1/images/openSUSE-Leap-42.1-OpenStack.x86_64.qcow2\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-libvirt/sdk/go/libvirt\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t// A pool for all cluster volumes\n\t\tcluster, err := libvirt.NewPool(ctx, \"cluster\", \u0026libvirt.PoolArgs{\n\t\t\tName: pulumi.String(\"cluster\"),\n\t\t\tType: pulumi.String(\"dir\"),\n\t\t\tPath: pulumi.String(\"/home/user/cluster_storage\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = libvirt.NewVolume(ctx, \"opensuse_leap\", \u0026libvirt.VolumeArgs{\n\t\t\tName:   pulumi.String(\"opensuse_leap\"),\n\t\t\tPool:   cluster.Name,\n\t\t\tSource: pulumi.String(\"http://download.opensuse.org/repositories/Cloud:/Images:/Leap_42.1/images/openSUSE-Leap-42.1-OpenStack.x86_64.qcow2\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.libvirt.Pool;\nimport com.pulumi.libvirt.PoolArgs;\nimport com.pulumi.libvirt.Volume;\nimport com.pulumi.libvirt.VolumeArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        // A pool for all cluster volumes\n        var cluster = new Pool(\"cluster\", PoolArgs.builder()        \n            .name(\"cluster\")\n            .type(\"dir\")\n            .path(\"/home/user/cluster_storage\")\n            .build());\n\n        var opensuseLeap = new Volume(\"opensuseLeap\", VolumeArgs.builder()        \n            .name(\"opensuse_leap\")\n            .pool(cluster.name())\n            .source(\"http://download.opensuse.org/repositories/Cloud:/Images:/Leap_42.1/images/openSUSE-Leap-42.1-OpenStack.x86_64.qcow2\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # A pool for all cluster volumes\n  cluster:\n    type: libvirt:Pool\n    properties:\n      name: cluster\n      type: dir\n      path: /home/user/cluster_storage\n  opensuseLeap:\n    type: libvirt:Volume\n    name: opensuse_leap\n    properties:\n      name: opensuse_leap\n      pool: ${cluster.name}\n      source: http://download.opensuse.org/repositories/Cloud:/Images:/Leap_42.1/images/openSUSE-Leap-42.1-OpenStack.x86_64.qcow2\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "properties": {
                "allocation": {
                    "type": "integer"
                },
                "available": {
                    "type": "integer"
                },
                "capacity": {
                    "type": "integer"
                },
                "name": {
                    "type": "string",
                    "description": "A unique name for the resource, required by libvirt.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The directory where the pool will keep all its volumes. This is only relevant to (and required by)\nthe \"dir\" type pools.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The type of the pool. Currently, only \"dir\" supported.\n"
                },
                "xml": {
                    "$ref": "#/types/libvirt:index/PoolXml:PoolXml"
                }
            },
            "required": [
                "allocation",
                "available",
                "capacity",
                "name",
                "type"
            ],
            "inputProperties": {
                "allocation": {
                    "type": "integer",
                    "willReplaceOnChanges": true
                },
                "available": {
                    "type": "integer",
                    "willReplaceOnChanges": true
                },
                "capacity": {
                    "type": "integer",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "A unique name for the resource, required by libvirt.\n",
                    "willReplaceOnChanges": true
                },
                "path": {
                    "type": "string",
                    "description": "The directory where the pool will keep all its volumes. This is only relevant to (and required by)\nthe \"dir\" type pools.\n",
                    "willReplaceOnChanges": true
                },
                "type": {
                    "type": "string",
                    "description": "The type of the pool. Currently, only \"dir\" supported.\n",
                    "willReplaceOnChanges": true
                },
                "xml": {
                    "$ref": "#/types/libvirt:index/PoolXml:PoolXml",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "type"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Pool resources.\n",
                "properties": {
                    "allocation": {
                        "type": "integer",
                        "willReplaceOnChanges": true
                    },
                    "available": {
                        "type": "integer",
                        "willReplaceOnChanges": true
                    },
                    "capacity": {
                        "type": "integer",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "A unique name for the resource, required by libvirt.\n",
                        "willReplaceOnChanges": true
                    },
                    "path": {
                        "type": "string",
                        "description": "The directory where the pool will keep all its volumes. This is only relevant to (and required by)\nthe \"dir\" type pools.\n",
                        "willReplaceOnChanges": true
                    },
                    "type": {
                        "type": "string",
                        "description": "The type of the pool. Currently, only \"dir\" supported.\n",
                        "willReplaceOnChanges": true
                    },
                    "xml": {
                        "$ref": "#/types/libvirt:index/PoolXml:PoolXml",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "libvirt:index/volume:Volume": {
            "description": "Manages a storage volume in libvirt. For more information see\n[the official documentation](https://libvirt.org/formatstorage.html).\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as libvirt from \"@pulumi/libvirt\";\n\n// Base OS image to use to create a cluster of different\n// nodes\nconst opensuseLeap = new libvirt.Volume(\"opensuse_leap\", {\n    name: \"opensuse_leap\",\n    source: \"http://download.opensuse.org/repositories/Cloud:/Images:/Leap_42.1/images/openSUSE-Leap-42.1-OpenStack.x86_64.qcow2\",\n});\n// volume to attach to the \"master\" domain as main disk\nconst master = new libvirt.Volume(\"master\", {\n    name: \"master.qcow2\",\n    baseVolumeId: opensuseLeap.id,\n});\n// volumes to attach to the \"workers\" domains as main disk\nconst worker: libvirt.Volume[] = [];\nfor (const range = {value: 0}; range.value \u003c workersCount; range.value++) {\n    worker.push(new libvirt.Volume(`worker-${range.value}`, {\n        name: `worker_${range.value}.qcow2`,\n        baseVolumeId: opensuseLeap.id,\n    }));\n}\n```\n```python\nimport pulumi\nimport pulumi_libvirt as libvirt\n\n# Base OS image to use to create a cluster of different\n# nodes\nopensuse_leap = libvirt.Volume(\"opensuse_leap\",\n    name=\"opensuse_leap\",\n    source=\"http://download.opensuse.org/repositories/Cloud:/Images:/Leap_42.1/images/openSUSE-Leap-42.1-OpenStack.x86_64.qcow2\")\n# volume to attach to the \"master\" domain as main disk\nmaster = libvirt.Volume(\"master\",\n    name=\"master.qcow2\",\n    base_volume_id=opensuse_leap.id)\n# volumes to attach to the \"workers\" domains as main disk\nworker = []\nfor range in [{\"value\": i} for i in range(0, workers_count)]:\n    worker.append(libvirt.Volume(f\"worker-{range['value']}\",\n        name=f\"worker_{range['value']}.qcow2\",\n        base_volume_id=opensuse_leap.id))\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Libvirt = Pulumi.Libvirt;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // Base OS image to use to create a cluster of different\n    // nodes\n    var opensuseLeap = new Libvirt.Volume(\"opensuse_leap\", new()\n    {\n        Name = \"opensuse_leap\",\n        Source = \"http://download.opensuse.org/repositories/Cloud:/Images:/Leap_42.1/images/openSUSE-Leap-42.1-OpenStack.x86_64.qcow2\",\n    });\n\n    // volume to attach to the \"master\" domain as main disk\n    var master = new Libvirt.Volume(\"master\", new()\n    {\n        Name = \"master.qcow2\",\n        BaseVolumeId = opensuseLeap.Id,\n    });\n\n    // volumes to attach to the \"workers\" domains as main disk\n    var worker = new List\u003cLibvirt.Volume\u003e();\n    for (var rangeIndex = 0; rangeIndex \u003c workersCount; rangeIndex++)\n    {\n        var range = new { Value = rangeIndex };\n        worker.Add(new Libvirt.Volume($\"worker-{range.Value}\", new()\n        {\n            Name = $\"worker_{range.Value}.qcow2\",\n            BaseVolumeId = opensuseLeap.Id,\n        }));\n    }\n});\n```\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/pulumi/pulumi-libvirt/sdk/go/libvirt\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t// Base OS image to use to create a cluster of different\n\t\t// nodes\n\t\topensuseLeap, err := libvirt.NewVolume(ctx, \"opensuse_leap\", \u0026libvirt.VolumeArgs{\n\t\t\tName:   pulumi.String(\"opensuse_leap\"),\n\t\t\tSource: pulumi.String(\"http://download.opensuse.org/repositories/Cloud:/Images:/Leap_42.1/images/openSUSE-Leap-42.1-OpenStack.x86_64.qcow2\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// volume to attach to the \"master\" domain as main disk\n\t\t_, err = libvirt.NewVolume(ctx, \"master\", \u0026libvirt.VolumeArgs{\n\t\t\tName:         pulumi.String(\"master.qcow2\"),\n\t\t\tBaseVolumeId: opensuseLeap.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// volumes to attach to the \"workers\" domains as main disk\n\t\tvar worker []*libvirt.Volume\n\t\tfor index := 0; index \u003c workersCount; index++ {\n\t\t\tkey0 := index\n\t\t\tval0 := index\n\t\t\t__res, err := libvirt.NewVolume(ctx, fmt.Sprintf(\"worker-%v\", key0), \u0026libvirt.VolumeArgs{\n\t\t\t\tName:         pulumi.String(fmt.Sprintf(\"worker_%v.qcow2\", val0)),\n\t\t\t\tBaseVolumeId: opensuseLeap.ID(),\n\t\t\t})\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tworker = append(worker, __res)\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.libvirt.Volume;\nimport com.pulumi.libvirt.VolumeArgs;\nimport com.pulumi.codegen.internal.KeyedValue;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        // Base OS image to use to create a cluster of different\n        // nodes\n        var opensuseLeap = new Volume(\"opensuseLeap\", VolumeArgs.builder()        \n            .name(\"opensuse_leap\")\n            .source(\"http://download.opensuse.org/repositories/Cloud:/Images:/Leap_42.1/images/openSUSE-Leap-42.1-OpenStack.x86_64.qcow2\")\n            .build());\n\n        // volume to attach to the \"master\" domain as main disk\n        var master = new Volume(\"master\", VolumeArgs.builder()        \n            .name(\"master.qcow2\")\n            .baseVolumeId(opensuseLeap.id())\n            .build());\n\n        // volumes to attach to the \"workers\" domains as main disk\n        for (var i = 0; i \u003c workersCount; i++) {\n            new Volume(\"worker-\" + i, VolumeArgs.builder()            \n                .name(String.format(\"worker_%s.qcow2\", range.value()))\n                .baseVolumeId(opensuseLeap.id())\n                .build());\n\n        \n}\n    }\n}\n```\n```yaml\nresources:\n  # Base OS image to use to create a cluster of different\n  # nodes\n  opensuseLeap:\n    type: libvirt:Volume\n    name: opensuse_leap\n    properties:\n      name: opensuse_leap\n      source: http://download.opensuse.org/repositories/Cloud:/Images:/Leap_42.1/images/openSUSE-Leap-42.1-OpenStack.x86_64.qcow2\n  # volume to attach to the \"master\" domain as main disk\n  master:\n    type: libvirt:Volume\n    properties:\n      name: master.qcow2\n      baseVolumeId: ${opensuseLeap.id}\n  # volumes to attach to the \"workers\" domains as main disk\n  worker:\n    type: libvirt:Volume\n    properties:\n      name: worker_${range.value}.qcow2\n      baseVolumeId: ${opensuseLeap.id}\n    options: {}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n\u003e **Tip:** when provisioning multiple domains using the same base image, create\na `libvirt.Volume` for the base image and then define the domain specific ones\nas based on it. This way the image will not be modified and no extra disk space\nis going to be used for the base image.\n",
            "properties": {
                "baseVolumeId": {
                    "type": "string",
                    "description": "The backing volume (CoW) to use for this volume.\n"
                },
                "baseVolumeName": {
                    "type": "string",
                    "description": "The name of the backing volume (CoW) to use\nfor this volume. Note well: when `base_volume_pool` is not specified the\nvolume is going to be searched inside of `pool`.\n"
                },
                "baseVolumePool": {
                    "type": "string",
                    "description": "The name of the storage pool containing the\nvolume defined by `base_volume_name`.\n"
                },
                "format": {
                    "type": "string"
                },
                "name": {
                    "type": "string",
                    "description": "A unique name for the resource, required by libvirt.\nChanging this forces a new resource to be created.\n"
                },
                "pool": {
                    "type": "string",
                    "description": "The storage pool where the resource will be created.\nIf not given, the `default` storage pool will be used.\n"
                },
                "size": {
                    "type": "integer",
                    "description": "The size of the volume in bytes (if you don't like this,\nhelp fix this issue.\nIf `source` is specified, `size` will be set to the source image file size.\n`size` can be omitted if `source` is specified. `size` will then be set to the source image file size.\n`size` can be omitted if `base_volume_id` or `base_volume_name` is specified. `size` will then be set to the base volume size.\nIf `size` is specified to be bigger than `base_volume_id` or `base_volume_name` size, you can use [cloudinit](https://cloudinit.readthedocs.io) if your OS supports it, with `libvirt.CloudInitDisk` and the [growpart](https://cloudinit.readthedocs.io/en/latest/topics/modules.html#growpart) module to resize the partition.\n"
                },
                "source": {
                    "type": "string"
                },
                "xml": {
                    "$ref": "#/types/libvirt:index/VolumeXml:VolumeXml"
                }
            },
            "required": [
                "format",
                "name",
                "size"
            ],
            "inputProperties": {
                "baseVolumeId": {
                    "type": "string",
                    "description": "The backing volume (CoW) to use for this volume.\n",
                    "willReplaceOnChanges": true
                },
                "baseVolumeName": {
                    "type": "string",
                    "description": "The name of the backing volume (CoW) to use\nfor this volume. Note well: when `base_volume_pool` is not specified the\nvolume is going to be searched inside of `pool`.\n",
                    "willReplaceOnChanges": true
                },
                "baseVolumePool": {
                    "type": "string",
                    "description": "The name of the storage pool containing the\nvolume defined by `base_volume_name`.\n",
                    "willReplaceOnChanges": true
                },
                "format": {
                    "type": "string",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "A unique name for the resource, required by libvirt.\nChanging this forces a new resource to be created.\n",
                    "willReplaceOnChanges": true
                },
                "pool": {
                    "type": "string",
                    "description": "The storage pool where the resource will be created.\nIf not given, the `default` storage pool will be used.\n",
                    "willReplaceOnChanges": true
                },
                "size": {
                    "type": "integer",
                    "description": "The size of the volume in bytes (if you don't like this,\nhelp fix this issue.\nIf `source` is specified, `size` will be set to the source image file size.\n`size` can be omitted if `source` is specified. `size` will then be set to the source image file size.\n`size` can be omitted if `base_volume_id` or `base_volume_name` is specified. `size` will then be set to the base volume size.\nIf `size` is specified to be bigger than `base_volume_id` or `base_volume_name` size, you can use [cloudinit](https://cloudinit.readthedocs.io) if your OS supports it, with `libvirt.CloudInitDisk` and the [growpart](https://cloudinit.readthedocs.io/en/latest/topics/modules.html#growpart) module to resize the partition.\n",
                    "willReplaceOnChanges": true
                },
                "source": {
                    "type": "string",
                    "willReplaceOnChanges": true
                },
                "xml": {
                    "$ref": "#/types/libvirt:index/VolumeXml:VolumeXml",
                    "willReplaceOnChanges": true
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Volume resources.\n",
                "properties": {
                    "baseVolumeId": {
                        "type": "string",
                        "description": "The backing volume (CoW) to use for this volume.\n",
                        "willReplaceOnChanges": true
                    },
                    "baseVolumeName": {
                        "type": "string",
                        "description": "The name of the backing volume (CoW) to use\nfor this volume. Note well: when `base_volume_pool` is not specified the\nvolume is going to be searched inside of `pool`.\n",
                        "willReplaceOnChanges": true
                    },
                    "baseVolumePool": {
                        "type": "string",
                        "description": "The name of the storage pool containing the\nvolume defined by `base_volume_name`.\n",
                        "willReplaceOnChanges": true
                    },
                    "format": {
                        "type": "string",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "A unique name for the resource, required by libvirt.\nChanging this forces a new resource to be created.\n",
                        "willReplaceOnChanges": true
                    },
                    "pool": {
                        "type": "string",
                        "description": "The storage pool where the resource will be created.\nIf not given, the `default` storage pool will be used.\n",
                        "willReplaceOnChanges": true
                    },
                    "size": {
                        "type": "integer",
                        "description": "The size of the volume in bytes (if you don't like this,\nhelp fix this issue.\nIf `source` is specified, `size` will be set to the source image file size.\n`size` can be omitted if `source` is specified. `size` will then be set to the source image file size.\n`size` can be omitted if `base_volume_id` or `base_volume_name` is specified. `size` will then be set to the base volume size.\nIf `size` is specified to be bigger than `base_volume_id` or `base_volume_name` size, you can use [cloudinit](https://cloudinit.readthedocs.io) if your OS supports it, with `libvirt.CloudInitDisk` and the [growpart](https://cloudinit.readthedocs.io/en/latest/topics/modules.html#growpart) module to resize the partition.\n",
                        "willReplaceOnChanges": true
                    },
                    "source": {
                        "type": "string",
                        "willReplaceOnChanges": true
                    },
                    "xml": {
                        "$ref": "#/types/libvirt:index/VolumeXml:VolumeXml",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        }
    },
    "functions": {
        "libvirt:index/getNetworkDnsHostTemplate:getNetworkDnsHostTemplate": {
            "inputs": {
                "description": "A collection of arguments for invoking getNetworkDnsHostTemplate.\n",
                "properties": {
                    "hostname": {
                        "type": "string"
                    },
                    "ip": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "hostname",
                    "ip"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getNetworkDnsHostTemplate.\n",
                "properties": {
                    "hostname": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "ip": {
                        "type": "string"
                    },
                    "rendered": {
                        "additionalProperties": {
                            "type": "string"
                        },
                        "type": "object"
                    }
                },
                "required": [
                    "hostname",
                    "ip",
                    "rendered",
                    "id"
                ],
                "type": "object"
            }
        },
        "libvirt:index/getNetworkDnsSrvTemplate:getNetworkDnsSrvTemplate": {
            "inputs": {
                "description": "A collection of arguments for invoking getNetworkDnsSrvTemplate.\n",
                "properties": {
                    "domain": {
                        "type": "string"
                    },
                    "port": {
                        "type": "string"
                    },
                    "priority": {
                        "type": "string"
                    },
                    "protocol": {
                        "type": "string"
                    },
                    "service": {
                        "type": "string"
                    },
                    "target": {
                        "type": "string"
                    },
                    "weight": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "protocol",
                    "service"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getNetworkDnsSrvTemplate.\n",
                "properties": {
                    "domain": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "port": {
                        "type": "string"
                    },
                    "priority": {
                        "type": "string"
                    },
                    "protocol": {
                        "type": "string"
                    },
                    "rendered": {
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "type": "object"
                    },
                    "service": {
                        "type": "string"
                    },
                    "target": {
                        "type": "string"
                    },
                    "weight": {
                        "type": "string"
                    }
                },
                "required": [
                    "protocol",
                    "rendered",
                    "service",
                    "id"
                ],
                "type": "object"
            }
        },
        "libvirt:index/getNetworkDnsmasqOptionsTemplate:getNetworkDnsmasqOptionsTemplate": {
            "inputs": {
                "description": "A collection of arguments for invoking getNetworkDnsmasqOptionsTemplate.\n",
                "properties": {
                    "optionName": {
                        "type": "string"
                    },
                    "optionValue": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "optionName"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getNetworkDnsmasqOptionsTemplate.\n",
                "properties": {
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "optionName": {
                        "type": "string"
                    },
                    "optionValue": {
                        "type": "string"
                    },
                    "rendered": {
                        "additionalProperties": {
                            "type": "string"
                        },
                        "type": "object"
                    }
                },
                "required": [
                    "optionName",
                    "rendered",
                    "id"
                ],
                "type": "object"
            }
        }
    }
}