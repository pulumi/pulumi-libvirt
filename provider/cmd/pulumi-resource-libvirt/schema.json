{
    "name": "libvirt",
    "description": "A Pulumi package for creating and managing libvirt cloud resources.",
    "keywords": [
        "pulumi",
        "libvirt"
    ],
    "homepage": "https://pulumi.io",
    "license": "Apache-2.0",
    "attribution": "This Pulumi package is based on the [`libvirt` Terraform Provider](https://github.com/dmacvicar/terraform-provider-libvirt).",
    "repository": "https://github.com/pulumi/pulumi-libvirt",
    "meta": {
        "moduleFormat": "(.*)(?:/[^/]*)"
    },
    "language": {
        "csharp": {
            "packageReferences": {
                "Pulumi": "3.*"
            },
            "compatibility": "tfbridge20"
        },
        "go": {
            "importBasePath": "github.com/pulumi/pulumi-libvirt/sdk/go/libvirt",
            "generateResourceContainerTypes": true,
            "generateExtraInputTypes": true
        },
        "nodejs": {
            "packageDescription": "A Pulumi package for creating and managing libvirt cloud resources.",
            "readme": "\u003e This provider is a derived work of the [Terraform Provider](https://github.com/dmacvicar/terraform-provider-libvirt)\n\u003e distributed under [MPL 2.0](https://www.mozilla.org/en-US/MPL/2.0/). If you encounter a bug or missing feature,\n\u003e first check the [`pulumi-libvirt` repo](https://github.com/pulumi/pulumi-libvirt/issues); however, if that doesn't turn up anything,\n\u003e please consult the source [`terraform-provider-libvirt` repo](https://github.com/dmacvicar/terraform-provider-libvirt/issues).",
            "dependencies": {
                "@pulumi/pulumi": "^3.0.0"
            },
            "devDependencies": {
                "@types/mime": "^2.0.0",
                "@types/node": "^10.0.0"
            },
            "compatibility": "tfbridge20",
            "disableUnionOutputTypes": true
        },
        "python": {
            "requires": {
                "pulumi": "\u003e=3.0.0,\u003c4.0.0"
            },
            "readme": "\u003e This provider is a derived work of the [Terraform Provider](https://github.com/dmacvicar/terraform-provider-libvirt)\n\u003e distributed under [MPL 2.0](https://www.mozilla.org/en-US/MPL/2.0/). If you encounter a bug or missing feature,\n\u003e first check the [`pulumi-libvirt` repo](https://github.com/pulumi/pulumi-libvirt/issues); however, if that doesn't turn up anything,\n\u003e please consult the source [`terraform-provider-libvirt` repo](https://github.com/dmacvicar/terraform-provider-libvirt/issues).",
            "compatibility": "tfbridge20",
            "pyproject": {
                "enabled": true
            }
        }
    },
    "config": {
        "variables": {
            "uri": {
                "type": "string",
                "description": "libvirt connection URI for operations. See https://libvirt.org/uri.html\n",
                "defaultInfo": {
                    "environment": [
                        "LIBVIRT_DEFAULT_URI"
                    ]
                }
            }
        },
        "defaults": [
            "uri"
        ]
    },
    "types": {
        "libvirt:index/DomainBootDevice:DomainBootDevice": {
            "properties": {
                "devs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            },
            "type": "object"
        },
        "libvirt:index/DomainConsole:DomainConsole": {
            "properties": {
                "sourceHost": {
                    "type": "string",
                    "description": "IP address to listen on. Defaults to 127.0.0.1.\n",
                    "willReplaceOnChanges": true
                },
                "sourcePath": {
                    "type": "string",
                    "description": "Source path\n\nAdditional attributes when type is \"tcp\":\n",
                    "willReplaceOnChanges": true
                },
                "sourceService": {
                    "type": "string",
                    "description": "Port number or a service name. Defaults to a\nrandom port.\n\nNote that you can repeat the `console` block to create more than one console.\nThis works the same way as with the `disk` blocks (see above).\n\nSee [libvirt Domain XML Console element](https://libvirt.org/formatdomain.html#elementsConsole)\nfor more information.\n",
                    "willReplaceOnChanges": true
                },
                "targetPort": {
                    "type": "string",
                    "description": "Target port\n",
                    "willReplaceOnChanges": true
                },
                "targetType": {
                    "type": "string",
                    "description": "for the first console and defaults to `serial`.\nSubsequent `console` blocks must have a different type - usually `virtio`.\n\nAdditional attributes when type is \"pty\":\n",
                    "willReplaceOnChanges": true
                },
                "type": {
                    "type": "string",
                    "description": "The type of hypervisor to use for the domain.  Defaults to `kvm`, other values can be found [here](https://libvirt.org/formatdomain.html#id1)\n",
                    "willReplaceOnChanges": true
                }
            },
            "type": "object",
            "required": [
                "targetPort",
                "type"
            ]
        },
        "libvirt:index/DomainCpu:DomainCpu": {
            "properties": {
                "mode": {
                    "type": "string"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "mode"
                    ]
                }
            }
        },
        "libvirt:index/DomainDisk:DomainDisk": {
            "properties": {
                "blockDevice": {
                    "type": "string",
                    "description": "The path to the host device to use as the block device for this disk. \n\nWhile `volume_id`, `url`, `file` and `block_device` are optional, it is intended that you use one of them.\n"
                },
                "file": {
                    "type": "string",
                    "description": "The filename to use as the block device for this disk (read-only)\n"
                },
                "scsi": {
                    "type": "boolean",
                    "description": "Use a scsi controller for this disk.  The controller\nmodel is set to `virtio-scsi`\n",
                    "willReplaceOnChanges": true
                },
                "url": {
                    "type": "string",
                    "description": "The http url to use as the block device for this disk (read-only)\n"
                },
                "volumeId": {
                    "type": "string",
                    "description": "The volume id to use for this disk.\n"
                },
                "wwn": {
                    "type": "string",
                    "description": "Specify a WWN to use for the disk if the disk is using\na scsi controller, if not specified then a random wwn is generated for the disk\n\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as libvirt from \"@pulumi/libvirt\";\n\nconst leap = new libvirt.Volume(\"leap\", {\n    name: \"leap\",\n    source: \"http://someurl/openSUSE_Leap-42.1.qcow2\",\n});\nconst mydisk = new libvirt.Volume(\"mydisk\", {\n    name: \"mydisk\",\n    baseVolumeId: leap.id,\n});\nconst domain1 = new libvirt.Domain(\"domain1\", {\n    name: \"domain1\",\n    disks: [\n        {\n            volumeId: mydisk.id,\n            scsi: true,\n        },\n        {\n            url: \"http://foo.com/install.iso\",\n        },\n        {\n            file: \"/absolute/path/to/disk.iso\",\n        },\n        {\n            blockDevice: \"/dev/mapper/36005076802810e55400000000000145f\",\n        },\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_libvirt as libvirt\n\nleap = libvirt.Volume(\"leap\",\n    name=\"leap\",\n    source=\"http://someurl/openSUSE_Leap-42.1.qcow2\")\nmydisk = libvirt.Volume(\"mydisk\",\n    name=\"mydisk\",\n    base_volume_id=leap.id)\ndomain1 = libvirt.Domain(\"domain1\",\n    name=\"domain1\",\n    disks=[\n        libvirt.DomainDiskArgs(\n            volume_id=mydisk.id,\n            scsi=True,\n        ),\n        libvirt.DomainDiskArgs(\n            url=\"http://foo.com/install.iso\",\n        ),\n        libvirt.DomainDiskArgs(\n            file=\"/absolute/path/to/disk.iso\",\n        ),\n        libvirt.DomainDiskArgs(\n            block_device=\"/dev/mapper/36005076802810e55400000000000145f\",\n        ),\n    ])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Libvirt = Pulumi.Libvirt;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var leap = new Libvirt.Volume(\"leap\", new()\n    {\n        Name = \"leap\",\n        Source = \"http://someurl/openSUSE_Leap-42.1.qcow2\",\n    });\n\n    var mydisk = new Libvirt.Volume(\"mydisk\", new()\n    {\n        Name = \"mydisk\",\n        BaseVolumeId = leap.Id,\n    });\n\n    var domain1 = new Libvirt.Domain(\"domain1\", new()\n    {\n        Name = \"domain1\",\n        Disks = new[]\n        {\n            new Libvirt.Inputs.DomainDiskArgs\n            {\n                VolumeId = mydisk.Id,\n                Scsi = true,\n            },\n            new Libvirt.Inputs.DomainDiskArgs\n            {\n                Url = \"http://foo.com/install.iso\",\n            },\n            new Libvirt.Inputs.DomainDiskArgs\n            {\n                File = \"/absolute/path/to/disk.iso\",\n            },\n            new Libvirt.Inputs.DomainDiskArgs\n            {\n                BlockDevice = \"/dev/mapper/36005076802810e55400000000000145f\",\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-libvirt/sdk/go/libvirt\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tleap, err := libvirt.NewVolume(ctx, \"leap\", \u0026libvirt.VolumeArgs{\n\t\t\tName:   pulumi.String(\"leap\"),\n\t\t\tSource: pulumi.String(\"http://someurl/openSUSE_Leap-42.1.qcow2\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tmydisk, err := libvirt.NewVolume(ctx, \"mydisk\", \u0026libvirt.VolumeArgs{\n\t\t\tName:         pulumi.String(\"mydisk\"),\n\t\t\tBaseVolumeId: leap.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = libvirt.NewDomain(ctx, \"domain1\", \u0026libvirt.DomainArgs{\n\t\t\tName: pulumi.String(\"domain1\"),\n\t\t\tDisks: libvirt.DomainDiskArray{\n\t\t\t\t\u0026libvirt.DomainDiskArgs{\n\t\t\t\t\tVolumeId: mydisk.ID(),\n\t\t\t\t\tScsi:     pulumi.Bool(true),\n\t\t\t\t},\n\t\t\t\t\u0026libvirt.DomainDiskArgs{\n\t\t\t\t\tUrl: pulumi.String(\"http://foo.com/install.iso\"),\n\t\t\t\t},\n\t\t\t\t\u0026libvirt.DomainDiskArgs{\n\t\t\t\t\tFile: pulumi.String(\"/absolute/path/to/disk.iso\"),\n\t\t\t\t},\n\t\t\t\t\u0026libvirt.DomainDiskArgs{\n\t\t\t\t\tBlockDevice: pulumi.String(\"/dev/mapper/36005076802810e55400000000000145f\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.libvirt.Volume;\nimport com.pulumi.libvirt.VolumeArgs;\nimport com.pulumi.libvirt.Domain;\nimport com.pulumi.libvirt.DomainArgs;\nimport com.pulumi.libvirt.inputs.DomainDiskArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var leap = new Volume(\"leap\", VolumeArgs.builder()        \n            .name(\"leap\")\n            .source(\"http://someurl/openSUSE_Leap-42.1.qcow2\")\n            .build());\n\n        var mydisk = new Volume(\"mydisk\", VolumeArgs.builder()        \n            .name(\"mydisk\")\n            .baseVolumeId(leap.id())\n            .build());\n\n        var domain1 = new Domain(\"domain1\", DomainArgs.builder()        \n            .name(\"domain1\")\n            .disks(            \n                DomainDiskArgs.builder()\n                    .volumeId(mydisk.id())\n                    .scsi(\"true\")\n                    .build(),\n                DomainDiskArgs.builder()\n                    .url(\"http://foo.com/install.iso\")\n                    .build(),\n                DomainDiskArgs.builder()\n                    .file(\"/absolute/path/to/disk.iso\")\n                    .build(),\n                DomainDiskArgs.builder()\n                    .blockDevice(\"/dev/mapper/36005076802810e55400000000000145f\")\n                    .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  leap:\n    type: libvirt:Volume\n    properties:\n      name: leap\n      source: http://someurl/openSUSE_Leap-42.1.qcow2\n  mydisk:\n    type: libvirt:Volume\n    properties:\n      name: mydisk\n      baseVolumeId: ${leap.id}\n  domain1:\n    type: libvirt:Domain\n    properties:\n      name: domain1\n      disks:\n        - volumeId: ${mydisk.id}\n          scsi: 'true'\n        - url: http://foo.com/install.iso\n        - file: /absolute/path/to/disk.iso\n        - blockDevice: /dev/mapper/36005076802810e55400000000000145f\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\nAlso note that the `disk` block is actually a list of maps, so it is possible to\ndeclare several of them by using either the literal list and map syntax as in\nthe following examples:\n\n"
                }
            },
            "type": "object"
        },
        "libvirt:index/DomainFilesystem:DomainFilesystem": {
            "properties": {
                "accessmode": {
                    "type": "string",
                    "description": "specifies the security mode for accessing the source. By default\nthe `mapped` mode is chosen.\n"
                },
                "readonly": {
                    "type": "boolean",
                    "description": "enables exporting filesystem as a readonly mount for guest, by\ndefault read-only access is given.\n\nExample:\n\n"
                },
                "source": {
                    "type": "string",
                    "description": "the directory of the host to be shared with the guest.\n"
                },
                "target": {
                    "type": "string",
                    "description": "an arbitrary string tag that is exported to the guest as a hint for\nwhere to mount the source.\n"
                }
            },
            "type": "object",
            "required": [
                "source",
                "target"
            ]
        },
        "libvirt:index/DomainGraphics:DomainGraphics": {
            "properties": {
                "autoport": {
                    "type": "boolean",
                    "description": "defaults to \"yes\"\n",
                    "willReplaceOnChanges": true
                },
                "listenAddress": {
                    "type": "string",
                    "description": "IP Address where the VNC listener should be started if\n`listen_type` is set to `address`. Defaults to 127.0.0.1\n",
                    "willReplaceOnChanges": true
                },
                "listenType": {
                    "type": "string",
                    "description": "\"listen type\", defaults to \"none\"\n",
                    "willReplaceOnChanges": true
                },
                "type": {
                    "type": "string",
                    "description": "The type of hypervisor to use for the domain.  Defaults to `kvm`, other values can be found [here](https://libvirt.org/formatdomain.html#id1)\n",
                    "willReplaceOnChanges": true
                },
                "websocket": {
                    "type": "integer",
                    "description": "Port to listen on for VNC WebSocket functionality (-1 meaning auto-allocation)\n\nOn occasion we have found it necessary to set a `type` of `vnc` and a\n`listen_type` of `address` with certain builds of QEMU.\n\nWith `listen_address` it is possible to specify a listener address for the virtual\nmachines VNC server. Usually this is an IP of the host system.\n\nThe `graphics` block will look as follows:\n\n"
                }
            },
            "type": "object"
        },
        "libvirt:index/DomainNetworkInterface:DomainNetworkInterface": {
            "properties": {
                "addresses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "An IP address for this domain in this network.\n"
                },
                "bridge": {
                    "type": "string",
                    "description": "Provides a bridge from the VM directly to the LAN. This assumes\nthere is a bridge device on the host which has one or more of the hosts\nphysical NICs enslaved. The guest VM will have an associated _tun_ device\ncreated and enslaved to the bridge. The IP range / network configuration is\nwhatever is used on the LAN. This provides the guest VM full incoming \u0026\noutgoing net access just like a physical machine.\n"
                },
                "hostname": {
                    "type": "string",
                    "description": "A hostname that will be assigned to this domain\nresource in this network.\n"
                },
                "mac": {
                    "type": "string",
                    "description": "The specific MAC address to use for this interface.\n"
                },
                "macvtap": {
                    "type": "string",
                    "description": "Packets whose destination is on the same host as where they\noriginate from are directly delivered to the target macvtap device. Both\norigin and destination devices need to be in bridge mode for direct delivery.\nIf either one of them is in vepa mode, a VEPA capable bridge is required.\n"
                },
                "networkId": {
                    "type": "string"
                },
                "networkName": {
                    "type": "string"
                },
                "passthrough": {
                    "type": "string",
                    "description": "This feature attaches a virtual function of a SRIOV capable\nNIC directly to a VM without losing the migration capability. All packets are\nsent to the VF/IF of the configured network device. Depending on the\ncapabilities of the device additional prerequisites or limitations may apply;\nfor example, on Linux this requires kernel 2.6.38 or newer.\n\nExample of a `macvtap` interface:\n\n"
                },
                "vepa": {
                    "type": "string",
                    "description": "All VMs' packets are sent to the external bridge. Packets whose\ndestination is a VM on the same host as where the packet originates from are\nsent back to the host by the VEPA capable bridge (today's bridges are\ntypically not VEPA capable).\n"
                },
                "waitForLease": {
                    "type": "boolean",
                    "description": "When creating the domain resource, wait until the\nnetwork interface gets a DHCP lease from libvirt, so that the computed IP\naddresses will be available when the domain is up and the plan applied.\n\nWhen connecting to a LAN, users can specify a target device with:\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "addresses",
                        "hostname",
                        "mac",
                        "networkId",
                        "networkName"
                    ]
                }
            }
        },
        "libvirt:index/DomainNvram:DomainNvram": {
            "properties": {
                "file": {
                    "type": "string",
                    "description": "The filename to use as the block device for this disk (read-only)\n",
                    "willReplaceOnChanges": true
                },
                "template": {
                    "type": "string",
                    "description": "path to the file used to override variables from the master NVRAM\nstore.\n\nSo you should typically use the firmware as this,\n\n",
                    "willReplaceOnChanges": true
                }
            },
            "type": "object",
            "required": [
                "file"
            ]
        },
        "libvirt:index/DomainTpm:DomainTpm": {
            "properties": {
                "backendDevicePath": {
                    "type": "string",
                    "description": "Path to TPM device on the host, ex: `/dev/tpm0`\n\nAdditional attributes when `backend_type` is \"emulator\":\n",
                    "willReplaceOnChanges": true
                },
                "backendEncryptionSecret": {
                    "type": "string",
                    "description": "[Secret object](https://libvirt.org/formatsecret.html) for encrypting the TPM state\n",
                    "willReplaceOnChanges": true
                },
                "backendPersistentState": {
                    "type": "boolean",
                    "description": "Keep the TPM state when a transient domain is powered off or undefined\n",
                    "willReplaceOnChanges": true
                },
                "backendType": {
                    "type": "string",
                    "description": "TPM backend, either `passthrough` or `emulator` (default: `emulator`)\n\nAdditional attributes when `backend_type` is \"passthrough\":\n",
                    "willReplaceOnChanges": true
                },
                "backendVersion": {
                    "type": "string",
                    "description": "TPM version\n",
                    "willReplaceOnChanges": true
                },
                "model": {
                    "type": "string",
                    "description": "TPM model provided to the guest\n",
                    "willReplaceOnChanges": true
                }
            },
            "type": "object"
        },
        "libvirt:index/DomainVideo:DomainVideo": {
            "properties": {
                "type": {
                    "type": "string",
                    "description": "The type of hypervisor to use for the domain.  Defaults to `kvm`, other values can be found [here](https://libvirt.org/formatdomain.html#id1)\n"
                }
            },
            "type": "object"
        },
        "libvirt:index/DomainXml:DomainXml": {
            "properties": {
                "xslt": {
                    "type": "string",
                    "willReplaceOnChanges": true
                }
            },
            "type": "object"
        },
        "libvirt:index/NetworkDhcp:NetworkDhcp": {
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "description": "when false, disable the DHCP server\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "enabled"
                    ]
                }
            }
        },
        "libvirt:index/NetworkDns:NetworkDns": {
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "description": "when false, disable the DHCP server\n"
                },
                "forwarders": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/libvirt:index/NetworkDnsForwarder:NetworkDnsForwarder"
                    },
                    "description": "Either `address`, `domain`, or both must be set\n",
                    "willReplaceOnChanges": true
                },
                "hosts": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/libvirt:index/NetworkDnsHost:NetworkDnsHost"
                    },
                    "description": "a DNS host entry block. You can have one or more of these\nblocks in your DNS definition. You must specify both `ip` and `hostname`.\n\nAn advanced example of round-robin DNS (using DNS host templates) follows:\n\n"
                },
                "localOnly": {
                    "type": "boolean",
                    "description": "true/false: true means 'do not forward unresolved requests for this domain to the part DNS server\n"
                },
                "srvs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/libvirt:index/NetworkDnsSrv:NetworkDnsSrv"
                    },
                    "description": "a DNS SRV entry block. You can have one or more of these blocks\nin your DNS definition. You must specify `service` and `protocol`.\n",
                    "willReplaceOnChanges": true
                }
            },
            "type": "object"
        },
        "libvirt:index/NetworkDnsForwarder:NetworkDnsForwarder": {
            "properties": {
                "address": {
                    "type": "string",
                    "willReplaceOnChanges": true
                },
                "domain": {
                    "type": "string",
                    "description": "The domain used by the DNS server.\n",
                    "willReplaceOnChanges": true
                }
            },
            "type": "object"
        },
        "libvirt:index/NetworkDnsHost:NetworkDnsHost": {
            "properties": {
                "hostname": {
                    "type": "string"
                },
                "ip": {
                    "type": "string"
                }
            },
            "type": "object"
        },
        "libvirt:index/NetworkDnsSrv:NetworkDnsSrv": {
            "properties": {
                "domain": {
                    "type": "string",
                    "description": "The domain used by the DNS server.\n",
                    "willReplaceOnChanges": true
                },
                "port": {
                    "type": "string",
                    "willReplaceOnChanges": true
                },
                "priority": {
                    "type": "string",
                    "willReplaceOnChanges": true
                },
                "protocol": {
                    "type": "string",
                    "willReplaceOnChanges": true
                },
                "service": {
                    "type": "string",
                    "willReplaceOnChanges": true
                },
                "target": {
                    "type": "string",
                    "willReplaceOnChanges": true
                },
                "weight": {
                    "type": "string",
                    "willReplaceOnChanges": true
                }
            },
            "type": "object"
        },
        "libvirt:index/NetworkDnsmasqOptions:NetworkDnsmasqOptions": {
            "properties": {
                "options": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/libvirt:index/NetworkDnsmasqOptionsOption:NetworkDnsmasqOptionsOption"
                    },
                    "description": "a Dnsmasq option entry block. You can have one or more of these\nblocks in your definition. You must specify `option_name` while `option_value` is\noptional to support value-less options.\n\nAn example of setting Dnsmasq options (using Dnsmasq option templates) follows:\n\n"
                }
            },
            "type": "object"
        },
        "libvirt:index/NetworkDnsmasqOptionsOption:NetworkDnsmasqOptionsOption": {
            "properties": {
                "optionName": {
                    "type": "string"
                },
                "optionValue": {
                    "type": "string"
                }
            },
            "type": "object"
        },
        "libvirt:index/NetworkRoute:NetworkRoute": {
            "properties": {
                "cidr": {
                    "type": "string"
                },
                "gateway": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "cidr",
                "gateway"
            ]
        },
        "libvirt:index/NetworkXml:NetworkXml": {
            "properties": {
                "xslt": {
                    "type": "string",
                    "willReplaceOnChanges": true
                }
            },
            "type": "object"
        },
        "libvirt:index/PoolXml:PoolXml": {
            "properties": {
                "xslt": {
                    "type": "string",
                    "willReplaceOnChanges": true
                }
            },
            "type": "object"
        },
        "libvirt:index/VolumeXml:VolumeXml": {
            "properties": {
                "xslt": {
                    "type": "string",
                    "willReplaceOnChanges": true
                }
            },
            "type": "object"
        }
    },
    "provider": {
        "description": "The provider type for the libvirt package. By default, resources use package-wide configuration\nsettings, however an explicit `Provider` instance may be created and passed during resource\nconstruction to achieve fine-grained programmatic control over provider settings. See the\n[documentation](https://www.pulumi.com/docs/reference/programming-model/#providers) for more information.\n",
        "properties": {
            "uri": {
                "type": "string",
                "description": "libvirt connection URI for operations. See https://libvirt.org/uri.html\n"
            }
        },
        "inputProperties": {
            "uri": {
                "type": "string",
                "description": "libvirt connection URI for operations. See https://libvirt.org/uri.html\n",
                "defaultInfo": {
                    "environment": [
                        "LIBVIRT_DEFAULT_URI"
                    ]
                }
            }
        }
    },
    "resources": {
        "libvirt:index/cloudInitDisk:CloudInitDisk": {
            "properties": {
                "metaData": {
                    "type": "string",
                    "description": "cloud-init user data.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A unique name for the resource, required by libvirt.\n"
                },
                "networkConfig": {
                    "type": "string",
                    "description": "cloud-init network-config data.\n"
                },
                "pool": {
                    "type": "string",
                    "description": "The pool where the resource will be created.\nIf not given, the `default` pool will be used.\nFor user_data, network_config and meta_data parameters have a look at upstream doc:\nhttp://cloudinit.readthedocs.io/en/latest/topics/datasources/nocloud.html#datasource-nocloud\n"
                },
                "userData": {
                    "type": "string",
                    "description": "cloud-init user data.\n"
                }
            },
            "required": [
                "name"
            ],
            "inputProperties": {
                "metaData": {
                    "type": "string",
                    "description": "cloud-init user data.\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "A unique name for the resource, required by libvirt.\n",
                    "willReplaceOnChanges": true
                },
                "networkConfig": {
                    "type": "string",
                    "description": "cloud-init network-config data.\n",
                    "willReplaceOnChanges": true
                },
                "pool": {
                    "type": "string",
                    "description": "The pool where the resource will be created.\nIf not given, the `default` pool will be used.\nFor user_data, network_config and meta_data parameters have a look at upstream doc:\nhttp://cloudinit.readthedocs.io/en/latest/topics/datasources/nocloud.html#datasource-nocloud\n",
                    "willReplaceOnChanges": true
                },
                "userData": {
                    "type": "string",
                    "description": "cloud-init user data.\n",
                    "willReplaceOnChanges": true
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering CloudInitDisk resources.\n",
                "properties": {
                    "metaData": {
                        "type": "string",
                        "description": "cloud-init user data.\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "A unique name for the resource, required by libvirt.\n",
                        "willReplaceOnChanges": true
                    },
                    "networkConfig": {
                        "type": "string",
                        "description": "cloud-init network-config data.\n",
                        "willReplaceOnChanges": true
                    },
                    "pool": {
                        "type": "string",
                        "description": "The pool where the resource will be created.\nIf not given, the `default` pool will be used.\nFor user_data, network_config and meta_data parameters have a look at upstream doc:\nhttp://cloudinit.readthedocs.io/en/latest/topics/datasources/nocloud.html#datasource-nocloud\n",
                        "willReplaceOnChanges": true
                    },
                    "userData": {
                        "type": "string",
                        "description": "cloud-init user data.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "libvirt:index/domain:Domain": {
            "description": "Manages a VM domain resource within libvirt. For more information see\n[the official documentation](https://libvirt.org/formatdomain.html).\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as libvirt from \"@pulumi/libvirt\";\n\nconst _default = new libvirt.Domain(\"default\", {name: \"test\"});\n```\n```python\nimport pulumi\nimport pulumi_libvirt as libvirt\n\ndefault = libvirt.Domain(\"default\", name=\"test\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Libvirt = Pulumi.Libvirt;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var @default = new Libvirt.Domain(\"default\", new()\n    {\n        Name = \"test\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-libvirt/sdk/go/libvirt\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := libvirt.NewDomain(ctx, \"default\", \u0026libvirt.DomainArgs{\n\t\t\tName: pulumi.String(\"test\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.libvirt.Domain;\nimport com.pulumi.libvirt.DomainArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var default_ = new Domain(\"default\", DomainArgs.builder()        \n            .name(\"test\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  default:\n    type: libvirt:Domain\n    properties:\n      name: test\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "properties": {
                "arch": {
                    "type": "string",
                    "description": "The architecture for the VM (probably x86_64 or i686),\nyou normally won't need to set this unless you are building a special VM\n"
                },
                "autostart": {
                    "type": "boolean",
                    "description": "Set to `true` to start the domain on host boot up.\nIf not specified `false` is assumed.\n"
                },
                "bootDevices": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/libvirt:index/DomainBootDevice:DomainBootDevice"
                    },
                    "description": "A list of devices (dev) which defines boot order. Example\nbelow.\n"
                },
                "cloudinit": {
                    "type": "string",
                    "description": "The `libvirt.CloudInitDisk` disk that has to be used by\nthe domain. This is going to be attached as a CDROM ISO. Changing the\ncloud-init won't cause the domain to be recreated, however the change will\nhave effect on the next reboot.\n"
                },
                "cmdlines": {
                    "type": "array",
                    "items": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        }
                    },
                    "description": "Arguments to the kernel\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as libvirt from \"@pulumi/libvirt\";\n\nconst domain_suse = new libvirt.Domain(\"domain-suse\", {\n    name: \"suse\",\n    memory: 1024,\n    vcpu: 1,\n    kernel: kernel.id,\n    cmdlines: [{\n        arg1: \"value1\",\n        arg2: \"value2\",\n        _: \"rw nosplash\",\n    }],\n});\n```\n```python\nimport pulumi\nimport pulumi_libvirt as libvirt\n\ndomain_suse = libvirt.Domain(\"domain-suse\",\n    name=\"suse\",\n    memory=1024,\n    vcpu=1,\n    kernel=kernel[\"id\"],\n    cmdlines=[{\n        \"arg1\": \"value1\",\n        \"arg2\": \"value2\",\n        \"_\": \"rw nosplash\",\n    }])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Libvirt = Pulumi.Libvirt;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var domain_suse = new Libvirt.Domain(\"domain-suse\", new()\n    {\n        Name = \"suse\",\n        Memory = 1024,\n        Vcpu = 1,\n        Kernel = kernel.Id,\n        Cmdlines = new[]\n        {\n            \n            {\n                { \"arg1\", \"value1\" },\n                { \"arg2\", \"value2\" },\n                { \"_\", \"rw nosplash\" },\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-libvirt/sdk/go/libvirt\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := libvirt.NewDomain(ctx, \"domain-suse\", \u0026libvirt.DomainArgs{\n\t\t\tName:   pulumi.String(\"suse\"),\n\t\t\tMemory: pulumi.Int(1024),\n\t\t\tVcpu:   pulumi.Int(1),\n\t\t\tKernel: pulumi.Any(kernel.Id),\n\t\t\tCmdlines: pulumi.MapArray{\n\t\t\t\tpulumi.Map{\n\t\t\t\t\t\"arg1\": pulumi.Any(\"value1\"),\n\t\t\t\t\t\"arg2\": pulumi.Any(\"value2\"),\n\t\t\t\t\t\"_\":    pulumi.Any(\"rw nosplash\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.libvirt.Domain;\nimport com.pulumi.libvirt.DomainArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var domain_suse = new Domain(\"domain-suse\", DomainArgs.builder()        \n            .name(\"suse\")\n            .memory(\"1024\")\n            .vcpu(1)\n            .kernel(kernel.id())\n            .cmdlines(Map.ofEntries(\n                Map.entry(\"arg1\", \"value1\"),\n                Map.entry(\"arg2\", \"value2\"),\n                Map.entry(\"_\", \"rw nosplash\")\n            ))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  domain-suse:\n    type: libvirt:Domain\n    properties:\n      name: suse\n      memory: '1024'\n      vcpu: 1\n      kernel: ${kernel.id}\n      cmdlines:\n        - arg1: value1\n          arg2: value2\n          _: rw nosplash\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\nKernel params that don't have a keyword identifier can be specified using the\nspecial `\"_\"` keyword. Multiple keyword-less params have to be specified using\nthe same `\"_\"` keyword, like in the example above.\n\nAlso note that the `cmd` block is actually a list of maps, so it is possible to\ndeclare several of them by using either the literal list and map syntax as in\nthe following examples:\n\n"
                },
                "consoles": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/libvirt:index/DomainConsole:DomainConsole"
                    }
                },
                "coreosIgnition": {
                    "type": "string",
                    "description": "The\n[libvirt.Ignition](https://www.terraform.io/docs/providers/libvirt/r/coreos_ignition.html) resource\nthat is to be used by the CoreOS domain.\n"
                },
                "cpu": {
                    "$ref": "#/types/libvirt:index/DomainCpu:DomainCpu",
                    "description": "Configures CPU mode. See below for more\ndetails.\n"
                },
                "description": {
                    "type": "string",
                    "description": "The description for domain.\nChanging this forces a new resource to be created.\nThis data is not used by libvirt in any way, it can contain any information the user wants.\n"
                },
                "disks": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/libvirt:index/DomainDisk:DomainDisk"
                    },
                    "description": "An array of one or more disks to attach to the domain. The\n`disk` object structure is documented below.\n"
                },
                "emulator": {
                    "type": "string",
                    "description": "The path of the emulator to use\n"
                },
                "filesystems": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/libvirt:index/DomainFilesystem:DomainFilesystem"
                    },
                    "description": "An array of one or more host filesystems to attach to\nthe domain. The `filesystem` object structure is documented\nbelow.\n"
                },
                "firmware": {
                    "type": "string",
                    "description": "The UEFI rom images for exercising UEFI secure boot in a qemu\nenvironment. Users should usually specify one of the standard _Open Virtual Machine\nFirmware_ (_OVMF_) images available for their distributions. The file will be opened\nread-only.\n"
                },
                "fwCfgName": {
                    "type": "string",
                    "description": "The name of the firmware config path where ignition file is stored: default is `opt/com.coreos/config`. If you are using [Flatcar Linux](https://docs.flatcar-linux.org/os/booting-with-libvirt/#creating-the-domain-xml), the value is `opt/org.flatcar-linux/config`.\n"
                },
                "graphics": {
                    "$ref": "#/types/libvirt:index/DomainGraphics:DomainGraphics"
                },
                "initrd": {
                    "type": "string",
                    "description": "The path of the initrd to boot.\n\nYou can use it in the same way as the kernel.\n"
                },
                "kernel": {
                    "type": "string",
                    "description": "The path of the kernel to boot\n\nIf you are using a qcow2 volume, you can pass the id of the volume (eg. `${libvirt_volume.kernel.id}`)\nas they are local to the hypervisor.\n\nGiven that you can define a volume from a remote http file, this means, you can also have remote kernels.\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as libvirt from \"@pulumi/libvirt\";\n\nconst kernel = new libvirt.Volume(\"kernel\", {\n    source: \"http://download.opensuse.org/tumbleweed/repo/oss/boot/x86_64/loader/linux\",\n    name: \"kernel\",\n    pool: \"default\",\n    format: \"raw\",\n});\nconst domain_suse = new libvirt.Domain(\"domain-suse\", {\n    name: \"suse\",\n    memory: 1024,\n    vcpu: 1,\n    kernel: kernel.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_libvirt as libvirt\n\nkernel = libvirt.Volume(\"kernel\",\n    source=\"http://download.opensuse.org/tumbleweed/repo/oss/boot/x86_64/loader/linux\",\n    name=\"kernel\",\n    pool=\"default\",\n    format=\"raw\")\ndomain_suse = libvirt.Domain(\"domain-suse\",\n    name=\"suse\",\n    memory=1024,\n    vcpu=1,\n    kernel=kernel.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Libvirt = Pulumi.Libvirt;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var kernel = new Libvirt.Volume(\"kernel\", new()\n    {\n        Source = \"http://download.opensuse.org/tumbleweed/repo/oss/boot/x86_64/loader/linux\",\n        Name = \"kernel\",\n        Pool = \"default\",\n        Format = \"raw\",\n    });\n\n    var domain_suse = new Libvirt.Domain(\"domain-suse\", new()\n    {\n        Name = \"suse\",\n        Memory = 1024,\n        Vcpu = 1,\n        Kernel = kernel.Id,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-libvirt/sdk/go/libvirt\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tkernel, err := libvirt.NewVolume(ctx, \"kernel\", \u0026libvirt.VolumeArgs{\n\t\t\tSource: pulumi.String(\"http://download.opensuse.org/tumbleweed/repo/oss/boot/x86_64/loader/linux\"),\n\t\t\tName:   pulumi.String(\"kernel\"),\n\t\t\tPool:   pulumi.String(\"default\"),\n\t\t\tFormat: pulumi.String(\"raw\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = libvirt.NewDomain(ctx, \"domain-suse\", \u0026libvirt.DomainArgs{\n\t\t\tName:   pulumi.String(\"suse\"),\n\t\t\tMemory: pulumi.Int(1024),\n\t\t\tVcpu:   pulumi.Int(1),\n\t\t\tKernel: kernel.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.libvirt.Volume;\nimport com.pulumi.libvirt.VolumeArgs;\nimport com.pulumi.libvirt.Domain;\nimport com.pulumi.libvirt.DomainArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var kernel = new Volume(\"kernel\", VolumeArgs.builder()        \n            .source(\"http://download.opensuse.org/tumbleweed/repo/oss/boot/x86_64/loader/linux\")\n            .name(\"kernel\")\n            .pool(\"default\")\n            .format(\"raw\")\n            .build());\n\n        var domain_suse = new Domain(\"domain-suse\", DomainArgs.builder()        \n            .name(\"suse\")\n            .memory(\"1024\")\n            .vcpu(1)\n            .kernel(kernel.id())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  kernel:\n    type: libvirt:Volume\n    properties:\n      source: http://download.opensuse.org/tumbleweed/repo/oss/boot/x86_64/loader/linux\n      name: kernel\n      pool: default\n      format: raw\n  domain-suse:\n    type: libvirt:Domain\n    properties:\n      name: suse\n      memory: '1024'\n      vcpu: 1\n      kernel: ${kernel.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n"
                },
                "machine": {
                    "type": "string",
                    "description": "The machine type,\nyou normally won't need to set this unless you are running on a platform that\ndefaults to the wrong machine type for your template\n"
                },
                "memory": {
                    "type": "integer",
                    "description": "The amount of memory in MiB. If not specified the domain\nwill be created with 512 MiB of memory be used.\n"
                },
                "metadata": {
                    "type": "string"
                },
                "name": {
                    "type": "string",
                    "description": "A unique name for the resource, required by libvirt.\nChanging this forces a new resource to be created.\n"
                },
                "networkInterfaces": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/libvirt:index/DomainNetworkInterface:DomainNetworkInterface"
                    },
                    "description": "An array of one or more network interfaces to\nattach to the domain. The `network_interface` object structure is documented\nbelow.\n"
                },
                "nvram": {
                    "$ref": "#/types/libvirt:index/DomainNvram:DomainNvram",
                    "description": "this block allows specifying the following attributes related to the _nvram_:\n"
                },
                "qemuAgent": {
                    "type": "boolean",
                    "description": "By default is disabled, set to true for enabling it. More info [qemu-agent](https://wiki.libvirt.org/page/Qemu_guest_agent).\n"
                },
                "running": {
                    "type": "boolean",
                    "description": "Use `false` to turn off the instance. If not specified,\ntrue is assumed and the instance, if stopped, will be started at next apply.\n"
                },
                "tpm": {
                    "$ref": "#/types/libvirt:index/DomainTpm:DomainTpm",
                    "description": "TPM device to attach to the domain. The `tpm` object structure is documented below.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The type of hypervisor to use for the domain.  Defaults to `kvm`, other values can be found [here](https://libvirt.org/formatdomain.html#id1)\n"
                },
                "vcpu": {
                    "type": "integer",
                    "description": "The amount of virtual CPUs. If not specified, a single CPU\nwill be created.\n"
                },
                "video": {
                    "$ref": "#/types/libvirt:index/DomainVideo:DomainVideo"
                },
                "xml": {
                    "$ref": "#/types/libvirt:index/DomainXml:DomainXml"
                }
            },
            "required": [
                "arch",
                "autostart",
                "cpu",
                "emulator",
                "machine",
                "name"
            ],
            "inputProperties": {
                "arch": {
                    "type": "string",
                    "description": "The architecture for the VM (probably x86_64 or i686),\nyou normally won't need to set this unless you are building a special VM\n"
                },
                "autostart": {
                    "type": "boolean",
                    "description": "Set to `true` to start the domain on host boot up.\nIf not specified `false` is assumed.\n"
                },
                "bootDevices": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/libvirt:index/DomainBootDevice:DomainBootDevice"
                    },
                    "description": "A list of devices (dev) which defines boot order. Example\nbelow.\n"
                },
                "cloudinit": {
                    "type": "string",
                    "description": "The `libvirt.CloudInitDisk` disk that has to be used by\nthe domain. This is going to be attached as a CDROM ISO. Changing the\ncloud-init won't cause the domain to be recreated, however the change will\nhave effect on the next reboot.\n"
                },
                "cmdlines": {
                    "type": "array",
                    "items": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        }
                    },
                    "description": "Arguments to the kernel\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as libvirt from \"@pulumi/libvirt\";\n\nconst domain_suse = new libvirt.Domain(\"domain-suse\", {\n    name: \"suse\",\n    memory: 1024,\n    vcpu: 1,\n    kernel: kernel.id,\n    cmdlines: [{\n        arg1: \"value1\",\n        arg2: \"value2\",\n        _: \"rw nosplash\",\n    }],\n});\n```\n```python\nimport pulumi\nimport pulumi_libvirt as libvirt\n\ndomain_suse = libvirt.Domain(\"domain-suse\",\n    name=\"suse\",\n    memory=1024,\n    vcpu=1,\n    kernel=kernel[\"id\"],\n    cmdlines=[{\n        \"arg1\": \"value1\",\n        \"arg2\": \"value2\",\n        \"_\": \"rw nosplash\",\n    }])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Libvirt = Pulumi.Libvirt;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var domain_suse = new Libvirt.Domain(\"domain-suse\", new()\n    {\n        Name = \"suse\",\n        Memory = 1024,\n        Vcpu = 1,\n        Kernel = kernel.Id,\n        Cmdlines = new[]\n        {\n            \n            {\n                { \"arg1\", \"value1\" },\n                { \"arg2\", \"value2\" },\n                { \"_\", \"rw nosplash\" },\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-libvirt/sdk/go/libvirt\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := libvirt.NewDomain(ctx, \"domain-suse\", \u0026libvirt.DomainArgs{\n\t\t\tName:   pulumi.String(\"suse\"),\n\t\t\tMemory: pulumi.Int(1024),\n\t\t\tVcpu:   pulumi.Int(1),\n\t\t\tKernel: pulumi.Any(kernel.Id),\n\t\t\tCmdlines: pulumi.MapArray{\n\t\t\t\tpulumi.Map{\n\t\t\t\t\t\"arg1\": pulumi.Any(\"value1\"),\n\t\t\t\t\t\"arg2\": pulumi.Any(\"value2\"),\n\t\t\t\t\t\"_\":    pulumi.Any(\"rw nosplash\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.libvirt.Domain;\nimport com.pulumi.libvirt.DomainArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var domain_suse = new Domain(\"domain-suse\", DomainArgs.builder()        \n            .name(\"suse\")\n            .memory(\"1024\")\n            .vcpu(1)\n            .kernel(kernel.id())\n            .cmdlines(Map.ofEntries(\n                Map.entry(\"arg1\", \"value1\"),\n                Map.entry(\"arg2\", \"value2\"),\n                Map.entry(\"_\", \"rw nosplash\")\n            ))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  domain-suse:\n    type: libvirt:Domain\n    properties:\n      name: suse\n      memory: '1024'\n      vcpu: 1\n      kernel: ${kernel.id}\n      cmdlines:\n        - arg1: value1\n          arg2: value2\n          _: rw nosplash\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\nKernel params that don't have a keyword identifier can be specified using the\nspecial `\"_\"` keyword. Multiple keyword-less params have to be specified using\nthe same `\"_\"` keyword, like in the example above.\n\nAlso note that the `cmd` block is actually a list of maps, so it is possible to\ndeclare several of them by using either the literal list and map syntax as in\nthe following examples:\n\n",
                    "willReplaceOnChanges": true
                },
                "consoles": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/libvirt:index/DomainConsole:DomainConsole"
                    }
                },
                "coreosIgnition": {
                    "type": "string",
                    "description": "The\n[libvirt.Ignition](https://www.terraform.io/docs/providers/libvirt/r/coreos_ignition.html) resource\nthat is to be used by the CoreOS domain.\n",
                    "willReplaceOnChanges": true
                },
                "cpu": {
                    "$ref": "#/types/libvirt:index/DomainCpu:DomainCpu",
                    "description": "Configures CPU mode. See below for more\ndetails.\n",
                    "willReplaceOnChanges": true
                },
                "description": {
                    "type": "string",
                    "description": "The description for domain.\nChanging this forces a new resource to be created.\nThis data is not used by libvirt in any way, it can contain any information the user wants.\n",
                    "willReplaceOnChanges": true
                },
                "disks": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/libvirt:index/DomainDisk:DomainDisk"
                    },
                    "description": "An array of one or more disks to attach to the domain. The\n`disk` object structure is documented below.\n",
                    "willReplaceOnChanges": true
                },
                "emulator": {
                    "type": "string",
                    "description": "The path of the emulator to use\n"
                },
                "filesystems": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/libvirt:index/DomainFilesystem:DomainFilesystem"
                    },
                    "description": "An array of one or more host filesystems to attach to\nthe domain. The `filesystem` object structure is documented\nbelow.\n",
                    "willReplaceOnChanges": true
                },
                "firmware": {
                    "type": "string",
                    "description": "The UEFI rom images for exercising UEFI secure boot in a qemu\nenvironment. Users should usually specify one of the standard _Open Virtual Machine\nFirmware_ (_OVMF_) images available for their distributions. The file will be opened\nread-only.\n",
                    "willReplaceOnChanges": true
                },
                "fwCfgName": {
                    "type": "string",
                    "description": "The name of the firmware config path where ignition file is stored: default is `opt/com.coreos/config`. If you are using [Flatcar Linux](https://docs.flatcar-linux.org/os/booting-with-libvirt/#creating-the-domain-xml), the value is `opt/org.flatcar-linux/config`.\n",
                    "willReplaceOnChanges": true
                },
                "graphics": {
                    "$ref": "#/types/libvirt:index/DomainGraphics:DomainGraphics",
                    "willReplaceOnChanges": true
                },
                "initrd": {
                    "type": "string",
                    "description": "The path of the initrd to boot.\n\nYou can use it in the same way as the kernel.\n"
                },
                "kernel": {
                    "type": "string",
                    "description": "The path of the kernel to boot\n\nIf you are using a qcow2 volume, you can pass the id of the volume (eg. `${libvirt_volume.kernel.id}`)\nas they are local to the hypervisor.\n\nGiven that you can define a volume from a remote http file, this means, you can also have remote kernels.\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as libvirt from \"@pulumi/libvirt\";\n\nconst kernel = new libvirt.Volume(\"kernel\", {\n    source: \"http://download.opensuse.org/tumbleweed/repo/oss/boot/x86_64/loader/linux\",\n    name: \"kernel\",\n    pool: \"default\",\n    format: \"raw\",\n});\nconst domain_suse = new libvirt.Domain(\"domain-suse\", {\n    name: \"suse\",\n    memory: 1024,\n    vcpu: 1,\n    kernel: kernel.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_libvirt as libvirt\n\nkernel = libvirt.Volume(\"kernel\",\n    source=\"http://download.opensuse.org/tumbleweed/repo/oss/boot/x86_64/loader/linux\",\n    name=\"kernel\",\n    pool=\"default\",\n    format=\"raw\")\ndomain_suse = libvirt.Domain(\"domain-suse\",\n    name=\"suse\",\n    memory=1024,\n    vcpu=1,\n    kernel=kernel.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Libvirt = Pulumi.Libvirt;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var kernel = new Libvirt.Volume(\"kernel\", new()\n    {\n        Source = \"http://download.opensuse.org/tumbleweed/repo/oss/boot/x86_64/loader/linux\",\n        Name = \"kernel\",\n        Pool = \"default\",\n        Format = \"raw\",\n    });\n\n    var domain_suse = new Libvirt.Domain(\"domain-suse\", new()\n    {\n        Name = \"suse\",\n        Memory = 1024,\n        Vcpu = 1,\n        Kernel = kernel.Id,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-libvirt/sdk/go/libvirt\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tkernel, err := libvirt.NewVolume(ctx, \"kernel\", \u0026libvirt.VolumeArgs{\n\t\t\tSource: pulumi.String(\"http://download.opensuse.org/tumbleweed/repo/oss/boot/x86_64/loader/linux\"),\n\t\t\tName:   pulumi.String(\"kernel\"),\n\t\t\tPool:   pulumi.String(\"default\"),\n\t\t\tFormat: pulumi.String(\"raw\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = libvirt.NewDomain(ctx, \"domain-suse\", \u0026libvirt.DomainArgs{\n\t\t\tName:   pulumi.String(\"suse\"),\n\t\t\tMemory: pulumi.Int(1024),\n\t\t\tVcpu:   pulumi.Int(1),\n\t\t\tKernel: kernel.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.libvirt.Volume;\nimport com.pulumi.libvirt.VolumeArgs;\nimport com.pulumi.libvirt.Domain;\nimport com.pulumi.libvirt.DomainArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var kernel = new Volume(\"kernel\", VolumeArgs.builder()        \n            .source(\"http://download.opensuse.org/tumbleweed/repo/oss/boot/x86_64/loader/linux\")\n            .name(\"kernel\")\n            .pool(\"default\")\n            .format(\"raw\")\n            .build());\n\n        var domain_suse = new Domain(\"domain-suse\", DomainArgs.builder()        \n            .name(\"suse\")\n            .memory(\"1024\")\n            .vcpu(1)\n            .kernel(kernel.id())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  kernel:\n    type: libvirt:Volume\n    properties:\n      source: http://download.opensuse.org/tumbleweed/repo/oss/boot/x86_64/loader/linux\n      name: kernel\n      pool: default\n      format: raw\n  domain-suse:\n    type: libvirt:Domain\n    properties:\n      name: suse\n      memory: '1024'\n      vcpu: 1\n      kernel: ${kernel.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n"
                },
                "machine": {
                    "type": "string",
                    "description": "The machine type,\nyou normally won't need to set this unless you are running on a platform that\ndefaults to the wrong machine type for your template\n"
                },
                "memory": {
                    "type": "integer",
                    "description": "The amount of memory in MiB. If not specified the domain\nwill be created with 512 MiB of memory be used.\n",
                    "willReplaceOnChanges": true
                },
                "metadata": {
                    "type": "string"
                },
                "name": {
                    "type": "string",
                    "description": "A unique name for the resource, required by libvirt.\nChanging this forces a new resource to be created.\n",
                    "willReplaceOnChanges": true
                },
                "networkInterfaces": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/libvirt:index/DomainNetworkInterface:DomainNetworkInterface"
                    },
                    "description": "An array of one or more network interfaces to\nattach to the domain. The `network_interface` object structure is documented\nbelow.\n"
                },
                "nvram": {
                    "$ref": "#/types/libvirt:index/DomainNvram:DomainNvram",
                    "description": "this block allows specifying the following attributes related to the _nvram_:\n",
                    "willReplaceOnChanges": true
                },
                "qemuAgent": {
                    "type": "boolean",
                    "description": "By default is disabled, set to true for enabling it. More info [qemu-agent](https://wiki.libvirt.org/page/Qemu_guest_agent).\n"
                },
                "running": {
                    "type": "boolean",
                    "description": "Use `false` to turn off the instance. If not specified,\ntrue is assumed and the instance, if stopped, will be started at next apply.\n"
                },
                "tpm": {
                    "$ref": "#/types/libvirt:index/DomainTpm:DomainTpm",
                    "description": "TPM device to attach to the domain. The `tpm` object structure is documented below.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The type of hypervisor to use for the domain.  Defaults to `kvm`, other values can be found [here](https://libvirt.org/formatdomain.html#id1)\n",
                    "willReplaceOnChanges": true
                },
                "vcpu": {
                    "type": "integer",
                    "description": "The amount of virtual CPUs. If not specified, a single CPU\nwill be created.\n",
                    "willReplaceOnChanges": true
                },
                "video": {
                    "$ref": "#/types/libvirt:index/DomainVideo:DomainVideo"
                },
                "xml": {
                    "$ref": "#/types/libvirt:index/DomainXml:DomainXml"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Domain resources.\n",
                "properties": {
                    "arch": {
                        "type": "string",
                        "description": "The architecture for the VM (probably x86_64 or i686),\nyou normally won't need to set this unless you are building a special VM\n"
                    },
                    "autostart": {
                        "type": "boolean",
                        "description": "Set to `true` to start the domain on host boot up.\nIf not specified `false` is assumed.\n"
                    },
                    "bootDevices": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/libvirt:index/DomainBootDevice:DomainBootDevice"
                        },
                        "description": "A list of devices (dev) which defines boot order. Example\nbelow.\n"
                    },
                    "cloudinit": {
                        "type": "string",
                        "description": "The `libvirt.CloudInitDisk` disk that has to be used by\nthe domain. This is going to be attached as a CDROM ISO. Changing the\ncloud-init won't cause the domain to be recreated, however the change will\nhave effect on the next reboot.\n"
                    },
                    "cmdlines": {
                        "type": "array",
                        "items": {
                            "type": "object",
                            "additionalProperties": {
                                "$ref": "pulumi.json#/Any"
                            }
                        },
                        "description": "Arguments to the kernel\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as libvirt from \"@pulumi/libvirt\";\n\nconst domain_suse = new libvirt.Domain(\"domain-suse\", {\n    name: \"suse\",\n    memory: 1024,\n    vcpu: 1,\n    kernel: kernel.id,\n    cmdlines: [{\n        arg1: \"value1\",\n        arg2: \"value2\",\n        _: \"rw nosplash\",\n    }],\n});\n```\n```python\nimport pulumi\nimport pulumi_libvirt as libvirt\n\ndomain_suse = libvirt.Domain(\"domain-suse\",\n    name=\"suse\",\n    memory=1024,\n    vcpu=1,\n    kernel=kernel[\"id\"],\n    cmdlines=[{\n        \"arg1\": \"value1\",\n        \"arg2\": \"value2\",\n        \"_\": \"rw nosplash\",\n    }])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Libvirt = Pulumi.Libvirt;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var domain_suse = new Libvirt.Domain(\"domain-suse\", new()\n    {\n        Name = \"suse\",\n        Memory = 1024,\n        Vcpu = 1,\n        Kernel = kernel.Id,\n        Cmdlines = new[]\n        {\n            \n            {\n                { \"arg1\", \"value1\" },\n                { \"arg2\", \"value2\" },\n                { \"_\", \"rw nosplash\" },\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-libvirt/sdk/go/libvirt\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := libvirt.NewDomain(ctx, \"domain-suse\", \u0026libvirt.DomainArgs{\n\t\t\tName:   pulumi.String(\"suse\"),\n\t\t\tMemory: pulumi.Int(1024),\n\t\t\tVcpu:   pulumi.Int(1),\n\t\t\tKernel: pulumi.Any(kernel.Id),\n\t\t\tCmdlines: pulumi.MapArray{\n\t\t\t\tpulumi.Map{\n\t\t\t\t\t\"arg1\": pulumi.Any(\"value1\"),\n\t\t\t\t\t\"arg2\": pulumi.Any(\"value2\"),\n\t\t\t\t\t\"_\":    pulumi.Any(\"rw nosplash\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.libvirt.Domain;\nimport com.pulumi.libvirt.DomainArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var domain_suse = new Domain(\"domain-suse\", DomainArgs.builder()        \n            .name(\"suse\")\n            .memory(\"1024\")\n            .vcpu(1)\n            .kernel(kernel.id())\n            .cmdlines(Map.ofEntries(\n                Map.entry(\"arg1\", \"value1\"),\n                Map.entry(\"arg2\", \"value2\"),\n                Map.entry(\"_\", \"rw nosplash\")\n            ))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  domain-suse:\n    type: libvirt:Domain\n    properties:\n      name: suse\n      memory: '1024'\n      vcpu: 1\n      kernel: ${kernel.id}\n      cmdlines:\n        - arg1: value1\n          arg2: value2\n          _: rw nosplash\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\nKernel params that don't have a keyword identifier can be specified using the\nspecial `\"_\"` keyword. Multiple keyword-less params have to be specified using\nthe same `\"_\"` keyword, like in the example above.\n\nAlso note that the `cmd` block is actually a list of maps, so it is possible to\ndeclare several of them by using either the literal list and map syntax as in\nthe following examples:\n\n",
                        "willReplaceOnChanges": true
                    },
                    "consoles": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/libvirt:index/DomainConsole:DomainConsole"
                        }
                    },
                    "coreosIgnition": {
                        "type": "string",
                        "description": "The\n[libvirt.Ignition](https://www.terraform.io/docs/providers/libvirt/r/coreos_ignition.html) resource\nthat is to be used by the CoreOS domain.\n",
                        "willReplaceOnChanges": true
                    },
                    "cpu": {
                        "$ref": "#/types/libvirt:index/DomainCpu:DomainCpu",
                        "description": "Configures CPU mode. See below for more\ndetails.\n",
                        "willReplaceOnChanges": true
                    },
                    "description": {
                        "type": "string",
                        "description": "The description for domain.\nChanging this forces a new resource to be created.\nThis data is not used by libvirt in any way, it can contain any information the user wants.\n",
                        "willReplaceOnChanges": true
                    },
                    "disks": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/libvirt:index/DomainDisk:DomainDisk"
                        },
                        "description": "An array of one or more disks to attach to the domain. The\n`disk` object structure is documented below.\n",
                        "willReplaceOnChanges": true
                    },
                    "emulator": {
                        "type": "string",
                        "description": "The path of the emulator to use\n"
                    },
                    "filesystems": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/libvirt:index/DomainFilesystem:DomainFilesystem"
                        },
                        "description": "An array of one or more host filesystems to attach to\nthe domain. The `filesystem` object structure is documented\nbelow.\n",
                        "willReplaceOnChanges": true
                    },
                    "firmware": {
                        "type": "string",
                        "description": "The UEFI rom images for exercising UEFI secure boot in a qemu\nenvironment. Users should usually specify one of the standard _Open Virtual Machine\nFirmware_ (_OVMF_) images available for their distributions. The file will be opened\nread-only.\n",
                        "willReplaceOnChanges": true
                    },
                    "fwCfgName": {
                        "type": "string",
                        "description": "The name of the firmware config path where ignition file is stored: default is `opt/com.coreos/config`. If you are using [Flatcar Linux](https://docs.flatcar-linux.org/os/booting-with-libvirt/#creating-the-domain-xml), the value is `opt/org.flatcar-linux/config`.\n",
                        "willReplaceOnChanges": true
                    },
                    "graphics": {
                        "$ref": "#/types/libvirt:index/DomainGraphics:DomainGraphics",
                        "willReplaceOnChanges": true
                    },
                    "initrd": {
                        "type": "string",
                        "description": "The path of the initrd to boot.\n\nYou can use it in the same way as the kernel.\n"
                    },
                    "kernel": {
                        "type": "string",
                        "description": "The path of the kernel to boot\n\nIf you are using a qcow2 volume, you can pass the id of the volume (eg. `${libvirt_volume.kernel.id}`)\nas they are local to the hypervisor.\n\nGiven that you can define a volume from a remote http file, this means, you can also have remote kernels.\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as libvirt from \"@pulumi/libvirt\";\n\nconst kernel = new libvirt.Volume(\"kernel\", {\n    source: \"http://download.opensuse.org/tumbleweed/repo/oss/boot/x86_64/loader/linux\",\n    name: \"kernel\",\n    pool: \"default\",\n    format: \"raw\",\n});\nconst domain_suse = new libvirt.Domain(\"domain-suse\", {\n    name: \"suse\",\n    memory: 1024,\n    vcpu: 1,\n    kernel: kernel.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_libvirt as libvirt\n\nkernel = libvirt.Volume(\"kernel\",\n    source=\"http://download.opensuse.org/tumbleweed/repo/oss/boot/x86_64/loader/linux\",\n    name=\"kernel\",\n    pool=\"default\",\n    format=\"raw\")\ndomain_suse = libvirt.Domain(\"domain-suse\",\n    name=\"suse\",\n    memory=1024,\n    vcpu=1,\n    kernel=kernel.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Libvirt = Pulumi.Libvirt;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var kernel = new Libvirt.Volume(\"kernel\", new()\n    {\n        Source = \"http://download.opensuse.org/tumbleweed/repo/oss/boot/x86_64/loader/linux\",\n        Name = \"kernel\",\n        Pool = \"default\",\n        Format = \"raw\",\n    });\n\n    var domain_suse = new Libvirt.Domain(\"domain-suse\", new()\n    {\n        Name = \"suse\",\n        Memory = 1024,\n        Vcpu = 1,\n        Kernel = kernel.Id,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-libvirt/sdk/go/libvirt\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tkernel, err := libvirt.NewVolume(ctx, \"kernel\", \u0026libvirt.VolumeArgs{\n\t\t\tSource: pulumi.String(\"http://download.opensuse.org/tumbleweed/repo/oss/boot/x86_64/loader/linux\"),\n\t\t\tName:   pulumi.String(\"kernel\"),\n\t\t\tPool:   pulumi.String(\"default\"),\n\t\t\tFormat: pulumi.String(\"raw\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = libvirt.NewDomain(ctx, \"domain-suse\", \u0026libvirt.DomainArgs{\n\t\t\tName:   pulumi.String(\"suse\"),\n\t\t\tMemory: pulumi.Int(1024),\n\t\t\tVcpu:   pulumi.Int(1),\n\t\t\tKernel: kernel.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.libvirt.Volume;\nimport com.pulumi.libvirt.VolumeArgs;\nimport com.pulumi.libvirt.Domain;\nimport com.pulumi.libvirt.DomainArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var kernel = new Volume(\"kernel\", VolumeArgs.builder()        \n            .source(\"http://download.opensuse.org/tumbleweed/repo/oss/boot/x86_64/loader/linux\")\n            .name(\"kernel\")\n            .pool(\"default\")\n            .format(\"raw\")\n            .build());\n\n        var domain_suse = new Domain(\"domain-suse\", DomainArgs.builder()        \n            .name(\"suse\")\n            .memory(\"1024\")\n            .vcpu(1)\n            .kernel(kernel.id())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  kernel:\n    type: libvirt:Volume\n    properties:\n      source: http://download.opensuse.org/tumbleweed/repo/oss/boot/x86_64/loader/linux\n      name: kernel\n      pool: default\n      format: raw\n  domain-suse:\n    type: libvirt:Domain\n    properties:\n      name: suse\n      memory: '1024'\n      vcpu: 1\n      kernel: ${kernel.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n"
                    },
                    "machine": {
                        "type": "string",
                        "description": "The machine type,\nyou normally won't need to set this unless you are running on a platform that\ndefaults to the wrong machine type for your template\n"
                    },
                    "memory": {
                        "type": "integer",
                        "description": "The amount of memory in MiB. If not specified the domain\nwill be created with 512 MiB of memory be used.\n",
                        "willReplaceOnChanges": true
                    },
                    "metadata": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string",
                        "description": "A unique name for the resource, required by libvirt.\nChanging this forces a new resource to be created.\n",
                        "willReplaceOnChanges": true
                    },
                    "networkInterfaces": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/libvirt:index/DomainNetworkInterface:DomainNetworkInterface"
                        },
                        "description": "An array of one or more network interfaces to\nattach to the domain. The `network_interface` object structure is documented\nbelow.\n"
                    },
                    "nvram": {
                        "$ref": "#/types/libvirt:index/DomainNvram:DomainNvram",
                        "description": "this block allows specifying the following attributes related to the _nvram_:\n",
                        "willReplaceOnChanges": true
                    },
                    "qemuAgent": {
                        "type": "boolean",
                        "description": "By default is disabled, set to true for enabling it. More info [qemu-agent](https://wiki.libvirt.org/page/Qemu_guest_agent).\n"
                    },
                    "running": {
                        "type": "boolean",
                        "description": "Use `false` to turn off the instance. If not specified,\ntrue is assumed and the instance, if stopped, will be started at next apply.\n"
                    },
                    "tpm": {
                        "$ref": "#/types/libvirt:index/DomainTpm:DomainTpm",
                        "description": "TPM device to attach to the domain. The `tpm` object structure is documented below.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "The type of hypervisor to use for the domain.  Defaults to `kvm`, other values can be found [here](https://libvirt.org/formatdomain.html#id1)\n",
                        "willReplaceOnChanges": true
                    },
                    "vcpu": {
                        "type": "integer",
                        "description": "The amount of virtual CPUs. If not specified, a single CPU\nwill be created.\n",
                        "willReplaceOnChanges": true
                    },
                    "video": {
                        "$ref": "#/types/libvirt:index/DomainVideo:DomainVideo"
                    },
                    "xml": {
                        "$ref": "#/types/libvirt:index/DomainXml:DomainXml"
                    }
                },
                "type": "object"
            }
        },
        "libvirt:index/ignition:Ignition": {
            "properties": {
                "content": {
                    "type": "string"
                },
                "name": {
                    "type": "string",
                    "description": "A unique name for the resource, required by libvirt.\n"
                },
                "pool": {
                    "type": "string",
                    "description": "The pool where the resource will be created.\nIf not given, the `default` pool will be used.\n"
                }
            },
            "required": [
                "content",
                "name"
            ],
            "inputProperties": {
                "content": {
                    "type": "string",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "A unique name for the resource, required by libvirt.\n",
                    "willReplaceOnChanges": true
                },
                "pool": {
                    "type": "string",
                    "description": "The pool where the resource will be created.\nIf not given, the `default` pool will be used.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "content"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Ignition resources.\n",
                "properties": {
                    "content": {
                        "type": "string",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "A unique name for the resource, required by libvirt.\n",
                        "willReplaceOnChanges": true
                    },
                    "pool": {
                        "type": "string",
                        "description": "The pool where the resource will be created.\nIf not given, the `default` pool will be used.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "libvirt:index/network:Network": {
            "description": "Manages a VM network resource within libvirt. For more information see\n[the official documentation](https://libvirt.org/formatnetwork.html).\n\n",
            "properties": {
                "addresses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of (0 or 1) IPv4 and (0 or 1) IPv6 subnets in\nCIDR notation.  This defines the subnets associated to that network.\nThis argument is also used to define the address on the real host.\nIf `dhcp {  enabled = true }` addresses is also used to define the address range served by\nthe DHCP server.\nNo DHCP server will be started if `addresses` is omitted.\n"
                },
                "autostart": {
                    "type": "boolean",
                    "description": "Set to `true` to start the network on host boot up.\nIf not specified `false` is assumed.\n"
                },
                "bridge": {
                    "type": "string",
                    "description": "The bridge device defines the name of a bridge\ndevice which will be used to construct the virtual network (when not provided,\nit will be automatically obtained by libvirt in `none`, `nat`, `route` and `open` modes).\n"
                },
                "dhcp": {
                    "$ref": "#/types/libvirt:index/NetworkDhcp:NetworkDhcp",
                    "description": "DHCP configuration. \nYou need to use it in conjuction with the adresses variable.\n"
                },
                "dns": {
                    "$ref": "#/types/libvirt:index/NetworkDns:NetworkDns",
                    "description": "configuration of DNS specific settings for the network\n"
                },
                "dnsmasqOptions": {
                    "$ref": "#/types/libvirt:index/NetworkDnsmasqOptions:NetworkDnsmasqOptions",
                    "description": "configuration of Dnsmasq options for the network\nYou need to provide a list of option name and value pairs.\n"
                },
                "domain": {
                    "type": "string",
                    "description": "The domain used by the DNS server.\n"
                },
                "mode": {
                    "type": "string",
                    "description": "One of:\n"
                },
                "mtu": {
                    "type": "integer",
                    "description": "The MTU to set for the underlying network interfaces. When\nnot supplied, libvirt will use the default for the interface, usually 1500.\nLibvirt version 5.1 and greater will advertise this value to nodes via DHCP.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A unique name for the resource, required by libvirt.\nChanging this forces a new resource to be created.\n"
                },
                "routes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/libvirt:index/NetworkRoute:NetworkRoute"
                    },
                    "description": "a list of static routes. A `cidr` and a `gateway` must\nbe provided. The `gateway` must be reachable via the bridge interface.\n"
                },
                "xml": {
                    "$ref": "#/types/libvirt:index/NetworkXml:NetworkXml"
                }
            },
            "required": [
                "autostart",
                "bridge",
                "dhcp",
                "dns",
                "name"
            ],
            "inputProperties": {
                "addresses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of (0 or 1) IPv4 and (0 or 1) IPv6 subnets in\nCIDR notation.  This defines the subnets associated to that network.\nThis argument is also used to define the address on the real host.\nIf `dhcp {  enabled = true }` addresses is also used to define the address range served by\nthe DHCP server.\nNo DHCP server will be started if `addresses` is omitted.\n",
                    "willReplaceOnChanges": true
                },
                "autostart": {
                    "type": "boolean",
                    "description": "Set to `true` to start the network on host boot up.\nIf not specified `false` is assumed.\n"
                },
                "bridge": {
                    "type": "string",
                    "description": "The bridge device defines the name of a bridge\ndevice which will be used to construct the virtual network (when not provided,\nit will be automatically obtained by libvirt in `none`, `nat`, `route` and `open` modes).\n",
                    "willReplaceOnChanges": true
                },
                "dhcp": {
                    "$ref": "#/types/libvirt:index/NetworkDhcp:NetworkDhcp",
                    "description": "DHCP configuration. \nYou need to use it in conjuction with the adresses variable.\n",
                    "willReplaceOnChanges": true
                },
                "dns": {
                    "$ref": "#/types/libvirt:index/NetworkDns:NetworkDns",
                    "description": "configuration of DNS specific settings for the network\n"
                },
                "dnsmasqOptions": {
                    "$ref": "#/types/libvirt:index/NetworkDnsmasqOptions:NetworkDnsmasqOptions",
                    "description": "configuration of Dnsmasq options for the network\nYou need to provide a list of option name and value pairs.\n"
                },
                "domain": {
                    "type": "string",
                    "description": "The domain used by the DNS server.\n",
                    "willReplaceOnChanges": true
                },
                "mode": {
                    "type": "string",
                    "description": "One of:\n",
                    "willReplaceOnChanges": true
                },
                "mtu": {
                    "type": "integer",
                    "description": "The MTU to set for the underlying network interfaces. When\nnot supplied, libvirt will use the default for the interface, usually 1500.\nLibvirt version 5.1 and greater will advertise this value to nodes via DHCP.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A unique name for the resource, required by libvirt.\nChanging this forces a new resource to be created.\n",
                    "willReplaceOnChanges": true
                },
                "routes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/libvirt:index/NetworkRoute:NetworkRoute"
                    },
                    "description": "a list of static routes. A `cidr` and a `gateway` must\nbe provided. The `gateway` must be reachable via the bridge interface.\n",
                    "willReplaceOnChanges": true
                },
                "xml": {
                    "$ref": "#/types/libvirt:index/NetworkXml:NetworkXml",
                    "willReplaceOnChanges": true
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Network resources.\n",
                "properties": {
                    "addresses": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of (0 or 1) IPv4 and (0 or 1) IPv6 subnets in\nCIDR notation.  This defines the subnets associated to that network.\nThis argument is also used to define the address on the real host.\nIf `dhcp {  enabled = true }` addresses is also used to define the address range served by\nthe DHCP server.\nNo DHCP server will be started if `addresses` is omitted.\n",
                        "willReplaceOnChanges": true
                    },
                    "autostart": {
                        "type": "boolean",
                        "description": "Set to `true` to start the network on host boot up.\nIf not specified `false` is assumed.\n"
                    },
                    "bridge": {
                        "type": "string",
                        "description": "The bridge device defines the name of a bridge\ndevice which will be used to construct the virtual network (when not provided,\nit will be automatically obtained by libvirt in `none`, `nat`, `route` and `open` modes).\n",
                        "willReplaceOnChanges": true
                    },
                    "dhcp": {
                        "$ref": "#/types/libvirt:index/NetworkDhcp:NetworkDhcp",
                        "description": "DHCP configuration. \nYou need to use it in conjuction with the adresses variable.\n",
                        "willReplaceOnChanges": true
                    },
                    "dns": {
                        "$ref": "#/types/libvirt:index/NetworkDns:NetworkDns",
                        "description": "configuration of DNS specific settings for the network\n"
                    },
                    "dnsmasqOptions": {
                        "$ref": "#/types/libvirt:index/NetworkDnsmasqOptions:NetworkDnsmasqOptions",
                        "description": "configuration of Dnsmasq options for the network\nYou need to provide a list of option name and value pairs.\n"
                    },
                    "domain": {
                        "type": "string",
                        "description": "The domain used by the DNS server.\n",
                        "willReplaceOnChanges": true
                    },
                    "mode": {
                        "type": "string",
                        "description": "One of:\n",
                        "willReplaceOnChanges": true
                    },
                    "mtu": {
                        "type": "integer",
                        "description": "The MTU to set for the underlying network interfaces. When\nnot supplied, libvirt will use the default for the interface, usually 1500.\nLibvirt version 5.1 and greater will advertise this value to nodes via DHCP.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "A unique name for the resource, required by libvirt.\nChanging this forces a new resource to be created.\n",
                        "willReplaceOnChanges": true
                    },
                    "routes": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/libvirt:index/NetworkRoute:NetworkRoute"
                        },
                        "description": "a list of static routes. A `cidr` and a `gateway` must\nbe provided. The `gateway` must be reachable via the bridge interface.\n",
                        "willReplaceOnChanges": true
                    },
                    "xml": {
                        "$ref": "#/types/libvirt:index/NetworkXml:NetworkXml",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "libvirt:index/pool:Pool": {
            "description": "Manages a storage pool in libvirt. Currently only directory-based storage pool are supported. For more information on\nstorage pools in libvirt, see [the official documentation](https://libvirt.org/formatstorage.html).\n\n**WARNING:** This is experimental API and may change in the future.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as libvirt from \"@pulumi/libvirt\";\n\n// A pool for all cluster volumes\nconst cluster = new libvirt.Pool(\"cluster\", {\n    name: \"cluster\",\n    type: \"dir\",\n    path: \"/home/user/cluster_storage\",\n});\nconst opensuseLeap = new libvirt.Volume(\"opensuse_leap\", {\n    name: \"opensuse_leap\",\n    pool: cluster.name,\n    source: \"http://download.opensuse.org/repositories/Cloud:/Images:/Leap_42.1/images/openSUSE-Leap-42.1-OpenStack.x86_64.qcow2\",\n});\n```\n```python\nimport pulumi\nimport pulumi_libvirt as libvirt\n\n# A pool for all cluster volumes\ncluster = libvirt.Pool(\"cluster\",\n    name=\"cluster\",\n    type=\"dir\",\n    path=\"/home/user/cluster_storage\")\nopensuse_leap = libvirt.Volume(\"opensuse_leap\",\n    name=\"opensuse_leap\",\n    pool=cluster.name,\n    source=\"http://download.opensuse.org/repositories/Cloud:/Images:/Leap_42.1/images/openSUSE-Leap-42.1-OpenStack.x86_64.qcow2\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Libvirt = Pulumi.Libvirt;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // A pool for all cluster volumes\n    var cluster = new Libvirt.Pool(\"cluster\", new()\n    {\n        Name = \"cluster\",\n        Type = \"dir\",\n        Path = \"/home/user/cluster_storage\",\n    });\n\n    var opensuseLeap = new Libvirt.Volume(\"opensuse_leap\", new()\n    {\n        Name = \"opensuse_leap\",\n        Pool = cluster.Name,\n        Source = \"http://download.opensuse.org/repositories/Cloud:/Images:/Leap_42.1/images/openSUSE-Leap-42.1-OpenStack.x86_64.qcow2\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-libvirt/sdk/go/libvirt\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t// A pool for all cluster volumes\n\t\tcluster, err := libvirt.NewPool(ctx, \"cluster\", \u0026libvirt.PoolArgs{\n\t\t\tName: pulumi.String(\"cluster\"),\n\t\t\tType: pulumi.String(\"dir\"),\n\t\t\tPath: pulumi.String(\"/home/user/cluster_storage\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = libvirt.NewVolume(ctx, \"opensuse_leap\", \u0026libvirt.VolumeArgs{\n\t\t\tName:   pulumi.String(\"opensuse_leap\"),\n\t\t\tPool:   cluster.Name,\n\t\t\tSource: pulumi.String(\"http://download.opensuse.org/repositories/Cloud:/Images:/Leap_42.1/images/openSUSE-Leap-42.1-OpenStack.x86_64.qcow2\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.libvirt.Pool;\nimport com.pulumi.libvirt.PoolArgs;\nimport com.pulumi.libvirt.Volume;\nimport com.pulumi.libvirt.VolumeArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        // A pool for all cluster volumes\n        var cluster = new Pool(\"cluster\", PoolArgs.builder()        \n            .name(\"cluster\")\n            .type(\"dir\")\n            .path(\"/home/user/cluster_storage\")\n            .build());\n\n        var opensuseLeap = new Volume(\"opensuseLeap\", VolumeArgs.builder()        \n            .name(\"opensuse_leap\")\n            .pool(cluster.name())\n            .source(\"http://download.opensuse.org/repositories/Cloud:/Images:/Leap_42.1/images/openSUSE-Leap-42.1-OpenStack.x86_64.qcow2\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # A pool for all cluster volumes\n  cluster:\n    type: libvirt:Pool\n    properties:\n      name: cluster\n      type: dir\n      path: /home/user/cluster_storage\n  opensuseLeap:\n    type: libvirt:Volume\n    name: opensuse_leap\n    properties:\n      name: opensuse_leap\n      pool: ${cluster.name}\n      source: http://download.opensuse.org/repositories/Cloud:/Images:/Leap_42.1/images/openSUSE-Leap-42.1-OpenStack.x86_64.qcow2\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "properties": {
                "allocation": {
                    "type": "integer"
                },
                "available": {
                    "type": "integer"
                },
                "capacity": {
                    "type": "integer"
                },
                "name": {
                    "type": "string",
                    "description": "A unique name for the resource, required by libvirt.\n"
                },
                "path": {
                    "type": "string",
                    "description": "The directory where the pool will keep all its volumes. This is only relevant to (and required by)\nthe \"dir\" type pools.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The type of the pool. Currently, only \"dir\" supported.\n"
                },
                "xml": {
                    "$ref": "#/types/libvirt:index/PoolXml:PoolXml"
                }
            },
            "required": [
                "allocation",
                "available",
                "capacity",
                "name",
                "type"
            ],
            "inputProperties": {
                "allocation": {
                    "type": "integer",
                    "willReplaceOnChanges": true
                },
                "available": {
                    "type": "integer",
                    "willReplaceOnChanges": true
                },
                "capacity": {
                    "type": "integer",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "A unique name for the resource, required by libvirt.\n",
                    "willReplaceOnChanges": true
                },
                "path": {
                    "type": "string",
                    "description": "The directory where the pool will keep all its volumes. This is only relevant to (and required by)\nthe \"dir\" type pools.\n",
                    "willReplaceOnChanges": true
                },
                "type": {
                    "type": "string",
                    "description": "The type of the pool. Currently, only \"dir\" supported.\n",
                    "willReplaceOnChanges": true
                },
                "xml": {
                    "$ref": "#/types/libvirt:index/PoolXml:PoolXml",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "type"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Pool resources.\n",
                "properties": {
                    "allocation": {
                        "type": "integer",
                        "willReplaceOnChanges": true
                    },
                    "available": {
                        "type": "integer",
                        "willReplaceOnChanges": true
                    },
                    "capacity": {
                        "type": "integer",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "A unique name for the resource, required by libvirt.\n",
                        "willReplaceOnChanges": true
                    },
                    "path": {
                        "type": "string",
                        "description": "The directory where the pool will keep all its volumes. This is only relevant to (and required by)\nthe \"dir\" type pools.\n",
                        "willReplaceOnChanges": true
                    },
                    "type": {
                        "type": "string",
                        "description": "The type of the pool. Currently, only \"dir\" supported.\n",
                        "willReplaceOnChanges": true
                    },
                    "xml": {
                        "$ref": "#/types/libvirt:index/PoolXml:PoolXml",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "libvirt:index/volume:Volume": {
            "description": "Manages a storage volume in libvirt. For more information see\n[the official documentation](https://libvirt.org/formatstorage.html).\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as libvirt from \"@pulumi/libvirt\";\n\n// Base OS image to use to create a cluster of different\n// nodes\nconst opensuseLeap = new libvirt.Volume(\"opensuse_leap\", {\n    name: \"opensuse_leap\",\n    source: \"http://download.opensuse.org/repositories/Cloud:/Images:/Leap_42.1/images/openSUSE-Leap-42.1-OpenStack.x86_64.qcow2\",\n});\n// volume to attach to the \"master\" domain as main disk\nconst master = new libvirt.Volume(\"master\", {\n    name: \"master.qcow2\",\n    baseVolumeId: opensuseLeap.id,\n});\n// volumes to attach to the \"workers\" domains as main disk\nconst worker: libvirt.Volume[] = [];\nfor (const range = {value: 0}; range.value \u003c workersCount; range.value++) {\n    worker.push(new libvirt.Volume(`worker-${range.value}`, {\n        name: `worker_${range.value}.qcow2`,\n        baseVolumeId: opensuseLeap.id,\n    }));\n}\n```\n```python\nimport pulumi\nimport pulumi_libvirt as libvirt\n\n# Base OS image to use to create a cluster of different\n# nodes\nopensuse_leap = libvirt.Volume(\"opensuse_leap\",\n    name=\"opensuse_leap\",\n    source=\"http://download.opensuse.org/repositories/Cloud:/Images:/Leap_42.1/images/openSUSE-Leap-42.1-OpenStack.x86_64.qcow2\")\n# volume to attach to the \"master\" domain as main disk\nmaster = libvirt.Volume(\"master\",\n    name=\"master.qcow2\",\n    base_volume_id=opensuse_leap.id)\n# volumes to attach to the \"workers\" domains as main disk\nworker = []\nfor range in [{\"value\": i} for i in range(0, workers_count)]:\n    worker.append(libvirt.Volume(f\"worker-{range['value']}\",\n        name=f\"worker_{range['value']}.qcow2\",\n        base_volume_id=opensuse_leap.id))\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Libvirt = Pulumi.Libvirt;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // Base OS image to use to create a cluster of different\n    // nodes\n    var opensuseLeap = new Libvirt.Volume(\"opensuse_leap\", new()\n    {\n        Name = \"opensuse_leap\",\n        Source = \"http://download.opensuse.org/repositories/Cloud:/Images:/Leap_42.1/images/openSUSE-Leap-42.1-OpenStack.x86_64.qcow2\",\n    });\n\n    // volume to attach to the \"master\" domain as main disk\n    var master = new Libvirt.Volume(\"master\", new()\n    {\n        Name = \"master.qcow2\",\n        BaseVolumeId = opensuseLeap.Id,\n    });\n\n    // volumes to attach to the \"workers\" domains as main disk\n    var worker = new List\u003cLibvirt.Volume\u003e();\n    for (var rangeIndex = 0; rangeIndex \u003c workersCount; rangeIndex++)\n    {\n        var range = new { Value = rangeIndex };\n        worker.Add(new Libvirt.Volume($\"worker-{range.Value}\", new()\n        {\n            Name = $\"worker_{range.Value}.qcow2\",\n            BaseVolumeId = opensuseLeap.Id,\n        }));\n    }\n});\n```\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/pulumi/pulumi-libvirt/sdk/go/libvirt\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t// Base OS image to use to create a cluster of different\n\t\t// nodes\n\t\topensuseLeap, err := libvirt.NewVolume(ctx, \"opensuse_leap\", \u0026libvirt.VolumeArgs{\n\t\t\tName:   pulumi.String(\"opensuse_leap\"),\n\t\t\tSource: pulumi.String(\"http://download.opensuse.org/repositories/Cloud:/Images:/Leap_42.1/images/openSUSE-Leap-42.1-OpenStack.x86_64.qcow2\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// volume to attach to the \"master\" domain as main disk\n\t\t_, err = libvirt.NewVolume(ctx, \"master\", \u0026libvirt.VolumeArgs{\n\t\t\tName:         pulumi.String(\"master.qcow2\"),\n\t\t\tBaseVolumeId: opensuseLeap.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// volumes to attach to the \"workers\" domains as main disk\n\t\tvar worker []*libvirt.Volume\n\t\tfor index := 0; index \u003c workersCount; index++ {\n\t\t\tkey0 := index\n\t\t\tval0 := index\n\t\t\t__res, err := libvirt.NewVolume(ctx, fmt.Sprintf(\"worker-%v\", key0), \u0026libvirt.VolumeArgs{\n\t\t\t\tName:         pulumi.String(fmt.Sprintf(\"worker_%v.qcow2\", val0)),\n\t\t\t\tBaseVolumeId: opensuseLeap.ID(),\n\t\t\t})\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tworker = append(worker, __res)\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.libvirt.Volume;\nimport com.pulumi.libvirt.VolumeArgs;\nimport com.pulumi.codegen.internal.KeyedValue;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        // Base OS image to use to create a cluster of different\n        // nodes\n        var opensuseLeap = new Volume(\"opensuseLeap\", VolumeArgs.builder()        \n            .name(\"opensuse_leap\")\n            .source(\"http://download.opensuse.org/repositories/Cloud:/Images:/Leap_42.1/images/openSUSE-Leap-42.1-OpenStack.x86_64.qcow2\")\n            .build());\n\n        // volume to attach to the \"master\" domain as main disk\n        var master = new Volume(\"master\", VolumeArgs.builder()        \n            .name(\"master.qcow2\")\n            .baseVolumeId(opensuseLeap.id())\n            .build());\n\n        // volumes to attach to the \"workers\" domains as main disk\n        for (var i = 0; i \u003c workersCount; i++) {\n            new Volume(\"worker-\" + i, VolumeArgs.builder()            \n                .name(String.format(\"worker_%s.qcow2\", range.value()))\n                .baseVolumeId(opensuseLeap.id())\n                .build());\n\n        \n}\n    }\n}\n```\n```yaml\nresources:\n  # Base OS image to use to create a cluster of different\n  # nodes\n  opensuseLeap:\n    type: libvirt:Volume\n    name: opensuse_leap\n    properties:\n      name: opensuse_leap\n      source: http://download.opensuse.org/repositories/Cloud:/Images:/Leap_42.1/images/openSUSE-Leap-42.1-OpenStack.x86_64.qcow2\n  # volume to attach to the \"master\" domain as main disk\n  master:\n    type: libvirt:Volume\n    properties:\n      name: master.qcow2\n      baseVolumeId: ${opensuseLeap.id}\n  # volumes to attach to the \"workers\" domains as main disk\n  worker:\n    type: libvirt:Volume\n    properties:\n      name: worker_${range.value}.qcow2\n      baseVolumeId: ${opensuseLeap.id}\n    options: {}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n\u003e **Tip:** when provisioning multiple domains using the same base image, create\na `libvirt.Volume` for the base image and then define the domain specific ones\nas based on it. This way the image will not be modified and no extra disk space\nis going to be used for the base image.\n",
            "properties": {
                "baseVolumeId": {
                    "type": "string",
                    "description": "The backing volume (CoW) to use for this volume.\n"
                },
                "baseVolumeName": {
                    "type": "string",
                    "description": "The name of the backing volume (CoW) to use\nfor this volume. Note well: when `base_volume_pool` is not specified the\nvolume is going to be searched inside of `pool`.\n"
                },
                "baseVolumePool": {
                    "type": "string",
                    "description": "The name of the storage pool containing the\nvolume defined by `base_volume_name`.\n"
                },
                "format": {
                    "type": "string"
                },
                "name": {
                    "type": "string",
                    "description": "A unique name for the resource, required by libvirt.\nChanging this forces a new resource to be created.\n"
                },
                "pool": {
                    "type": "string",
                    "description": "The storage pool where the resource will be created.\nIf not given, the `default` storage pool will be used.\n"
                },
                "size": {
                    "type": "integer",
                    "description": "The size of the volume in bytes (if you don't like this,\nhelp fix this issue.\nIf `source` is specified, `size` will be set to the source image file size.\n`size` can be omitted if `source` is specified. `size` will then be set to the source image file size.\n`size` can be omitted if `base_volume_id` or `base_volume_name` is specified. `size` will then be set to the base volume size.\nIf `size` is specified to be bigger than `base_volume_id` or `base_volume_name` size, you can use [cloudinit](https://cloudinit.readthedocs.io) if your OS supports it, with `libvirt.CloudInitDisk` and the [growpart](https://cloudinit.readthedocs.io/en/latest/topics/modules.html#growpart) module to resize the partition.\n"
                },
                "source": {
                    "type": "string"
                },
                "xml": {
                    "$ref": "#/types/libvirt:index/VolumeXml:VolumeXml"
                }
            },
            "required": [
                "format",
                "name",
                "size"
            ],
            "inputProperties": {
                "baseVolumeId": {
                    "type": "string",
                    "description": "The backing volume (CoW) to use for this volume.\n",
                    "willReplaceOnChanges": true
                },
                "baseVolumeName": {
                    "type": "string",
                    "description": "The name of the backing volume (CoW) to use\nfor this volume. Note well: when `base_volume_pool` is not specified the\nvolume is going to be searched inside of `pool`.\n",
                    "willReplaceOnChanges": true
                },
                "baseVolumePool": {
                    "type": "string",
                    "description": "The name of the storage pool containing the\nvolume defined by `base_volume_name`.\n",
                    "willReplaceOnChanges": true
                },
                "format": {
                    "type": "string",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "A unique name for the resource, required by libvirt.\nChanging this forces a new resource to be created.\n",
                    "willReplaceOnChanges": true
                },
                "pool": {
                    "type": "string",
                    "description": "The storage pool where the resource will be created.\nIf not given, the `default` storage pool will be used.\n",
                    "willReplaceOnChanges": true
                },
                "size": {
                    "type": "integer",
                    "description": "The size of the volume in bytes (if you don't like this,\nhelp fix this issue.\nIf `source` is specified, `size` will be set to the source image file size.\n`size` can be omitted if `source` is specified. `size` will then be set to the source image file size.\n`size` can be omitted if `base_volume_id` or `base_volume_name` is specified. `size` will then be set to the base volume size.\nIf `size` is specified to be bigger than `base_volume_id` or `base_volume_name` size, you can use [cloudinit](https://cloudinit.readthedocs.io) if your OS supports it, with `libvirt.CloudInitDisk` and the [growpart](https://cloudinit.readthedocs.io/en/latest/topics/modules.html#growpart) module to resize the partition.\n",
                    "willReplaceOnChanges": true
                },
                "source": {
                    "type": "string",
                    "willReplaceOnChanges": true
                },
                "xml": {
                    "$ref": "#/types/libvirt:index/VolumeXml:VolumeXml",
                    "willReplaceOnChanges": true
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Volume resources.\n",
                "properties": {
                    "baseVolumeId": {
                        "type": "string",
                        "description": "The backing volume (CoW) to use for this volume.\n",
                        "willReplaceOnChanges": true
                    },
                    "baseVolumeName": {
                        "type": "string",
                        "description": "The name of the backing volume (CoW) to use\nfor this volume. Note well: when `base_volume_pool` is not specified the\nvolume is going to be searched inside of `pool`.\n",
                        "willReplaceOnChanges": true
                    },
                    "baseVolumePool": {
                        "type": "string",
                        "description": "The name of the storage pool containing the\nvolume defined by `base_volume_name`.\n",
                        "willReplaceOnChanges": true
                    },
                    "format": {
                        "type": "string",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "A unique name for the resource, required by libvirt.\nChanging this forces a new resource to be created.\n",
                        "willReplaceOnChanges": true
                    },
                    "pool": {
                        "type": "string",
                        "description": "The storage pool where the resource will be created.\nIf not given, the `default` storage pool will be used.\n",
                        "willReplaceOnChanges": true
                    },
                    "size": {
                        "type": "integer",
                        "description": "The size of the volume in bytes (if you don't like this,\nhelp fix this issue.\nIf `source` is specified, `size` will be set to the source image file size.\n`size` can be omitted if `source` is specified. `size` will then be set to the source image file size.\n`size` can be omitted if `base_volume_id` or `base_volume_name` is specified. `size` will then be set to the base volume size.\nIf `size` is specified to be bigger than `base_volume_id` or `base_volume_name` size, you can use [cloudinit](https://cloudinit.readthedocs.io) if your OS supports it, with `libvirt.CloudInitDisk` and the [growpart](https://cloudinit.readthedocs.io/en/latest/topics/modules.html#growpart) module to resize the partition.\n",
                        "willReplaceOnChanges": true
                    },
                    "source": {
                        "type": "string",
                        "willReplaceOnChanges": true
                    },
                    "xml": {
                        "$ref": "#/types/libvirt:index/VolumeXml:VolumeXml",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        }
    },
    "functions": {
        "libvirt:index/getNetworkDnsHostTemplate:getNetworkDnsHostTemplate": {
            "inputs": {
                "description": "A collection of arguments for invoking getNetworkDnsHostTemplate.\n",
                "properties": {
                    "hostname": {
                        "type": "string"
                    },
                    "ip": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "hostname",
                    "ip"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getNetworkDnsHostTemplate.\n",
                "properties": {
                    "hostname": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "ip": {
                        "type": "string"
                    },
                    "rendered": {
                        "additionalProperties": {
                            "type": "string"
                        },
                        "type": "object"
                    }
                },
                "required": [
                    "hostname",
                    "ip",
                    "rendered",
                    "id"
                ],
                "type": "object"
            }
        },
        "libvirt:index/getNetworkDnsSrvTemplate:getNetworkDnsSrvTemplate": {
            "inputs": {
                "description": "A collection of arguments for invoking getNetworkDnsSrvTemplate.\n",
                "properties": {
                    "domain": {
                        "type": "string"
                    },
                    "port": {
                        "type": "string"
                    },
                    "priority": {
                        "type": "string"
                    },
                    "protocol": {
                        "type": "string"
                    },
                    "service": {
                        "type": "string"
                    },
                    "target": {
                        "type": "string"
                    },
                    "weight": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "protocol",
                    "service"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getNetworkDnsSrvTemplate.\n",
                "properties": {
                    "domain": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "port": {
                        "type": "string"
                    },
                    "priority": {
                        "type": "string"
                    },
                    "protocol": {
                        "type": "string"
                    },
                    "rendered": {
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "type": "object"
                    },
                    "service": {
                        "type": "string"
                    },
                    "target": {
                        "type": "string"
                    },
                    "weight": {
                        "type": "string"
                    }
                },
                "required": [
                    "protocol",
                    "rendered",
                    "service",
                    "id"
                ],
                "type": "object"
            }
        },
        "libvirt:index/getNetworkDnsmasqOptionsTemplate:getNetworkDnsmasqOptionsTemplate": {
            "inputs": {
                "description": "A collection of arguments for invoking getNetworkDnsmasqOptionsTemplate.\n",
                "properties": {
                    "optionName": {
                        "type": "string"
                    },
                    "optionValue": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "optionName"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getNetworkDnsmasqOptionsTemplate.\n",
                "properties": {
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "optionName": {
                        "type": "string"
                    },
                    "optionValue": {
                        "type": "string"
                    },
                    "rendered": {
                        "additionalProperties": {
                            "type": "string"
                        },
                        "type": "object"
                    }
                },
                "required": [
                    "optionName",
                    "rendered",
                    "id"
                ],
                "type": "object"
            }
        }
    }
}